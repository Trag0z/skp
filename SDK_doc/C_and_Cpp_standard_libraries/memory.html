<HTML><HEAD>
<TITLE>&lt;memory&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;memory&gt;"></A><CODE>&lt;memory&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#addressof">addressof</A>
&middot; <A HREF="#allocate_shared">allocate_shared</A>
&middot; <A HREF="#allocator">allocator</A>
&middot; <A HREF="#allocator_arg">allocator_arg</A>
&middot; <A HREF="#allocator_arg_t">allocator_arg_t</A>
&middot; <A HREF="#allocator_traits">allocator_traits</A>
&middot; <A HREF="#auto_ptr">auto_ptr</A>
&middot; <A HREF="#auto_ptr_ref">auto_ptr_ref</A>
&middot; <A HREF="#bad_weak_ptr">bad_weak_ptr</A>
&middot; <A HREF="#const_pointer_cast">const_pointer_cast</A>
&middot; <A HREF="#default_delete">default_delete</A>
&middot; <A HREF="#default_delete_arr">default_delete&lt;Ty&gt;</A>
&middot; <A HREF="#dynamic_pointer_cast">dynamic_pointer_cast</A>
&middot; <A HREF="#enable_shared_from_this">enable_shared_from_this</A>
&middot; <A HREF="#get_deleter">get_deleter</A>
&middot; <A HREF="#get_temporary_buffer">get_temporary_buffer</A>
&middot; <A HREF="#hash">hash</A>
&middot; <A HREF="#make_shared">make_shared</A>
&middot; <A HREF="#operator!2">operator!=</A>
&middot; <A HREF="#operator22">operator==</A>
&middot; <A HREF="#operator&lt;">operator&lt;</A>
&middot; <A HREF="#operator&gt;">operator&gt;</A>
&middot; <A HREF="#operator&lt;2">operator&lt;=</A>
&middot; <A HREF="#operator&gt;2">operator&gt;=</A>
&middot; <A HREF="#operator&lt;&lt;">operator&lt;&lt;</A>
&middot; <A HREF="#owner_less">owner_less</A>
&middot; <A HREF="#pointer_traits">pointer_traits</A>
&middot; <A HREF="#raw_storage_iterator">raw_storage_iterator</A>
&middot; <A HREF="#shared_ptr">shared_ptr</A>
&middot; <A HREF="#static_pointer_cast">static_pointer_cast</A>
&middot; <A HREF="#swap">swap</A>
&middot; <A HREF="#uninitialized_copy">uninitialized_copy</A>
&middot; <A HREF="#uninitialized_copy_n">uninitialized_copy_n</A>
&middot; <A HREF="#uninitialized_fill">uninitialized_fill</A>
&middot; <A HREF="#uninitialized_fill_n">uninitialized_fill_n</A>
&middot; <A HREF="#unique_ptr">unique_ptr</A>
&middot; <A HREF="#unique_ptr_arr">unique_ptr&lt;Ty, Del&gt;</A>
&middot; <A HREF="#uses_allocator">uses_allocator</A>
&middot; <A HREF="#weak_ptr">weak_ptr</A>
</CODE></B></P>

<P><B><CODE><A HREF="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</A>
&middot; <A HREF="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</A>
&middot; <A HREF="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</A>
&middot; <A HREF="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</A>
&middot; <A HREF="#atomic_exchange">atomic_exchange</A>
&middot; <A HREF="#atomic_exchange_explicit">atomic_exchange_explicit</A>
&middot; <A HREF="#atomic_is_lock_free">atomic_is_lock_free</A>
&middot; <A HREF="#atomic_load">atomic_load</A>
&middot; <A HREF="#atomic_load_explicit">atomic_load_explicit</A>
&middot; <A HREF="#atomic_store">atomic_store</A>
&middot; <A HREF="#atomic_store_explicit">atomic_store_explicit</A>
</CODE></B></P>

<P><B><CODE><A HREF="#declare_no_pointers">declare_no_pointers</A>
&middot; <A HREF="#declare_reachable">declare_reachable</A>
&middot; <A HREF="#get_pointer_safety">get_pointer_safety</A>
&middot; <A HREF="#pointer_safety">pointer_safety</A>
&middot; <A HREF="#undeclare_no_pointers">undeclare_no_pointers</A>
&middot; <A HREF="#undeclare_reachable">undeclare_reachable</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;memory&gt;</CODE></B>
to define numerous classes, operators, and templates that help
manage memory.</P>

<PRE>namespace std {
        // TEMPLATE ALLOCATORS
template&lt;class Ty&gt;
    class <B><A HREF="#allocator">allocator</A></B>;
template&lt;&gt;
    class <B><A HREF="#allocator&lt;void&gt;">allocator&lt;void&gt;</A></B>;
template&lt;class OutIt, class Ty&gt;
    class <B><A HREF="#raw_storage_iterator">raw_storage_iterator</A></B>;
template&lt;class Ty&gt;
    class <B><A HREF="#auto_ptr">auto_ptr</A></B>; <B>[deprecated with C++11]</B>
template&lt;class Ty&gt;
    class <B><A HREF="#auto_ptr_ref">auto_ptr_ref</A></B>; <B>[deprecated with C++11]</B>

template&lt;class Ty1, class Ty2&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(const allocator&lt;Ty1&gt;&amp; left,
        const allocator&lt;Ty2&gt;&amp; right) throw();
template&lt;class Ty1, class Ty2&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(const allocator&lt;Ty1&gt;&amp; left,
        const allocator&lt;Ty2&gt;&amp; right) throw();

        // TEMPLATE FUNCTIONS
template&lt;class Ty&gt;
    Ty *<B><A HREF="#addressof">addressof</A></B>(Ty&amp; val) noexcept; <B>[added with C++11]</B>

template&lt;class Ty&gt;
    pair&lt;Ty *, ptrdiff_t&gt;
        <B><A HREF="#get_temporary_buffer">get_temporary_buffer</A></B>(ptrdiff_t count) noexcept;
template&lt;class Ty&gt;
    void <B><A HREF="#return_temporary_buffer">return_temporary_buffer</A></B>(Ty *pbuf);

template&lt;class InIt, class FwdIt&gt;
    FwdIt <B><A HREF="#uninitialized_copy">uninitialized_copy</A></B>(InIt first, InIt last,
        FwdIt dest);
template&lt;class InIt, class Diff, class FwdIt&gt;
    FwdIt <B><A HREF="#uninitialized_copy_n">uninitialized_copy_n</A></B>(InIt first, Diff count,
        FwdIt dest); <B>[added with C++11]</B>
template&lt;class FwdIt, class Ty&gt;
    void <B><A HREF="#uninitialized_fill">uninitialized_fill</A></B>(FwdIt first, FwdIt last,
        const Ty&amp; val);
template&lt;class FwdIt, class Size, class Ty&gt;
    FwdIt <B><A HREF="#uninitialized_fill_n">uninitialized_fill_n</A></B>(FwdIt first, Size count,
        const Ty&amp; val);

        // TEMPLATE UNIQUE POINTERS
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B><A HREF="#default_delete">default_delete</A></B>;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B><A HREF="#default_delete_arr">default_delete&lt;Ty[]&gt;</A></B>;

template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    class <B><A HREF="#unique_ptr">unique_ptr</A></B>;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    class <B><A HREF="#unique_ptr_arr">unique_ptr&lt;Ty[], Del&gt;</A></B>;

template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    class <B><A HREF="#hash">hash&lt;unique_ptr&lt;Ty, Del&gt;&gt;</A></B> {
    size_t <B>operator()</B>(unique_ptr&lt;Ty, Del&gt; val) const;
    };

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator22">operator==</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator22">operator==</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator22">operator==</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator!2">operator!=</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator!2">operator!=</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator!2">operator!=</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);

template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    void <B><A HREF="#swap">swap</A></B>(unique_ptr&lt;Ty, Del&gt;&amp; left,
        unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;

        // TEMPLATE SHARED POINTERS
template&lt;class Ty&gt; <B>[added with C++11]</B>
    class <B><A HREF="#shared_ptr">shared_ptr</A></B>;

template&lt;class Ty&gt; <B>[added with C++11]</B>
    class <B><A HREF="#hash">hash&lt;shared_ptr&lt;Ty&gt;&gt;</A></B> {
    size_t <B>operator()</B>(shared_ptr&lt;Ty&gt; val) const;
    };

template&lt;class Ty&gt;
    bool <B><A HREF="#atomic_is_lock_free">atomic_is_lock_free</A></B>(const shared_ptr&lt;Ty&gt; *Ptr);
template&lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#atomic_load">atomic_load</A></B>(const shared_ptr&lt;Ty&gt; *Ptr);
template&lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#atomic_load_explicit">atomic_load_explicit</A></B>(const shared_ptr&lt;Ty&gt; *Ptr,
        memory_order Order);
template&lt;class Ty&gt;
    void <B><A HREF="#atomic_store">atomic_store</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other);
template&lt;class Ty&gt;
    void <B><A HREF="#atomic_store_explicit">atomic_store_explicit</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other, memory_order Order);
template&lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#atomic_exchange">atomic_exchange</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other);
template&lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#atomic_exchange_explicit">atomic_exchange_explicit</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other, memory_order Order);
template&lt;class Ty&gt;
    bool <B><A HREF="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value);
template&lt;class Ty&gt;
    bool <B><A HREF="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value,
        memory_order Order1, memory_order Order2);
template&lt;class Ty&gt;
    bool <B><A HREF="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value);
template&lt;class Ty&gt;
    bool <B><A HREF="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</A></B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value,
        memory_order Order1, memory_order Order2);

template&lt;class Ty1, class Ty2&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator22">operator==</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator22">operator==</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Ty2&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator!2">operator!=</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator!2">operator!=</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Ty2&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Ty2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Ty2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Ty2&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Elem, class Tr, class Ty&gt;
    basic_ostream&lt;Elem, Tr&gt;&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Tr&gt;&amp; out,
        const shared_ptr&lt;Ty&gt;&amp; sp);

template&lt;class Ty&gt;
    void <B><A HREF="#swap">swap</A></B>(shared_ptr&lt;Ty&gt;&amp; left,
        shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class D, class Ty&gt;
    D *<B><A HREF="#get_deleter">get_deleter</A></B>(const shared_ptr&lt;Ty&gt;&amp; sp) noexcept;

        // TEMPLATE WEAK POINTERS
template&lt;class Ty&gt;
    class <B><A HREF="#weak_ptr">weak_ptr</A></B>;
template&lt;class Ty&gt;
    void <B><A HREF="#swap">swap</A></B>(weak_ptr&lt;Ty&gt;&amp; left,
        weak_ptr&lt;Ty&gt;&amp; right) noexcept;

        // UTILITY TEMPLATE CLASSES
template&lt;class Ty&gt;
    class <B><A HREF="#enable_shared_from_this">enable_shared_from_this</A></B>;
class <B><A HREF="#bad_weak_ptr">bad_weak_ptr</A></B>;

struct <B><A HREF="#allocator_arg_t">allocator_arg_t</A></B>;
constexpr allocator_arg_t <B><A HREF="#allocator_arg">allocator_arg</A></B> =
    allocator_arg_t();

template&lt;class Ptr&gt;
    struct <B><A HREF="#pointer_traits">pointer_traits</A></B>; <B>[added with C++11]</B>
template&lt;class Ty&gt;
    struct <B><A HREF="#pointer_traits_ptr">pointer_traits&lt;Ty *&gt;</A></B>; <B>[added with C++11]</B>

template&lt;class Alloc&gt;
    struct <B><A HREF="#allocator_traits">allocator_traits</A></B>; <B>[added with C++11]</B>
template&lt;class Ty, class Alloc&gt;
    struct <B><A HREF="#uses_allocator">uses_allocator</A></B>; <B>[added with C++11]</B>

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Other&gt;
    shared_ptr&lt;Ty&gt;
        <B><A HREF="#const_pointer_cast">const_pointer_cast</A></B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
template&lt;class Ty, class Other&gt;
    shared_ptr&lt;Ty&gt;
        <B><A HREF="#dynamic_pointer_cast">dynamic_pointer_cast</A></B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
template&lt;class Ty, class Other&gt;
    shared_ptr&lt;Ty&gt;
        <B><A HREF="#static_pointer_cast">static_pointer_cast</A></B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;

template&lt;class Ty, class... Types&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#make_shared">make_shared</A></B>(Types&amp;&amp;... args); <B>[added with C++11]</B>
template&lt;class Ty, class Alloc, class... Types&gt;
    shared_ptr&lt;Ty&gt; <B><A HREF="#allocate_shared">allocate_shared</A></B>(Alloc&amp; al, Types&amp;&amp;... args); <B>[added with C++11]</B>

        // FUNCTIONS
void *<B><A HREF="#align">align</A></B>(size_t alignment, size_t size,
    void *&amp; ptr, size_t&amp; space); <B>[added with C++11]</B>
    namespace tr1 {
using std::allocate_shared; using std::bad_weak_ptr; <B>[added with C++11]</B>
using std::const_pointer_cast; using std::dynamic_pointer_cast;
using std::enable_shared_from_this; using std::get_deleter;
using std::hash; using std::shared_ptr;
using std::static_pointer_cast; using std::unique_ptr;
using std::weak_ptr;
    } // namespace tr1

        // FUNCTORS
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B><A HREF="#owner_less">owner_less</A></B>; // not defined
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B><A HREF="#owner_less">owner_less</A>&lt;shared_ptr&lt;Ty&gt; &gt;</B>;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B><A HREF="#owner_less">owner_less</A>&lt;weak_ptr&lt;Ty&gt; &gt;</B>;

        // POINTER SAFETY
enum class <B><A HREF="#pointer_safety">pointer_safety</A></B> { <B>[added with C++11]</B>&nbsp;
    <B>relaxed</B>, <B>preferred</B>, <B>strict</B>
    };

void <B><A HREF="#declare_reachable">declare_reachable</A></B>(void *ptr); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    Ty *<B><A HREF="#undeclare_reachable">undeclare_reachable</A></B>(Ty *ptr); <B>[added with C++11]</B>
void <B><A HREF="#declare_no_pointers">declare_no_pointers</A></B>(char *ptr, size_t size); <B>[added with C++11]</B>
void <B><A HREF="#undeclare_no_pointers">undeclare_no_pointers</A></B>(char *ptr, size_t size); <B>[added with C++11]</B>
pointer_safety <B><A HREF="#get_pointer_safety">get_pointer_safety</A></B>() noexcept; <B>[added with C++11]</B>
}  // namespace std</PRE>

<H2><A NAME="addressof"></A><CODE>addressof</CODE></H2>

<PRE>template&lt;class Ty&gt;
    Ty *<B>addressof</B>(Ty&amp; val) noexcept; <B>[added with C++11]</B></PRE>

<P>The template function returns the address of <CODE>val</CODE>.</P>

<H3><A NAME="align"></A><CODE>align</CODE></H3>

<PRE>void *<B>align</B>(size_t alignment, size_t size,
    void *&amp; ptr, size_t&amp; space); <B>[added with C++11]</B></PRE>

<P>The function determines whether <CODE>space</CODE> bytes of storage
aligned to <CODE>alignment</CODE> (a power of two bytes) can be located
within the <CODE>size</CODE>-byte buffer beginning at <CODE>ptr</CODE>.
If so, it updates <CODE>ptr</CODE> to point just past the first available
instance of such aligned storage, reduces <CODE>space</CODE> to the number
of bytes remaining after the aligned storage, and returns the address of
the beginning of the aligned storage. If not, it leaves <CODE>ptr</CODE>
and <CODE>space</CODE> unchanged and returns a null pointer.</P>

<H2><A NAME="allocate_shared"></A><CODE>allocate_shared</CODE></H2>

<PRE>template&lt;class Ty, class Alloc, class... Types&gt;
    shared_ptr&lt;Ty&gt; <B>allocate_shared</B>(Alloc&amp; al, Types&amp;&amp;... args); <B>[added with C++11]</B></PRE>

<P>The function creates the object <CODE>shared_ptr&lt;Ty&gt;ptr</CODE>, where
<CODE>ptr</CODE> is a pointer to <CODE>Ty(args...)</CODE> as allocated and constructed by
<CODE>al</CODE>.</P>

<H2><A NAME="allocator"></A><CODE>allocator</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>allocator</B> {
public:
    typedef Ty <B><A HREF="#allocator__value_type">value_type</A></B>;

    typedef size_t <B><A HREF="#allocator__size_type">size_type</A></B>;
    typedef ptrdiff_t <B><A HREF="#allocator__difference_type">difference_type</A></B>;

    typedef Ty *<B><A HREF="#allocator__pointer">pointer</A></B>;
    typedef const Ty *<B><A HREF="#allocator__const_pointer">const_pointer</A></B>;
    typedef void *<B><A HREF="#allocator__void_pointer">void_pointer</A></B>; <B>[added with C++11]</B>
    typedef const void *<B><A HREF="#allocator__const_void_pointer">const_void_pointer</A></B>; <B>[added with C++11]</B>

    typedef Ty&amp; <B><A HREF="#allocator__reference">reference</A></B>;
    typedef const Ty&amp; <B><A HREF="#allocator__const_reference">const_reference</A></B>;

    Ty *<B><A HREF="#allocator__address">address</A></B>(reference val) const noexcept;
    const Ty *<B><A HREF="#allocator__address">address</A></B>(const_reference val) const noexcept;

    template&lt;class Other&gt;
        struct <B><A HREF="#allocator__rebind">rebind</A></B>;

    <B><A HREF="#allocator__allocator">allocator</A></B>() throw();
    template&lt;class Other&gt;
        <B><A HREF="#allocator__allocator">allocator</A></B>(const allocator&lt;Other&gt;&amp; right) throw();
    template&lt;class Other&gt;
        allocator&amp; <B><A HREF="#allocator__operator2">operator=</A></B>(const allocator&lt;Other&gt;&amp; right);

    pointer <B><A HREF="#allocator__allocate">allocate</A></B>(size_type count,
        typename allocator&lt;void&gt;::const_pointer *hint = 0);
    void <B><A HREF="#allocator__deallocate">deallocate</A></B>(pointer ptr, size_type count);

    void <B><A HREF="#allocator__construct">construct</A></B>(Ty *ptr, const Ty&amp; val);
    template&lt;class Uty, class Types&gt;
        void <B><A HREF="#allocator__construct">construct</A></B>(Uty *ptr, Types&amp;&amp;... args); <B>[added with C++11]</B>
    void <B><A HREF="#allocator__destroy">destroy</A></B>(Ty *ptr);
    template&lt;class Uty&gt;
        void <B><A HREF="#allocator__destroy">destroy</A></B>(Uty *ptr); <B>[added with C++11]</B>

    size_type <B><A HREF="#allocator__max_size">max_size</A></B>() const throw();
    };</PRE>

<P>The template class describes an object that manages
storage allocation and freeing for arrays of objects of non-const,
non-reference, object type <CODE>Ty</CODE>.
An object of class <CODE>allocator</CODE> is the default
<B><A NAME="allocator_object"></A>allocator object</B>
specified in the constructors for several
container template classes in the Standard C++ library.</P>

<P>Template class <CODE>allocator</CODE> supplies several
type definitions that are rather pedestrian,
but another class with the same members
might choose more interesting alternatives.
Constructing a container with an allocator object of such a class
gives individual control over allocation and freeing
of elements controlled by that container.</P>

<P>For example, an allocator object might allocate storage on a
<B><A NAME="private_heap"></A>private heap</B>.
Or it might allocate storage requiring nonstandard
pointers to access the allocated objects.
Hence, a class that allocates storage using an allocator object
should use these types religiously
(as do the containers in the Standard C++ library) for declaring pointer
objects, for allocating storage, and for freeing storage.</P>

<P>Thus, an allocator defines the types (among others):</P>

<UL>
<LI><A HREF="#allocator__pointer"><CODE>pointer</CODE></A>
-- behaves like a pointer to <CODE>Ty</CODE></LI>

<LI><A HREF="#allocator__const_pointer"><CODE>const_pointer</CODE></A>
-- behaves like a
const pointer to <CODE>Ty</CODE></LI>

<LI><A HREF="#allocator__void_pointer"><CODE>void_pointer</CODE></A>
-- behaves like a pointer to <CODE>void</CODE></LI>

<LI><A HREF="#allocator__const_void_pointer"><CODE>const_void_pointer</CODE></A>
-- behaves like a
pointer to <CODE>const void</CODE></LI>
</UL>

<P>These types specify the form that pointers take for allocated elements.
Note that <CODE>allocator::pointer</CODE> is not necessarily a
<B><A NAME="raw_pointer"></A>raw pointer</B> (an object that can be
declared as <CODE>Ty *</CODE>) for all allocator objects, even though
it has this obvious definition for class <CODE>allocator</CODE>.
You can convert any of these pointer types to raw pointers, but you
cannot necessarily convert raw pointers back to these pointer types.
The set of operations permissible for allocator pointers is described
by the template class
<A HREF="#pointer_traits">pointer_traits</A>.</P>


<H3><A NAME="allocator__address"></A><CODE>allocator::address</CODE></H3>

<PRE>Ty *<B><A HREF="#allocator__address">address</A></B>(reference val) const noexcept;
const Ty *<B><A HREF="#allocator__address">address</A></B>(const_reference val) const noexcept;</PRE>

<P>The member functions return the address of <CODE>val</CODE>,
as a <A HREF="#raw_pointer">raw pointer</A>.</P>

<H3><A NAME="allocator__allocate"></A><CODE>allocator::allocate</CODE></H3>

<PRE>pointer <B>allocate</B>(size_type count,
    typename allocator&lt;void&gt;::const_pointer *hint = 0);</PRE>

<P>The member function allocates storage for
an array of <CODE>count</CODE> elements of type <CODE>Ty</CODE>, by calling
<CODE>::operator new(count)</CODE>.
It returns a pointer to the allocated object.
The <CODE>hint</CODE> argument helps some allocators
in improving locality of reference -- a valid choice
is the address of an object earlier allocated by the same allocator
object, and not yet deallocated.
A null pointer argument is taken as no hint.</P>

<H3><A NAME="allocator__allocator"></A><CODE>allocator::allocator</CODE></H3>

<PRE><B>allocator</B>() throw();
template&lt;class Other&gt;
    <B>allocator</B>(const allocator&lt;Other&gt;&amp; right) throw();</PRE>

<P>The constructor does nothing. In general, however, an allocator object
constructed from another allocator object should compare equal to it
(and hence permit intermixing of object allocation and freeing between
the two allocator objects).</P>


<H3><A NAME="allocator__const_pointer"></A><CODE>allocator::const_pointer</CODE></H3>

<PRE>typedef const Ty *<B>const_pointer</B>;</PRE>

<P>The pointer type describes an object <CODE>ptr</CODE> that can
designate, via the expression <CODE>*ptr</CODE>, any const object
that an object of template class
<CODE>allocator</CODE> can allocate.</P>

<H3><A NAME="allocator__const_reference"></A><CODE>allocator::const_reference</CODE></H3>

<PRE>typedef const Ty&amp; <B>const_reference</B>;</PRE>

<P>The reference type describes a reference to a const object.</P>

<H3><A NAME="allocator__const_void_pointer"></A><CODE>allocator::const_void_pointer</CODE></H3>

<PRE>typedef const void *<B>const_void_pointer</B>; <B>[added with C++11]</B></PRE>

<P>The pointer type describes an object <CODE>ptr</CODE> that can
represent any object of type <CODE>const_pointer</CODE>,
but does not designate any object.</P>

<H3><A NAME="allocator__construct"></A><CODE>allocator::construct</CODE></H3>

<PRE>void <B>construct</B>(Ty *ptr, const Ty&amp; val);
template&lt;class Uty, class Types&gt;
    void <B>construct</B>(Uty *ptr, Types&amp;&amp;... args); <B>[added with C++11]</B></PRE>

<P>The first member function constructs an object of type <CODE>Ty</CODE>
at <CODE>ptr</CODE> by evaluating the placement
<CODE>new</CODE> expression <CODE>new ((void *)ptr) Ty(val)</CODE>.</P>

<P>The second member function behaves the same as the first, but can
construct an object of any type <CODE>Uty</CODE>, with any constructor
arguments <CODE>Types&amp;&amp;...</CODE>.</P>

<H3><A NAME="allocator__deallocate"></A><CODE>allocator::deallocate</CODE></H3>

<PRE>void <B>deallocate</B>(pointer ptr, size_type count);</PRE>

<P>The member function frees storage for
the array of <CODE>count</CODE> objects of type
<CODE>Ty</CODE> beginning at <CODE>ptr</CODE>, by calling
<CODE>::operator delete(ptr)</CODE>.
The pointer <CODE>ptr</CODE> must have been earlier returned by a call to
<CODE><A HREF="#allocator__allocate">allocate</A></CODE> for an allocator
object that compares equal to <CODE>*this</CODE>, allocating an array object
of the same size and type.</P>

<P>The member function throws nothing.</P>

<H3><A NAME="allocator__destroy"></A><CODE>allocator::destroy</CODE></H3>

<PRE>void <B>destroy</B>(Ty *ptr);
template&lt;class Uty&gt;
    void <B>destroy</B>(Uty *ptr); <B>[added with C++11]</B></PRE>

<P>The first member function destroys the object
designated by <CODE>ptr</CODE>,
by calling the destructor <CODE>ptr-&gt;Ty::~Ty()</CODE>.</P>

<P>The second member function behaves the same as the first, but can
destroy an object of any type <CODE>Uty</CODE>.</P>

<H3><A NAME="allocator__difference_type"></A><CODE>allocator::difference_type</CODE></H3>

<PRE>typedef ptrdiff_t <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in a sequence
that an object of template class <CODE>allocator</CODE> can allocate.</P>

<H3><A NAME="allocator__max_size"></A><CODE>allocator::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const throw();</PRE>

<P>The member function returns the length of the longest sequence
of elements of type <CODE>Ty</CODE> that an object of class
<CODE>allocator</CODE> <I>might</I> be able to allocate.</P>

<H3><A NAME="allocator__operator2"></A><CODE>allocator::operator=</CODE></H3>

<PRE>template&lt;class Other&gt;
    allocator&amp; <B>operator=</B>(const allocator&lt;Other&gt;&amp; right);</PRE>

<P>The template assignment operator does nothing.
In general, however, an allocator object
assigned to another allocator object should compare equal to it
(and hence permit intermixing of object allocation and freeing between
the two allocator objects).</P>


<H3><A NAME="allocator__pointer"></A><CODE>allocator::pointer</CODE></H3>

<PRE>typedef Ty *<B>pointer</B>;</PRE>

<P>The pointer type describes an object <CODE>ptr</CODE> that can
designate, via the expression <CODE>*ptr</CODE>, any object
that an object of template class
<CODE>allocator</CODE> can allocate.</P>

<H3><A NAME="allocator__rebind"></A><CODE>allocator::rebind</CODE></H3>

<PRE>template&lt;class Other&gt;
    struct <B>rebind</B> {
    typedef allocator&lt;Other&gt; <B>other</B>;
    };</PRE>

<P>The member template class defines the type
<B><CODE><A NAME="allocator__other"></A>other</CODE></B>.
Its sole purpose is to provide the type name <CODE>allocator&lt;Other&gt;</CODE>
given the type name <CODE>allocator&lt;Ty&gt;</CODE>.</P>

<P>For example, given an allocator object <CODE>al</CODE> of type
<CODE>A</CODE>, you can allocate an object of type
<CODE>Other</CODE> with the expression:</P>

<PRE>A::rebind&lt;Other&gt;::other(al).allocate(1, (Other *)0)</PRE>

<P>Or, you can simply name its pointer type by writing the type:</P>

<PRE>A::rebind&lt;Other&gt;::other::pointer</PRE>

<H3><A NAME="allocator__reference"></A><CODE>allocator::reference</CODE></H3>

<PRE>typedef Ty&amp; <B>reference</B>;</PRE>

<P>The reference type describes an object that can
designate any object that an object of template class
<CODE>allocator</CODE> can allocate.</P>

<H3><A NAME="allocator__size_type"></A><CODE>allocator::size_type</CODE></H3>

<PRE>typedef size_t <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent
the length of any sequence that an object of template class
<CODE>allocator</CODE> can allocate.</P>

<H3><A NAME="allocator__value_type"></A><CODE>allocator::value_type</CODE></H3>

<PRE>typedef Ty <B>value_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H3><A NAME="allocator__void_pointer"></A><CODE>allocator::void_pointer</CODE></H3>

<PRE>typedef void *<B>void_pointer</B>; <B>[added with C++11]</B></PRE>

<P>The pointer type describes an object <CODE>ptr</CODE> that can
represent any object of type <CODE>pointer</CODE>,
but does not designate any object.</P>

<H2><A NAME="allocator&lt;void&gt;"></A><CODE>allocator&lt;void&gt;</CODE></H2>

<PRE>template&lt;&gt;
    class <B>allocator&lt;void&gt;</B> {
    typedef void *<B>pointer</B>;
    typedef const void *<B>const_pointer</B>;
    typedef void <B>value_type</B>;
    template&lt;class Other&gt;
        struct <B>rebind</B>;
    <B>allocator</B>() throw();
    template&lt;class Other&gt;
        <B>allocator</B>(const allocator&lt;Other&gt;) throw();
    template&lt;class Other&gt;
        allocator&lt;void&gt;&amp; <B>operator=</B>(const allocator&lt;Other&gt;);
    };</PRE>

<P>The class explicitly specializes template class
<A HREF="#allocator">allocator</A> for type <I>void.</I>
Its constructors and assignment operator behave the same as for the
template class, but it defines only the types
<A HREF="#allocator__const_pointer"><CODE>const_pointer</CODE></A>,
<A HREF="#allocator__pointer"><CODE>pointer</CODE></A>,
<A HREF="#allocator__value_type"><CODE>value_type</CODE></A>,
and the nested template class
<A HREF="#allocator__rebind"><CODE>rebind</CODE></A>.</P>

<H2><CODE><A NAME="allocator_arg"></A>allocator_arg</CODE></H2>

<PRE>constexpr allocator_arg_t <B>allocator_arg</B> =
    allocator_arg_t();</PRE>

<P>The object is used as a function argument to match the parameter type
<CODE><A HREF="#allocator_arg_t">allocator_arg_t</A></CODE>.</P>

<H2><CODE><A NAME="allocator_arg_t"></A>allocator_arg_t</CODE></H2>

<PRE>struct <B>allocator_arg_t</B> {};</PRE>

<P>The struct is used as a function parameter to indicate that the
function should expect an allocator argument to follow.</P>

<H2><A NAME="allocator_traits"></A><CODE>allocator_traits</CODE></H2>

<PRE>template&lt;class Alloc&gt;
    class <B>allocator_traits</B> { <B>[added with C++11]</B>
public:
    typedef Alloc <B><A HREF="#allocator_traits__allocator_type">allocator_type</A></B>;
    typedef typename Alloc::value_type <B><A HREF="#allocator_traits__value_type">value_type</A></B>;

    typedef T1 <B><A HREF="#allocator_traits__pointer">pointer</A></B>;
    typedef T2 <B><A HREF="#allocator_traits__const_pointer">const_pointer</A></B>;
    typedef T3 <B><A HREF="#allocator_traits__void_pointer">void_pointer</A></B>;
    typedef T4 <B><A HREF="#allocator_traits__const_void_pointer">const_void_pointer</A></B>;

    typedef T5 <B><A HREF="#allocator_traits__size_type">size_type</A></B>;
    typedef T6 <B><A HREF="#allocator_traits__difference_type">difference_type</A></B>;

    typedef T7 <B><A HREF="#allocator_traits__propagate_on_container_copy_assignment">propagate_on_container_copy_assignment</A></B>;
    typedef T8 <B><A HREF="#allocator_traits__propagate_on_container_move_assignment">propagate_on_container_move_assignment</A></B>;
    typedef T9 <B><A HREF="#allocator_traits__propagate_on_container_swap">propagate_on_container_swap</A></B>;

    template&lt;class Other&gt;
        using <B><A HREF="#allocator_traits__rebind_alloc">rebind_alloc</A></B> = T10;
    template&lt;class Other&gt;
        using <B><A HREF="#allocator_traits__rebind_traits">rebind_traits</A></B> = allocator_traits&lt;rebind_alloc&lt;Other&gt; &gt;;

    static pointer <B><A HREF="#allocator_traits__allocate">allocate</A></B>(Alloc&amp; al, size_type count);
    static pointer <B><A HREF="#allocator_traits__allocate">allocate</A></B>(Alloc&amp; al, size_type count,
        typename allocator_traits&lt;void&gt;::const_pointer *hint);
    static void <B><A HREF="#allocator_traits__deallocate">deallocate</A></B>(Alloc&amp; al,
        pointer ptr, size_type count);

    template&lt;class Uty, class Types&gt;
        static void <B><A HREF="#allocator_traits__construct">construct</A></B>(Alloc&amp; al, Uty *ptr, Tyes&amp;&amp;... args);
    template&lt;class Uty&gt;
        static void <B><A HREF="#allocator_traits__destroy">destroy</A></B>(Alloc&amp; al, Uty *ptr);

    static size_type <B><A HREF="#allocator_traits__max_size">max_size</A></B>(const Alloc&amp; al);
    static Alloc <B><A HREF="#allocator_traits__select_on_container_copy_construction">select_on_container_copy_construction</A></B>(const Alloc&amp; al);
    };</PRE>

<P>The template class describes an object that supplements an
<B><A NAME="allocator_type"></A>allocator type</B> --
any type that describes an
<A HREF="#allocator_object">allocator object</A> used for managing
allocated storage. Specifically, for any allocator type <CODE>Alloc</CODE>,
you can interrogate <CODE>allocator_traits&lt;Alloc&gt;</CODE>
to determine all the information needed by an
<A HREF="#allocator_enabled">allocator enabled</A> container.
This is a superset of the information supplied by the default allocator class
<CODE><A HREF="#allocator">allocator</A></CODE>.</P>

<P>In fact, given an allocator type as simple as:</P>

<PRE>template&lt;class Ty&gt;
    struct Minimal
    {   // minimal allocator for use with allocator_traits
    typedef Ty value_type;

    Alloc();
    template&lt;class Uty&gt;
        Alloc(const Alloc&lt;Uty&gt; other);
    Ty *allocate(size_t count);
    void deallocate(Ty *ptr, size_t count);
    };</PRE>

<P><CODE>allocator_traits&lt;Minimal&lt;Ty&gt; &gt;</CODE> can make educated guesses
about all the omitted type definitions and member functions required by
an allocator enabled container.</P>

<H3><A NAME="allocator_traits__allocator_type"></A><CODE>allocator_traits::allocator_type</CODE></H3>

<PRE>typedef Alloc allocator_type;</PRE>

<P>The type is a synonym for <CODE>Alloc</CODE>.</P>

<H3><A NAME="allocator_traits__allocate"></A><CODE>allocator_traits::allocate</CODE></H3>

<PRE>static pointer <B>allocate</B>(Alloc&amp; al, size_type count);
static pointer <B>allocate</B>(Alloc&amp; al, size_type count,
    typename allocator_traits&lt;void&gt;::const_pointer *hint);</PRE>

<P>The first static member function returns <CODE>al.allocate(al)</CODE>.
The second returns <CODE>al.allocate(al, hint)</CODE>,
if that expression is well formed; otherwise it
returns <CODE>al.allocate(al)</CODE>.</P>

<H3><A NAME="allocator_traits__const_pointer"></A><CODE>allocator_traits::const_pointer</CODE></H3>

<PRE>typedef T2 <B>const_pointer</B>;</PRE>

<P>The type is a synonym for the type <CODE>T2</CODE>, which is
<CODE>Alloc::const_pointer</CODE> if that type is well formed;
otherwise it is
<CODE>pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt;</CODE>.</P>

<H3><A NAME="allocator_traits__const_void_pointer"></A><CODE>allocator_traits::const_void_pointer</CODE></H3>

<PRE>typedef T4 <B>const_void_pointer</B>;</PRE>

<P>The type is a synonym for the type <CODE>T4</CODE>, which is
<CODE>Alloc::const_void_pointer</CODE> if that type is well formed;
otherwise it is
<CODE>pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt;</CODE>.</P>

<H3><A NAME="allocator_traits__construct"></A><CODE>allocator_traits::construct</CODE></H3>

<PRE>template&lt;class Uty, class Types&gt;
    static void <B>construct</B>(Alloc&amp; al, Uty *ptr, Tyes&amp;&amp;... args);</PRE>

<P>The static member function calls <CODE>al.construct(ptr, args...)</CODE>,
if that expression is well formed; otherwise it evaluates
<CODE>::new (static_cast&lt;void *&gt;(ptr)) Uty(std::forward&lt;Types&gt;(args)...)</CODE>.</P>

<H3><A NAME="allocator_traits__deallocate"></A><CODE>allocator_traits::deallocate</CODE></H3>

<PRE>static void <B>deallocate</B>(Alloc al,
    pointer ptr, size_type count);</PRE>

<P>The static member function calls
<CODE>al.deallocate(ptr, count)</CODE>.</P>

<P>The member function throws nothing.</P>

<H3><A NAME="allocator_traits__destroy"></A><CODE>allocator_traits::destroy</CODE></H3>

<PRE>template&lt;class Uty&gt;
    static void <B>destroy</B>(Alloc&amp; al, Uty *ptr);</PRE>

<P>The static member function calls <CODE>al.destroy(ptr)</CODE>,
if that expression is well formed; otherwise it evaluates
<CODE>ptr-&gt;~Uty()</CODE>.</P>

<H3><A NAME="allocator_traits__difference_type"></A><CODE>allocator_traits::difference_type</CODE></H3>

<PRE>typedef T6 <B>difference_type</B>;</PRE>

<P>The type is a synonym for the type <CODE>T6</CODE>, which is
<CODE>Alloc::difference_type</CODE> if that type is well formed;
otherwise it is
<CODE>pointer_traits&lt;pointer&gt;::difference_type</CODE>.</P>

<H3><A NAME="allocator_traits__max_size"></A><CODE>allocator_traits::max_size</CODE></H3>

<PRE>static size_type <B>max_size</B>(const Alloc&amp; al);</PRE>

<P>The static member function returns <CODE>al.max_size()</CODE>,
if that expression is well formed; otherwise it returns
<CODE>numeric_limits&lt;size_type&gt;::max()</CODE>.</P>

<H3><A NAME="allocator_traits__pointer"></A><CODE>allocator_traits::pointer</CODE></H3>

<PRE>typedef T1 <B>pointer</B>;</PRE>

<P>The type is a synonym for the type <CODE>T1</CODE>, which is
<CODE>Alloc::pointer</CODE> if that type is well formed;
otherwise it is <CODE>value_type *</CODE>.</P>

<H3><A NAME="allocator_traits__propagate_on_container_copy_assignment"></A><CODE>allocator_traits::propagate_on_container_copy_assignment</CODE></H3>

<PRE>typedef T7 <B>propagate_on_container_copy_assignment</B>;</PRE>

<P>The type is a synonym for the type <CODE>T7</CODE>, which is
<CODE>Alloc::propagate_on_container_copy_assignment</CODE> if that type is well formed;
otherwise it is <CODE>false_type</CODE>.</P>

<P>If the type
<A HREF="typetrait.html#holds_true">holds true</A>,
an <A HREF="#allocator_enabled">allocator enabled</A> container
copies its stored allocator on a copy assignment.</P>

<H3><A NAME="allocator_traits__propagate_on_container_move_assignment"></A><CODE>allocator_traits::propagate_on_container_move_assignment</CODE></H3>

<PRE>typedef T8 <B>propagate_on_container_move_assignment</B>;</PRE>

<P>The type is a synonym for the type <CODE>T8</CODE>, which is
<CODE>Alloc::propagate_on_container_move_assignment</CODE> if that type is well formed;
otherwise it is <CODE>false_type</CODE>.</P>

<P>If the type
<A HREF="typetrait.html#holds_true">holds true</A>,
an <A HREF="#allocator_enabled">allocator enabled</A> container
copies its stored allocator on a move assignment.</P>

<H3><A NAME="allocator_traits__propagate_on_container_swap"></A><CODE>allocator_traits::propagate_on_container_swap</CODE></H3>

<PRE>typedef T9 <B>propagate_on_container_swap</B>;</PRE>

<P>The type is a synonym for the type <CODE>T9</CODE>, which is
<CODE>Alloc::propagate_on_container_swap</CODE> if that type is well formed;
otherwise it is <CODE>false_type</CODE>.</P>

<P>If the type
<A HREF="typetrait.html#holds_true">holds true</A>,
an <A HREF="#allocator_enabled">allocator enabled</A> container
swaps its stored allocator on a swap.</P>

<H3><A NAME="allocator_traits__rebind_alloc"></A><CODE>allocator_traits::rebind_alloc</CODE></H3>

<PRE>template&lt;class Other&gt;
    using <B>rebind_alloc</B> = T10;</PRE>

<P>The template alias is a synonym for the type <CODE>T10</CODE>, which is
<CODE>Alloc::rebind&lt;Other&gt;::other</CODE> if that type is well formed;
otherwise it is <CODE>Alloc&lt;Other, Types...&gt;</CODE>,
where <CODE>Alloc</CODE> is a template instantiation of the form
<CODE>Alloc&lt;Ty, Types...&gt;</CODE>.</P>

<H3><A NAME="allocator_traits__rebind_traits"></A><CODE>allocator_traits::rebind_traits</CODE></H3>

<PRE>template&lt;class Other&gt;
    using <B>rebind_traits</B> = allocator_traits&lt;rebind_alloc&lt;Other&gt; &gt;;</PRE>

<P>The template alias is a synonym for the type
<CODE>allocator_traits&lt;rebind_alloc&lt;Other&gt; &gt;</CODE>.</P>

<H3><A NAME="allocator_traits__select_on_container_copy_construction"></A><CODE>allocator_traits::select_on_container_copy_construction</CODE></H3>

<PRE>static Alloc <B>select_on_container_copy_construction</B>(const Alloc&amp; al);</PRE>

<P>The static member function returns
<CODE>al.select_on_container_copy_construction()</CODE>,
if that expression is well formed;
otherwise it returns <CODE>al</CODE>.</P>

<P>An <A HREF="#allocator_enabled">allocator enabled</A> container
copies its stored allocator on a copy construction.</P>

<H3><A NAME="allocator_traits__size_type"></A><CODE>allocator_traits::size_type</CODE></H3>

<PRE>typedef T5 <B>size_type</B>;</PRE>

<P>The type is a synonym for the type <CODE>T5</CODE>, which is
<CODE>Alloc::size_type</CODE> if that type is well formed;
otherwise it is
<CODE>make_unsigned&lt;difference_type&gt;::type</CODE>.</P>

<H3><A NAME="allocator_traits__value_type"></A><CODE>allocator_traits::value_type</CODE></H3>

<PRE>typedef Alloc::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Alloc::value_type</CODE>.</P>

<H3><A NAME="allocator_traits__void_pointer"></A><CODE>allocator_traits::void_pointer</CODE></H3>

<PRE>typedef T3 <B>void_pointer</B>;</PRE>

<P>The type is a synonym for the type <CODE>T3</CODE>, which is
<CODE>Alloc::void_pointer</CODE> if that type is well formed;
otherwise it is
<CODE>pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;</CODE>.</P>

<H2><CODE><A NAME="atomic_compare_exchange_strong"></A>atomic_compare_exchange_strong</CODE></H2>

<PRE>template &lt;class Ty&gt;
    bool <B>atomic_compare_exchange_strong</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value);</PRE>

<P>The function returns
<CODE><A HREF="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</A>(Ptr,
Expected, Value, memory_order_seq_cst, memory_order_seq_cst)</CODE>.
<CODE>Ptr</CODE> and <CODE>Expected</CODE> must not be null pointers.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_compare_exchange_strong_explicit"></A>atomic_compare_exchange_strong_explicit</CODE></H2>

<PRE>template &lt;class Ty&gt;
    bool <B>atomic_compare_exchange_strong_explicit</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value,
        memory_order Order1, memory_order Order2);</PRE>

<P>The function performs an
<A HREF="atomic.html#atomic_compare_and_exchange">atomic compare and exchange</A>
operation on its arguments and returns the result. The value of <CODE>order2</CODE>
should not be <CODE>memory_order_release</CODE> or <CODE>memory_order_acq_rel</CODE>,
nor should it be stronger than the value of <CODE>order1</CODE>.
<CODE>Ptr</CODE> and <CODE>Expected</CODE> must not be null pointers.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_compare_exchange_weak"></A>atomic_compare_exchange_weak</CODE></H2>

<PRE>template &lt;class Ty&gt;
    bool <B>atomic_compare_exchange_weak</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value);</PRE>

<P>The function returns
<CODE><A HREF="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</A>(Ptr,
Expected, Value, memory_order_seq_cst, memory_order_seq_cst)</CODE>.
<CODE>Ptr</CODE> and <CODE>Expected</CODE> must not be null pointers.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_compare_exchange_weak_explicit"></A>atomic_compare_exchange_weak_explicit</CODE></H2>

<PRE>template &lt;class Ty&gt;
    bool <B>atomic_compare_exchange_weak_explicit</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; *Expected, shared_ptr&lt;Ty&gt; Value,
        memory_order Order1, memory_order Order2);</PRE>

<P>The function performs a
<A HREF="atomic.html#weak_atomic_compare_and_exchange">weak atomic compare and exchange</A>
operation on its arguments and returns the result. The value of <CODE>order2</CODE>
should not be <CODE>memory_order_release</CODE> or <CODE>memory_order_acq_rel</CODE>,
nor should it be stronger than the value of <CODE>order1</CODE>.
<CODE>Ptr</CODE> and <CODE>Expected</CODE> must not be null pointers.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_exchange"></A>atomic_exchange</CODE></H2>

<PRE>template &lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B>atomic_exchange</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other);</PRE>

<P>The function returns
<CODE><A HREF="#atomic_exchange_explicit">atomic_exchange_explicit</A>(Ptr, Other)</CODE>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_exchange_explicit"></A>atomic_exchange_explicit</CODE></H2>

<PRE>template &lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B>atomic_exchange_explicit</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other, memory_order Order);</PRE>

<P>The function atomically assigns <CODE>Other</CODE> to <CODE>*Ptr</CODE> and
returns the value that <CODE>*Ptr</CODE> had on entry. It applies the memory constraints
specified by <CODE>Order</CODE>, and is a
<A HREF="atomic.html#read-modify-write_operation">read-modify-write operation</A>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_is_lock_free"></A>atomic_is_lock_free</CODE></H2>

<PRE>template &lt;class Ty&gt;
    bool <B>atomic_is_lock_free</B>(const shared_ptr&lt;Ty&gt; *Ptr);</PRE>

<P>The function returns <CODE>true</CODE> only if atomic operations on <CODE>*Ptr</CODE>
are <A HREF="atomic.html#lock_free">lock free</A>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_load"></A>atomic_load</CODE></H2>

<PRE>template &lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B>atomic_load</B>(const shared_ptr&lt;Ty&gt; *Ptr);</PRE>

<P>The function returns
<CODE><A HREF="#atomic_load_explicit">atomic_load_explicit</A>(Ptr, memory_order_seq_cst)</CODE>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_load_explicit"></A>atomic_load_explicit</CODE></H2>

<PRE>template &lt;class Ty&gt;
    shared_ptr&lt;Ty&gt; <B>atomic_load_explicit</B>(const shared_ptr&lt;Ty&gt; *Ptr,
        memory_order Order);</PRE>

<P>The function atomically loads the value of <CODE>*Ptr</CODE> and returns the result.
It applies the memory constraints specified by <CODE>Order</CODE>. The value of <CODE>Order</CODE>
should not be <CODE>memory_order_release</CODE> or <CODE>memory_order_acq_rel</CODE>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_store"></A>atomic_store</CODE></H2>

<PRE>template &lt;class Ty&gt;
    void <B>atomic_store</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other);</PRE>

<P>The function calls
<CODE><A HREF="#atomic_store_explicit">atomic_store_explicit</A>(Ptr,
Other, memory_order_seq_cst)</CODE>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><CODE><A NAME="atomic_store_explicit"></A>atomic_store_explicit</CODE></H2>

<PRE>template &lt;class Ty&gt;
    void <B>atomic_store_explicit</B>(shared_ptr&lt;Ty&gt; *Ptr,
        shared_ptr&lt;Ty&gt; Other, memory_order Order);</PRE>

<P>The function atomically stores <CODE>Other</CODE> in <CODE>*Ptr</CODE>. It applies the
memory constraints specified by <CODE>Order</CODE>. The value of <CODE>Order</CODE> should not
be <CODE>memory_order_consume</CODE>, <CODE>memory_order_acquire</CODE>, or
<CODE>memory_order_acq_rel</CODE>.
<CODE>Ptr</CODE> must not be a null pointer.</P>

<P>The function throws nothing.</P>

<H2><A NAME="auto_ptr"></A><CODE>auto_ptr</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>auto_ptr</B> { <B>[deprecated with C++11]</B>
public:
    typedef Ty <B><A HREF="#auto_ptr__element_type">element_type</A></B>;
    explicit <B><A HREF="#auto_ptr__auto_ptr">auto_ptr</A></B>(Ty *ptr = 0) throw();
    <B><A HREF="#auto_ptr__auto_ptr">auto_ptr</A></B>(auto_ptr&lt;Ty&gt;&amp; right) throw();
    template&lt;class Other&gt;
        <B><A HREF="#auto_ptr__auto_ptr">auto_ptr</A></B>(auto_ptr&lt;Other&gt;&amp; right) throw();
    <B><A HREF="#auto_ptr__auto_ptr">auto_ptr</A></B>(auto_ptr_ref&lt;Ty&gt; right) throw();
    <B><A HREF="#auto_ptr__~auto_ptr">~auto_ptr</A></B>() throw();
    template&lt;class Other&gt;
        <B><A HREF="#auto_ptr__operator_auto_ptr&lt;Other&gt;">operator auto_ptr&lt;Other&gt;</A></B>() throw();
    template&lt;class Other&gt;
        <B><A HREF="#auto_ptr__operator_auto_ptr_ref&lt;Other&gt;">operator auto_ptr_ref&lt;Other&gt;</A></B>() throw();
    template&lt;class Other&gt;
        auto_ptr&lt;Ty&gt;&amp; <B><A HREF="#auto_ptr__operator2">operator=</A></B>(auto_ptr&lt;Other&gt;&amp; right) throw();
    auto_ptr&lt;Ty&gt;&amp; <B><A HREF="#auto_ptr__operator2">operator=</A></B>(auto_ptr&lt;Ty&gt;&amp; right) throw();
    auto_ptr&lt;Ty&gt;&amp; <B><A HREF="#auto_ptr__operator2">operator=</A></B>(auto_ptr_ref&lt;Ty&gt; right) throw();
    Ty&amp; <B><A HREF="#auto_ptr__operator*">operator*</A></B>() const throw();
    Ty *<B><A HREF="#auto_ptr__operator-&gt;">operator-&gt;</A></B>() const throw();
    Ty *<B><A HREF="#auto_ptr__get">get</A></B>() const throw();
    Ty *<B><A HREF="#auto_ptr__release">release</A></B>() throw();
    void <B><A HREF="#auto_ptr__reset">reset</A></B>(Ty *ptr = 0);
    };</PRE>

<P>The class describes an object that stores a pointer to an allocated object
<B><CODE>myptr</CODE></B> of type <CODE>Ty *</CODE>. The stored pointer must either be null or
designate an object allocated by a
<CODE>new</CODE> expression.
An object constructed with a non-null pointer owns the pointer.
It transfers ownership if its stored value is assigned to another
object. (It replaces the stored value after a transfer with a null pointer.)
The destructor for <CODE>auto_ptr&lt;Ty&gt;</CODE>
deletes the allocated object if it owns it.
Hence, an object of class <CODE>auto_ptr&lt;Ty&gt;</CODE>
ensures that an allocated object is automatically deleted when
control leaves a block, even via a thrown exception.
You should not construct two <CODE>auto_ptr&lt;Ty&gt;</CODE> objects
that own the same object.</P>

<P>You can pass an <CODE>auto_ptr&lt;Ty&gt;</CODE> object by value as an
argument to a function call. You can return such an object by value as well.
(Both operations depend on the implicit construction of intermediate objects
of class <CODE>auto_ptr_ref&lt;Ty&gt;</CODE>, by various
subtle conversion rules.) You cannot, however, reliably manage a sequence of
<CODE>auto_ptr&lt;Ty&gt;</CODE> objects with an STL
<A HREF="lib_cont.html#Containers">container</A>.</P>

<H3><A NAME="auto_ptr__auto_ptr"></A><CODE>auto_ptr::auto_ptr</CODE></H3>

<PRE>explicit <B>auto_ptr</B>(Ty *ptr = 0) throw();
<B>auto_ptr</B>(auto_ptr&lt;Ty&gt;&amp; right) throw();
<B>auto_ptr</B>(auto_ptr_ref&lt;Ty&gt; right) throw();
template&lt;class Other&gt;
    <B>auto_ptr</B>(auto_ptr&lt;Other&gt;&amp; right) throw();</PRE>

<P>The first constructor stores <CODE>ptr</CODE> in <CODE>myptr</CODE>,
the stored pointer to the allocated object.
The second constructor transfers ownership of the
pointer stored in <CODE>right</CODE>, by storing
<CODE>right.<A HREF="#auto_ptr__release">release</A>()</CODE>
in <CODE>myptr</CODE>.
The third constructor behaves the same as the second, except
that it stores <CODE>right.ref.release()</CODE> in <CODE>myptr</CODE>, where <CODE>ref</CODE>
is the reference stored in <CODE>right</CODE>.</P>

<P>The template constructor behaves the same as the second constructor,
provided that a pointer to <CODE>Other</CODE> can be implicitly converted
to a pointer to <CODE>Ty</CODE>.</P>

<H3><A NAME="auto_ptr__~auto_ptr"></A><CODE>auto_ptr::~auto_ptr</CODE></H3>

<PRE><B>~auto_ptr</B>() throw();</PRE>

<P>The destructor evaluates the expression <CODE>delete myptr</CODE>
to delete the object designated by the stored pointer.</P>

<H3><A NAME="auto_ptr__element_type"></A><CODE>auto_ptr::element_type</CODE></H3>

<PRE>typedef Ty <B>element_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H3><A NAME="auto_ptr__get"></A><CODE>auto_ptr::get</CODE></H3>

<PRE>Ty *<B>get</B>() const throw();</PRE>

<P>The member function returns the stored pointer <CODE>myptr</CODE>.</P>

<H3><A NAME="auto_ptr__operator2"></A><CODE>auto_ptr::operator=</CODE></H3>

<PRE>template&lt;class Other&gt;
    auto_ptr&lt;Ty&gt;&amp; <B>operator=</B>(auto_ptr&lt;Other&gt;&amp; right) throw();
auto_ptr&lt;Ty&gt;&amp; <B>operator=</B>(auto_ptr&lt;&gt;&amp; right) throw();
auto_ptr&lt;Ty&gt;&amp; <B>operator=</B>(auto_ptr_ref&lt;&gt;&amp; right) throw();</PRE>

<P>The assignment evaluates the expression <CODE>delete myptr</CODE>,
but only if the stored pointer <CODE>myptr</CODE>
changes as a result of the assignment.
It then transfers ownership of the pointer designated by <CODE>right</CODE>, by storing
<CODE>right.<A HREF="#auto_ptr__release">release</A>()</CODE> in <CODE>myptr</CODE>.
(The last assignment behaves as if <CODE>right</CODE> designates the reference
it stores.) The function returns <CODE>*this</CODE>.</P>


<H3><A NAME="auto_ptr__operator*"></A><CODE>auto_ptr::operator*</CODE></H3>

<PRE>Ty&amp; <B>operator*</B>() const throw();</PRE>

<P>The indirection operator returns
<CODE>*<A HREF="#auto_ptr__get">get</A>()</CODE>.
Hence, the stored pointer must not be null.</P>

<H3><A NAME="auto_ptr__operator-&gt;"></A><CODE>auto_ptr::operator-&gt;</CODE></H3>

<PRE>Ty *<B>operator-&gt;</B>() const throw();</PRE>

<P>The selection operator returns
<CODE><A HREF="#auto_ptr__get">get</A>()</CODE>,
so that the expression <CODE>ap-&gt;member</CODE> behaves the same as
<CODE>(ap.get())-&gt;member</CODE>, where <CODE>ap</CODE> is an object
of class <CODE>auto_ptr&lt;Ty&gt;</CODE>.
Hence, the stored pointer must not be null, and <CODE>Ty</CODE>
must be a class, structure, or union type with a member <CODE>member</CODE>.</P>

<H3><A NAME="auto_ptr__operator_auto_ptr&lt;Other&gt;"></A><CODE>auto_ptr::operator auto_ptr&lt;Other&gt;</CODE></H3>

<PRE>template&lt;class Other&gt;
    <B>operator auto_ptr&lt;Other&gt;</B>() throw();</PRE>

<P>The type cast operator returns
<CODE>auto_ptr&lt;Other&gt;(*this)</CODE>.</P>

<H3><A NAME="auto_ptr__operator_auto_ptr_ref&lt;Other&gt;"></A><CODE>auto_ptr::operator auto_ptr_ref&lt;Other&gt;</CODE></H3>

<PRE>template&lt;class Other&gt;
    <B>operator auto_ptr_ref&lt;Other&gt;</B>() throw();</PRE>

<P>The type cast operator returns
<CODE><A HREF="#auto_ptr_ref">auto_ptr_ref</A>&lt;Other&gt;(*this)</CODE>.</P>

<H3><A NAME="auto_ptr__release"></A><CODE>auto_ptr::release</CODE></H3>

<PRE>Ty *<B>release</B>() throw();</PRE>

<P>The member replaces the stored pointer <CODE>myptr</CODE> with a null pointer and
returns the previously stored pointer.</P>

<H3><A NAME="auto_ptr__reset"></A><CODE>auto_ptr::reset</CODE></H3>

<PRE>void <B>reset</B>(Ty *ptr = 0);</PRE>

<P>The member function evaluates the expression <CODE>delete myptr</CODE>,
but only if the stored pointer value <CODE>myptr</CODE>
changes as a result of function call.
It then replaces the stored pointer with <CODE>ptr</CODE>.</P>

<H2><A NAME="auto_ptr_ref"></A><CODE>auto_ptr_ref</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>auto_ptr_ref</B>; <B>[deprecated with C++11]</B></PRE>

<P>The class describes an object that stores a reference to an object of class
<CODE><A HREF="#auto_ptr">auto_ptr</A>&lt;Ty&gt;</CODE>. It is used as a helper
class for <CODE>auto_ptr&lt;Ty&gt;</CODE>. You should not have an occasion
to construct an <CODE>auto_ptr_ref&lt;Ty&gt;</CODE> object directly.</P>

<H2><CODE><A NAME="bad_weak_ptr"></A>bad_weak_ptr</CODE></H2>

<PRE>class <B>bad_weak_ptr</B>  <B>[added with C++11]</B>
    : public exception {
public:
    <B>bad_weak_ptr</B>() noexcept;
    const char *<B>what</B>() throw();
    };</PRE>

<P>The class describes an exception that can be thrown from the
<CODE><A HREF="#shared_ptr">shared_ptr</A></CODE> constructor that takes an argument
of type <CODE><A HREF="#weak_ptr">weak_ptr</A></CODE>. The member function <CODE>what</CODE>
returns <CODE>&quot;bad_weak_ptr&quot;</CODE>.</P>

<H2><CODE><A NAME="const_pointer_cast"></A>const_pointer_cast</CODE></H2>

<PRE>template &lt;class Ty, class Other&gt;  <B>[added with C++11]</B>
    shared_ptr&lt;Ty&gt;
        <B>const_pointer_cast</B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;</PRE>

<P>The template function returns an <A HREF="#empty_shared_ptr">empty shared_ptr</A> object
if <CODE>const_cast&lt;Ty*&gt;(sp.get())</CODE> returns a null pointer; otherwise it returns
a <CODE><A HREF="#shared_ptr">shared_ptr</A>&lt;Ty&gt;</CODE> object that
<A HREF="#owns">owns</A> the resource that is owned by <CODE>sp</CODE>.
The expression <CODE>const_cast&lt;Ty*&gt;(sp.get())</CODE> must be valid.</P>

<H2><A NAME="declare_no_pointers"></A><CODE>declare_no_pointers</CODE></H2>

<PRE>void <B>declare_no_pointers</B>(char *ptr, size_t size); <B>[added with C++11]</B></PRE>

<P>The function informs any
<A HREF="#garbage_collector">garbage collector</A>
that the range of addresses <CODE>[ptr, ptr + size)</CODE> no longer contain
<B><A NAME="traceable_pointers"></A>traceable pointers</B>.
(Any pointers to allocated storage must not be dereferenced unless
made <A HREF="#reachable_pointers">reachable</A>.)</P>

<P>The function throws nothing.</P>

<H2><A NAME="declare_reachable"></A><CODE>declare_reachable</CODE></H2>

<PRE>void <B>declare_reachable</B>(void *ptr); <B>[added with C++11]</B></PRE>

<P>If <CODE>ptr</CODE> is not null, the function informs any
<B><A NAME="garbage_collector"></A>garbage collector</B>
that <CODE>ptr</CODE> is hereafter
<B><A NAME="reachable_pointers"></A>reachable</B> (points to valid allocated
storage).</P>

<H2><CODE><A NAME="default_delete"></A>default_delete</CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>default_delete</B> {  <B>[added with C++11]</B>
    constexpr <B><A HREF="#default_delete__default_delete">default_delete</A></B>() noexcept = default;
    template&lt;class Other&gt;
        <B><A HREF="#default_delete__default_delete">default_delete</A></B>(const default_delete&lt;Other&gt;&amp;) noexcept;
    void <B><A HREF="#default_delete__operator_call">operator()</A></B>(Ty *ptr) const;
    };</PRE>

<P>The template class describes a <A HREF="#deleter">deleter</A>
that deletes scalar objects allocated with <CODE>::operator new</CODE>,
suitable for use with template class
<CODE><A HREF="#unique_ptr">unique_ptr</A></CODE>. It also has the
explicit specialization <CODE><A HREF="#default_delete_arr">default_delete&lt;Ty[]&gt;</A></CODE>.</P>

<H3><A NAME="default_delete__default_delete"></A><CODE>default_delete::default_delete</CODE></H3>

<PRE><B>constexpr default_delete</B>() noexcept = default;
template&lt;class Other&gt;
    <B>default_delete</B>(const default_delete&lt;Other&gt;&amp;) noexcept;</PRE>

<P>The constructors do nothing. In the second constructor, unless
<CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
the constructor does not participate in overload resolution.</P>

<H3><A NAME="default_delete__operator_call"></A><CODE>default_delete::operator()</CODE></H3>

<PRE>void <B>operator()</B>(Ty *ptr) const;</PRE>

<P>The member operator executes <CODE>delete ptr</CODE>.
<CODE>Ty</CODE> must not be an incomplete type.</P>

<H2><CODE><A NAME="default_delete_arr"></A>default_delete&lt;Ty[]&gt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>default_delete&lt;Ty[]&gt;</B> { <B>[added with C++11]</B>
    constexpr <B>default_delete</B>() noexcept = default;
    void <B><A HREF="#default_delete_arr__operator_call">operator()</A></B>(Ty *ptr) const;
    template&lt;class Other&gt;
        void <B><A HREF="#default_delete_arr__operator_call">operator()</A></B>(Other *ptr) const = delete;
    };</PRE>

<P>The template class describes a <A HREF="#deleter">deleter</A>
that deletes array objects allocated with <CODE>::operator new[]</CODE>,
suitable for use with template class
<CODE><A HREF="#unique_ptr_arr">unique_ptr</A>&lt;Ty[]&gt;</CODE>. It is an
explicit specialization of the template class
<CODE><A HREF="#default_delete">default_delete</A></CODE>.</P>

<H3><A NAME="default_delete_arr__operator_call"></A><CODE>default_delete&lt;Ty[]&gt;::operator()</CODE></H3>

<PRE>void <B>operator()</B>(Ty *ptr) const;
template&lt;class Other&gt;
    void <B>operator()</B>(Other *ptr) const = delete;</PRE>

<P>The member operator executes <CODE>delete[] ptr</CODE>.
<CODE>Ty</CODE> must not be an incomplete type.</P>

<H2><CODE><A NAME="dynamic_pointer_cast"></A>dynamic_pointer_cast</CODE></H2>

<PRE>template &lt;class Ty, class Other&gt;  <B>[added with C++11]</B>
    shared_ptr&lt;Ty&gt;
        <B>dynamic_pointer_cast</B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;</PRE>

<P>The template function returns an <A HREF="#empty_shared_ptr">empty shared_ptr</A> object
if <CODE>dynamic_cast&lt;Ty*&gt;(sp.get())</CODE> returns a null pointer; otherwise it returns
a <CODE><A HREF="#shared_ptr">shared_ptr</A>&lt;Ty&gt;</CODE> object that
<A HREF="#owns">owns</A> the resource that is owned by <CODE>sp</CODE>.
The expression <CODE>dynamic_cast&lt;Ty*&gt;(sp.get())</CODE> must be valid.</P>

<H2><CODE><A NAME="enable_shared_from_this"></A>enable_shared_from_this</CODE></H2>

<PRE>template&lt;class Ty&gt;  <B>[added with C++11]</B>
    class <B>enable_shared_from_this</B> {
public:
    shared_ptr&lt;Ty&gt; <B><A HREF="#enable_shared_from_this__shared_from_this">shared_from_this</A></B>();
    shared_ptr&lt;const Ty&gt; <B><A HREF="#enable_shared_from_this__shared_from_this">shared_from_this</A></B>() const;

protected:
    constexpr <B>enable_shared_from_this</B>() noexcept;
    <B>enable_shared_from_this</B>(const enable_shared_from_this&amp;) noexcept;
    enable_shared_from_this&amp; <B>operator=</B>(const enable_shared_from_this&amp;) noexcept;
    <B>~enable_shared_from_this</B>();
    };</PRE>

<P>The template class can be used as a public base class to simplify creating
<CODE><A HREF="#shared_ptr">shared_ptr</A></CODE> objects that own objects of the derived type:</P>

<PRE><CODE>class derived
    : public enable_shared_from_this&lt;derived&gt;
    {
    };

shared_ptr&lt;derived&gt; sp0(new derived);
shared_ptr&lt;derived&gt; sp1 = sp0-&gt;shared_from_this();</CODE></PRE>

<P>The constructors, destructor, and assignment operator are protected to help
prevent accidental misuse. The template argument type <CODE>Ty</CODE> must be the
type of the derived class.</P>

<H3><CODE><A NAME="enable_shared_from_this__shared_from_this"></A>enable_shared_from_this::shared_from_this</CODE></H3>

<PRE>shared_ptr&lt;Ty&gt; <B>shared_from_this</B>();
shared_ptr&lt;const Ty&gt; <B>shared_from_this</B>() const;</PRE>

<P>The member functions each return a <CODE><A HREF="#shared_ptr">shared_ptr</A></CODE> object that
<A HREF="#owns">owns</A> <CODE>*(Ty*)this</CODE>.</P>

<H2><CODE><A NAME="get_deleter"></A>get_deleter</CODE></H2>

<PRE>template&lt;class D, class Ty&gt;  <B>[added with C++11]</B>
    D *<B>get_deleter</B>(const shared_ptr&lt;Ty&gt;&amp; sp) noexcept;</PRE>

<P>The template function returns a pointer to the <A HREF="#deleter">deleter</A>
of type <CODE>D</CODE> that belongs to the <CODE><A HREF="#shared_ptr">shared_ptr</A></CODE>
object <CODE>sp</CODE>. If <CODE>sp</CODE> has no deleter or if its deleter is
not of type <CODE>D</CODE> the function returns 0.</P>

<H2><A NAME="get_pointer_safety"></A><CODE>get_pointer_safety</CODE></H2>

<PRE>pointer_safety <B>get_pointer_safety</B>() noexcept; <B>[added with C++11]</B></PRE>

<P>The function returns the type of pointer safety assumed by any automatic
<A HREF="#garbage_collector">garbage collector</A>.</P>

<H2><A NAME="get_temporary_buffer"></A><CODE>get_temporary_buffer</CODE></H2>

<PRE>template&lt;class Ty&gt;
    pair&lt;Ty *, ptrdiff_t&gt;
        <B>get_temporary_buffer</B>(ptrdiff_t count) noexcept;</PRE>

<P>The template function allocates storage for a sequence of at most
<CODE>count</CODE> elements of type <CODE>Ty</CODE>, from an unspecified
source (which may well be the standard heap used by
<CODE>::operator new</CODE>).
It returns a value <CODE>pr</CODE>, of type
<CODE><A HREF="utility.html#pair">pair</A>&lt;Ty *, ptrdiff_t&gt;</CODE>.
If the function allocates storage,
<CODE>pr.<A HREF="utility.html#pair__first">first</A></CODE> designates
the allocated storage and
<CODE>pr.<A HREF="utility.html#pair__second">second</A></CODE>
is the number of elements in the longest sequence the storage can hold.
Otherwise, <CODE>pr.first</CODE> is a null pointer.</P>


<H2><A NAME="hash"></A><CODE>hash</CODE></H2>

<PRE>template&lt;class Ty&gt; <B>[added with C++11]</B>
    class <B>hash&lt;shared_ptr&lt;Ty&gt;&gt;</B> {
    size_t <B>operator()</B>(shared_ptr&lt;Ty&gt; val) const;
    };
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    class <B>hash&lt;unique_ptr&lt;Ty, Del&gt;&gt;</B> {
    size_t <B>operator()</B>(unique_ptr&lt;Ty, Del&gt; val) const;
    };</PRE>

<P>Each template class defines its member function as returning
a value uniquely determined by <CODE>val</CODE>. In each case,
the member function defines a
<A HREF="functio2.html#hash_function">hash function</A>, suitable for mapping values
of the argument type to a distribution of index values.</P>

<H2><A NAME="make_shared"></A><CODE>make_shared</CODE></H2>

<PRE>template&lt;class Ty, class... Types&gt;
    shared_ptr&lt;Ty&gt; <B>make_shared</B>(Types&amp;&amp;... args); <B>[added with C++11]</B></PRE>

<P>The function creates the object <CODE>shared_ptr&lt;Ty&gt;</CODE>, where
<CODE>ptr</CODE> is a pointer to <CODE>Ty(args...)</CODE> as allocated and constructed by
the default allocator <CODE>allocator()</CODE>.</P>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;
    bool <B>operator!=</B>(const allocator&lt;Ty1&gt;&amp; left,
        const allocator&lt;Ty2&gt;&amp; right) throw();

template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator!=</B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator!=</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator!=</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator!=</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator!=</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator!=</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;</PRE>

<P>The first template operator returns false.
(All default allocators are equal.)
The remaining template operators return <CODE>!(left == right)</CODE>,
if both <CODE>left</CODE> and <CODE>right</CODE> are defined. Otherwise, for
an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;
    bool <B>operator==</B>(const allocator&lt;Ty1&gt;&amp; left,
        const allocator&lt;Ty2&gt;&amp; right) throw();

template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator==</B>(const shared_ptr&lt;Ty1&gt;&amp; left;,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator==</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator==</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator==</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator==</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator==</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;</PRE>

<P>The first template operator returns true.
(All default allocators are equal.)
The remaining template operators return <CODE>left.get() == right.get()</CODE>,
if both <CODE>left</CODE> and <CODE>right</CODE> are defined. Otherwise, for
an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>

<H2><CODE><A NAME="operator&lt;"></A>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);</PRE>

<P>The template operators return
<CODE><A HREF="functio2.html#less">less</A>&lt;V&gt;()(left.get(), right.get())</CODE>,
where <CODE>V</CODE> is either <CODE>Ty</CODE>
or the composite pointer type of <CODE>Ty1 *</CODE>
and <CODE>Ty2 *</CODE>.
For an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>

<H2><CODE><A NAME="operator&lt;&lt;"></A>operator&lt;&lt;</CODE></H2>

<PRE>template&lt;class Elem, class Tr, class Ty&gt;  <B>[added with C++11]</B>
    basic_ostream&lt;Elem, Tr&gt;&amp; <B>operator&lt;&lt;</B>(basic_ostream&lt;Elem, Tr&gt;&amp; out,
    const shared_ptr&lt;Ty&gt;&amp; sp);</PRE>

<P>The template operator returns <CODE>out &lt;&lt; sp.get()</CODE>.</P>

<H2><CODE><A NAME="operator&lt;2"></A>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator&lt;=</B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;=</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;=</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;=</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;=</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&lt;</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);</PRE>

<P>The template operators return <CODE>left.get() &lt;= right.get()</CODE>.
For an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>

<H2><CODE><A NAME="operator&gt;"></A>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);</PRE>

<P>The template operators return <CODE>left.get() &gt; right.get()</CODE>.
For an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>

<H2><CODE><A NAME="operator&gt;2"></A>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty1, class Ty2&gt;  <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(const shared_ptr&lt;Ty1&gt;&amp; left,
        const shared_ptr&lt;Ty2&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        nullptr_t) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(nullptr_t,
        const shared_ptr&lt;Ty&gt;&amp; right) noexcept;

template&lt;class Ty1, class Del1,
    class Ty2, class Del2&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(const unique_ptr&lt;Ty1, Del1&gt;&amp; left,
        const unique_ptr&lt;Ty2, Del2&gt;&amp; right);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(const unique_ptr&lt;Ty, Del&gt;&amp; left,
        nullptr_t);
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    bool <B>operator&gt;=</B>(nullptr_t,
        const unique_ptr&lt;Ty, Del&gt;&amp; right);</PRE>

<P>The template operators return <CODE>left.get() &gt;= right.get()</CODE>.
For an argument <CODE>X</CODE> of type <CODE>nullptr_t</CODE>, its corresponding
term is <CODE>(Ty *)0</CODE>.</P>


<H2><A NAME="owner_less"></A><CODE>owner_less</CODE></H2>

<PRE>template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B>owner_less</B>; // not defined
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B>owner_less&lt;shared_ptr&lt;Ty&gt; &gt;</B> {
    bool <B>operator()</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        const shared_ptr&lt;Ty&gt;&amp; right) const;
    bool <B>operator()</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        const weak_ptr&lt;Ty&gt;&amp; right) const;
    bool <B>operator()</B>(const weak_ptr&lt;Ty&gt;&amp; left,
        const shared_ptr&lt;Ty&gt;&amp; right) const;
    };
template&lt;class Ty&gt; <B>[added with C++11]</B>
    struct <B>owner_less&lt;weak_ptr&lt;Ty&gt; &gt;</B>
    bool <B>operator()</B>(const weak_ptr&lt;Ty&gt;&amp; left,
        const weak_ptr&lt;Ty&gt;&amp; right) const;
    bool <B>operator()</B>(const weak_ptr&lt;Ty&gt;&amp; left,
        const shared_ptr&lt;Ty&gt;&amp; right) const;
    bool <B>operator()</B>(const shared_ptr&lt;Ty&gt;&amp; left,
        const weak_ptr&lt;Ty&gt;&amp; right) const;
    };</PRE>

<P>The template classes define all their member operators as returning
<CODE>left.owner_before(right)</CODE>.</P>

<H2><A NAME="pointer_safety"></A><CODE>pointer_safety</CODE></H2>

<PRE>enum class <B>pointer_safety</B> { <B>[added with C++11]</B>&nbsp;
    <B>relaxed</B>, <B>preferred</B>, <B>strict</B>
    };</PRE>

<P>The scoped enum defines the values that can be returned by
<CODE><A HREF="#get_pointer_safety">get_pointer_safety</A>()</CODE>:</P>

<UL>
<LI><CODE>relaxed</CODE> -- pointers not
<B><A NAME="safely_derived_pointers"></A>safely derived</B> (obviously
pointers to declared or allocated objects) are treated the same as those
safely derived.</LI>

<LI><CODE>preferred</CODE> -- as before, but pointers not safely derived
should not be dereferenced.</LI>

<LI><CODE>strict</CODE> -- pointers not safely derived might be treated
differently than those safely derived.</LI>
</UL>

<H2><A NAME="pointer_traits"></A><CODE>pointer_traits</CODE></H2>

<PRE>template&lt;class Ptr&gt;
    struct <B>pointer_traits</B> <B>[added with C++11]</B>
    { // defines traits for arbitrary pointers
    typedef T1 <B><A HREF="#pointer_traits__element_type">element_type</A></B>;
    typedef Ptr <B><A HREF="#pointer_traits__pointer">pointer</A></B>;
    typedef T2 <B><A HREF="#pointer_traits__difference_type">difference_type</A></B>;

    template&lt;Other&gt;
        using <B><A HREF="#pointer_traits__rebind">rebind</A></B> = T3;

    static pointer <B><A HREF="#pointer_traits__pointer_to">pointer_to</A></B>(element_type&amp; obj);
    };</PRE>

<P>The template class supplies all the information needed by an object
of template class <CODE><A HREF="#allocator_traits">allocator_traits</A></CODE>
to describe an allocator with pointer type <CODE>Ptr</CODE>.
Such a pointer type can be a
<A HREF="#raw_pointer">raw pointer</A> of type <CODE>Ty *</CODE>
or a class with the properties:</P>

<PRE>template&lt;class Ty, class... Rest&gt;
    struct <B>Ptr</B>
    { // describes a pointer type usable by allocators
    typedef Ptr <B><A HREF="#pointer_traits__pointer">pointer</A></B>;
    typedef T1 <B><A HREF="#pointer_traits__element_type">element_type</A></B>; // optional
    typedef T2 <B><A HREF="#pointer_traits__difference_type">difference_type</A></B>; // optional
    template&lt;class Other&gt;
        using <B><A HREF="#pointer_traits__rebind">rebind</A></B> = typename Ptr&lt;Other, Rest...&gt;; // optional
    
    static pointer <B><A HREF="#pointer_traits__pointer_to">pointer_to</A></B>(element_type&amp; obj); // optional
    };</PRE>

<H3><A NAME="pointer_traits__difference_type"></A><CODE>pointer_traits::difference_type</CODE></H3>

<PRE>typedef T2 <B>difference_type</B>;</PRE>

<P>The type <CODE>T2</CODE> is <CODE>Ptr::difference_type</CODE> if that
type exists, otherwise <CODE>ptrdiff_t</CODE>.
For <CODE>Ptr</CODE> a raw pointer <CODE>Ty *</CODE>
it is <CODE>ptrdiff_t</CODE>.</P>

<H3><A NAME="pointer_traits__element_type"></A><CODE>pointer_traits::element_type</CODE></H3>

<PRE>typedef T1 <B>element_type</B>;</PRE>

<P>The type <CODE>T1</CODE> is <CODE>Ptr::element_type</CODE> if that
type exists, otherwise <CODE>Ty</CODE>.
For <CODE>Ptr</CODE> a raw pointer <CODE>Ty *</CODE>
it is <CODE>Ty</CODE>.</P>

<H3><A NAME="pointer_traits__pointer"></A><CODE>pointer_traits::pointer</CODE></H3>

<PRE>typedef Ptr <B>pointer</B>;</PRE>

<P>The type is <CODE>Ptr</CODE>.</P>

<H3><A NAME="pointer_traits__pointer_to"></A><CODE>pointer_traits::pointer_to</CODE></H3>

<PRE>static pointer <B>pointer_to</B>(element_type&amp; obj);</PRE>

<P>The static member function returns <CODE>Ptr::pointer_to(obj)</CODE>,
if that function exists. Otherwise, it is not possible to convert an
arbitrary reference to a object of class <CODE>Ptr</CODE>.
For <CODE>Ptr</CODE> a raw pointer <CODE>Ty *</CODE>
it returns <CODE><A HREF="#addressof">addressof</A>(obj)</CODE>.</P>

<H3><A NAME="pointer_traits__rebind"></A><CODE>pointer_traits::rebind</CODE></H3>

<PRE>template&lt;Other&gt;
    using <B>rebind</B> = T3;</PRE>

<P>The type <CODE>T3</CODE> is <CODE>Ptr::rebind&lt;Other&gt;</CODE> if that
type exists, otherwise <CODE>Ptr&lt;Other, Rest...&gt;</CODE>.
For <CODE>Ptr</CODE> a raw pointer <CODE>Ty *</CODE>
it is <CODE>Other *</CODE>.</P>

<H2><A NAME="pointer_traits_ptr"></A><CODE>pointer_traits&lt;Ty *&gt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    struct <B>pointer_traits&lt;Ty *&gt;</B>; <B>[added with C++11]</B>
    { // defines traits for raw pointers
    typedef Ty <B><A HREF="#pointer_traits__element_type">element_type</A></B>;
    typedef Ty *<B><A HREF="#pointer_traits__pointer">pointer</A></B>;
    typedef ptrdiff_t <B><A HREF="#pointer_traits__difference_type">difference_type</A></B>;

    template&lt;Other&gt;
        using <B><A HREF="#pointer_traits__rebind">rebind</A></B> = Other *;

    static pointer <B><A HREF="#pointer_traits__pointer_to">pointer_to</A></B>(<I>e-type</I>&amp; obj)
        {return addressof(obj); }
    };</PRE>

<P>The template class supplies all the information needed by an object
of template class
<CODE><A HREF="#allocator_traits">allocator_traits</A></CODE>
to describe an allocator with pointer type <CODE>Ty *</CODE>.
If <CODE>element_type</CODE> is not a void type,
<CODE><I>e-type</I></CODE> is
<CODE>add_lvalue_reference&lt;Ty&gt;::type</CODE>;
otherwise it is <CODE>char&amp;</CODE>.</P>

<H2><A NAME="raw_storage_iterator"></A><CODE>raw_storage_iterator</CODE></H2>

<PRE>template&lt;class OutIt, class Ty&gt;
    class <B>raw_storage_iterator</B>
         : public iterator&lt;output_iterator_tag,
             void, void, void, void&gt; {
public:
    explicit <B><A HREF="#raw_storage_iterator__raw_storage_iterator">raw_storage_iterator</A></B>(OutIt first);
    raw_storage_iterator&lt;OutIt, Ty&gt;&amp; <B><A HREF="#raw_storage_iterator__operator*">operator*</A></B>();
    raw_storage_iterator&lt;OutIt, Ty&gt;&amp;
        <B><A HREF="#raw_storage_iterator__operator2">operator=</A></B>(const Ty&amp; val);
    raw_storage_iterator&lt;OutIt, Ty&gt;&amp; <B><A HREF="#raw_storage_iterator__operator++">operator++</A></B>();
    raw_storage_iterator&lt;OutIt, Ty&gt; <B><A HREF="#raw_storage_iterator__operator++">operator++</A></B>(int);
    };</PRE>

<P>The class describes an output iterator
that constructs objects of type <CODE>Ty</CODE>
in the sequence it generates. An object of class
<CODE>raw_storage_iterator&lt;OutIt, Ty&gt;</CODE>
accesses storage through an output iterator object,
of class <CODE>OutIt</CODE>, that you specify when you construct
the object. For an object <CODE>first</CODE> of class <CODE>OutIt</CODE>,
the expression <CODE>&amp;*first</CODE> must designate unconstructed storage for
the next object (of type <CODE>Ty</CODE>) in the generated sequence.</P>

<H3><A NAME="raw_storage_iterator__operator*"></A><CODE>raw_storage_iterator::operator*</CODE></H3>

<PRE>raw_storage_iterator&lt;OutIt, Ty&gt;&amp; <B>operator*</B>();</PRE>

<P>The indirection operator returns <CODE>*this</CODE> (so that
<CODE><A HREF="#raw_storage_iterator__operator2">operator=</A>(const
Ty&amp;)</CODE> can perform the actual store
in an expression such as <CODE>*ptr = val</CODE>).</P>

<H3><A NAME="raw_storage_iterator__operator2"></A><CODE>raw_storage_iterator::operator=</CODE></H3>

<PRE>raw_storage_iterator&lt;OutIt, Ty&gt;&amp; <B>operator=</B>(const Ty&amp; val);</PRE>

<P>The assignment operator constructs the next object in the
output sequence using the stored iterator value <CODE>first</CODE>,
by evaluating the
placement <CODE>new</CODE> expression
<CODE>new ((void *)&amp;*first) Ty(val)</CODE>.
The function returns <CODE>*this</CODE>.</P>

<H3><A NAME="raw_storage_iterator__operator++"></A><CODE>raw_storage_iterator::operator++</CODE></H3>

<PRE>raw_storage_iterator&lt;OutIt, Ty&gt;&amp; <B>operator++</B>();
raw_storage_iterator&lt;OutIt, Ty&gt; <B>operator++</B>(int);</PRE>

<P>The first (preincrement) operator increments the stored output iterator
object, then returns <CODE>*this</CODE>.</P>

<P>The second (postincrement) operator makes a copy of <CODE>*this</CODE>,
increments the stored output iterator object, then returns
the copy.</P>

<H3><A NAME="raw_storage_iterator__raw_storage_iterator"></A><CODE>raw_storage_iterator::raw_storage_iterator</CODE></H3>

<PRE>explicit <B>raw_storage_iterator</B>(OutIt first);</PRE>

<P>The constructor stores <CODE>first</CODE> as the output iterator
object.</P>

<H2><A NAME="return_temporary_buffer"></A><CODE>return_temporary_buffer</CODE></H2>

<PRE>template&lt;class Ty&gt;
    void <B>return_temporary_buffer</B>(Ty *pbuf);</PRE>

<P>The template function frees the storage designated by <CODE>pbuf</CODE>,
which must be earlier allocated by a call to
<CODE><A HREF="#get_temporary_buffer">get_temporary_buffer</A></CODE>.</P>

<H2><CODE><A NAME="shared_ptr"></A>shared_ptr</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>shared_ptr</B> {  <B>[added with C++11]</B>
public:
    typedef Ty <B><A HREF="#shared_ptr__element_type">element_type</A></B>;

    constexpr <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>() noexcept;
    constexpr <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(nullptr_t); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(const shared_ptr&amp; sp) noexcept;
    <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(shared_ptr&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
    template&lt;class Other&gt;
        explicit <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(Other *ptr);
    template&lt;class Other, class D&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(Other *ptr, D dtor);
    template&lt;class D&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(nullptr_t ptr, D dtor); <B>[added with C++11]</B>
    template&lt;class Other, class D, class A&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(Other *ptr, D dtor, A alloc); <B>[added with C++11]</B>
    template&lt;class D, class A&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(nullptr_t ptr, D dtor, A alloc); <B>[added with C++11]</B>
    template&lt;class Other&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
    template&lt;class Other&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(shared_ptr&lt;Other&gt;&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
    template&lt;class Other&gt;
        explicit <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(const weak_ptr&lt;Other&gt;&amp; wp);
    template&lt;class Other&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(auto_ptr&lt;Other&gt;&amp;&amp; ap);
    template&lt;class Other, class D&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(unique_ptr&lt;Other, D&gt;&amp;&amp; up); <B>[added with C++11]</B>
    template&lt;class Other&gt;
        <B><A HREF="#shared_ptr__shared_ptr">shared_ptr</A></B>(const shared_ptr&lt;Other&gt;&amp; sp,
            Ty *ptr) noexcept; <B>[added with C++11]</B>

    <B><A HREF="#shared_ptr__~shared_ptr">~shared_ptr</A></B>();

    shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(const shared_ptr&amp; sp) noexcept;
    shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(shared_ptr&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
    template&lt;class Other&gt;
        shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
    template&lt;class Other&gt;
        shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(shared_ptr&lt;Other&gt;&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
    template&lt;class Other&gt;
        shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(auto_ptr&lt;Other&gt;&amp;&amp; ap);
    template&lt;class Other, class D&gt;
        shared_ptr&amp; <B><A HREF="#shared_ptr__operator2">operator=</A></B>(unique_ptr&lt;Other, D&gt;&amp;&amp; ap) noexcept; <B>[added with C++11]</B>

    void <B><A HREF="#shared_ptr__swap">swap</A></B>(shared_ptr&amp; sp) noexcept;
    void <B><A HREF="#shared_ptr__reset">reset</A></B>() noexcept;
    template&lt;class Other&gt;
        void <B><A HREF="#shared_ptr__reset">reset</A></B>(Other *ptr);
    template&lt;class Other, class D&gt;
        void <B><A HREF="#shared_ptr__reset">reset</A></B>(Other *ptr, D dtor);
    template&lt;class Other, class D, class A&gt;
        void <B><A HREF="#shared_ptr__reset">reset</A></B>(Other *ptr, D dtor, A alloc); <B>[added with C++11]</B>

    Ty *<B><A HREF="#shared_ptr__get">get</A></B>() const noexcept;
    Ty&amp; <B><A HREF="#shared_ptr__operator*">operator*</A></B>() const noexcept;
    Ty *<B><A HREF="#shared_ptr__operator-&gt;">operator-&gt;</A></B>() const noexcept;
    long <B><A HREF="#shared_ptr__use_count">use_count</A></B>() const noexcept;
    bool <B><A HREF="#shared_ptr__unique">unique</A></B>() const noexcept;
    explicit <B><A HREF="#shared_ptr__operator_bool">operator bool</A></B>() cons noexcept;

    template&lt;class Other&gt;
        bool <B><A HREF="#shared_ptr__owner_before">owner_before</A></B>(const shared_ptr&lt;Other&gt;&amp; ptr) const; <B>[added with C++11]</B>
    template&lt;class Other&gt;
        bool <B><A HREF="#shared_ptr__owner_before">owner_before</A></B>(const weak_ptr&lt;Other&gt;&amp; ptr) const; <B>[added with C++11]</B>
    };</PRE>

<P>The template class describes an object that uses reference counting to manage resources.
Each <CODE>shared_ptr</CODE> object effectively stores a pointer to the resource that it
owns or stores a null pointer. A resource can be owned by more than one
<CODE>shared_ptr</CODE> object; when the last <CODE>shared_ptr</CODE> object that owns
a particular resource is destroyed the resource is freed.</P>

<P>The template argument <CODE>Ty</CODE> may be an incomplete type except as noted
for certain <A HREF="#operand_sequence">operand sequences</A>.</P>

<P>When a <CODE>shared_ptr&lt;Ty&gt;</CODE> object is constructed from a
resource pointer of type <CODE>D*</CODE> or from a <CODE>shared_ptr&lt;D&gt;</CODE>,
the pointer type <CODE>D*</CODE> must be convertible to <CODE>Ty*</CODE>. If it is
not, the code will not compile. For example:</P>

<PRE>class B {};
class D : public B {};

shared_ptr&lt;D&gt; sp0(new D);   // okay, template parameter D and argument D*
shared_ptr&lt;D&gt; sp1(sp0);     // okay, template parameter D and argument shared_ptr&lt;D&gt;
shared_ptr&lt;B&gt; sp2(new D);   // okay, D* convertible to B*
shared_ptr&lt;B&gt; sp3(sp0);     // okay, template parameter B and argument shared_ptr&lt;D&gt;
shared_ptr&lt;B&gt; sp4(sp2);     // okay, template parameter B and argument shared_ptr&lt;B&gt;
shared_ptr&lt;int&gt; sp4(new D); // error, D* not convertible to int*
shared_ptr&lt;int&gt; sp5(sp2);   // error, template parameter int and argument shared_ptr&lt;B&gt;</PRE>

<P>A <CODE>shared_ptr</CODE> object <B><A NAME="owns"></A>owns</B> a resource:</P>

<UL>
<LI>if it was constructed with a pointer to that resource,</LI>
<LI>if it was constructed from a <CODE>shared_ptr</CODE> object that owns that resource,</LI>
<LI>if it was constructed from a <CODE><A HREF="#weak_ptr">weak_ptr</A></CODE> object that
<A HREF="#points_to">points to</A> that resource, or</LI>
<LI>if ownership of that resource was assigned to it, either with
<CODE><A HREF="#shared_ptr__operator2">operator=</A></CODE> or by calling the member function
<CODE><A HREF="#shared_ptr__reset">reset</A></CODE>.</LI>
</UL>

<P>All the <CODE>shared_ptr</CODE>
objects that own a single resource share a control block which holds the number
of <CODE>shared_ptr</CODE> objects that own the resource, the number of
<CODE>weak_ptr</CODE> objects that point to the resource, and the
<A HREF="#deleter">deleter</A> for that resource if it has one. A <CODE>shared_ptr</CODE>
object that was initialized with a null pointer has a control block; thus it is not an
<A HREF="#empty_shared_ptr">empty shared_ptr</A>.
After a <CODE>shared_ptr</CODE> object <B><A NAME="release"></A>releases</B> a resource
it no longer owns that resource. After a <CODE>weak_ptr</CODE> object releases a resource
it no longer <A HREF="#points_to">points to</A> that resource.
When the number of <CODE>shared_ptr</CODE> objects that own a resource becomes zero
the resource is freed, either by deleting it or by passing its address to a
deleter, depending on how ownership of the resource was originally created. When the
number of <CODE>shared_ptr</CODE> objects that own a resource is zero and the number
of <CODE>weak_ptr</CODE> objects that point to that resource is zero the control block
is freed.</P>

<P>An <B><A NAME="empty_shared_ptr"></A>empty shared_ptr</B> object does not own any
resources and has no control block.</P>

<P>A <B><A NAME="deleter"></A>deleter</B> is a function pointer or an object of a type
with a member function <CODE>operator()</CODE>. Its type must be copy constructible
and its copy constructor and destructor must not throw exceptions. A deleter is bound
to a <CODE>shared_ptr</CODE> object with an
<A HREF="#operand_sequence">operand sequence</A> of the form <CODE>ptr, dtor</CODE>.</P>

<P>Some functions take an <B><A NAME="operand_sequence"></A>operand sequence</B>
that defines properties of the resulting <CODE>shared_ptr&lt;Ty&gt;</CODE>
or <CODE>weak_ptr&lt;Ty&gt;</CODE> object. You can specify such an
operand sequence several ways:</P>

<UL>
<LI><I>no arguments</I> -- the resulting object is an
<A HREF="#empty_shared_ptr">empty shared_ptr</A> object or an
<A HREF="#empty_weak_ptr">empty weak_ptr</A> object.</LI>

<LI><CODE>ptr</CODE> -- a pointer of type <CODE>Other*</CODE> to the resource to be
managed. <CODE>Ty</CODE> must be a complete type. If the function fails
it evaluates the expression <CODE>delete ptr</CODE>.</LI>

<LI><CODE>ptr, dtor</CODE> -- a pointer of type <CODE>Other*</CODE> to the
resource to be managed and a <A HREF="#deleter">deleter</A> for that resource.
If the function fails it calls <CODE>dtor(ptr)</CODE>, which must be well
defined.</LI>

<LI><CODE>ptr, dtor, alloc</CODE> -- a pointer of type <CODE>Other*</CODE> to the
resource to be managed, a <A HREF="#deleter">deleter</A> for that resource, and an
allocator to manage any storage that must be allocated and freed.
If the function fails it calls <CODE>dtor(ptr)</CODE>, which must be well
defined.</LI>

<LI><CODE>sp</CODE> -- a <CODE>shared_ptr&lt;Other&gt;</CODE> object that
<A HREF="#owns">owns</A> the resource to be managed.</LI>

<LI><CODE>wp</CODE> -- a <CODE>weak_ptr&lt;Other&gt;</CODE> object that
<A HREF="#points_to">points to</A> the resource to be managed.</LI>

<LI><CODE>ap</CODE> -- an <CODE>auto_ptr&lt;Other&gt;</CODE> object that holds
a pointer to the resource to be managed. If the function succeeds it calls
<CODE>ap.release()</CODE>; otherwise it leaves <CODE>ap</CODE> unchanged.</LI>
</UL>

<P>In all cases, the pointer type <CODE>Other *</CODE> must be convertible to
<CODE>Ty *</CODE>.</P>

<P><CODE>shared_ptr</CODE> and <CODE>weak_ptr</CODE> objects provide limited thread-safety
guarantees. Creating new objects from existing objects is safe, and destroying
objects is safe. Other operations, including assigning from one object to
another, are not safe. To use these unsafe operations in multiple threads, either
use the various <CODE>shared_ptr</CODE>
<A HREF="#atomic_compare_exchange_strong_explicit">atomic</A>
operations or provide your own synchronization.</P>

<H3><CODE><A NAME="shared_ptr__element_type"></A>shared_ptr::element_type</CODE></H3>

<PRE>typedef Ty <B>element_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__get"></A>shared_ptr::get</CODE></H3>

<PRE>Ty *<B>get</B>() const;</PRE>

<P>The member function returns the address of the <A HREF="#owns">owned</A>
resource. If the object does not own a resource it returns 0.</P>

<H3><CODE><A NAME="shared_ptr__operator2"></A>shared_ptr::operator=</CODE></H3>

<PRE>shared_ptr&amp; <B>operator=</B>(const shared_ptr&amp; sp) noexcept;
shared_ptr&amp; <B>operator=</B>(shared_ptr&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
template&lt;class Other&gt;
    shared_ptr&amp; <B>operator=</B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
template&lt;class Other&gt;
    shared_ptr&amp; <B>operator=</B>(shared_ptr&lt;Other&gt;&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
template&lt;class Other&gt;
    shared_ptr&amp; <B>operator=</B>(auto_ptr&lt;Other&gt;&amp;&amp; ap);
template&lt;class Other, class D&gt;
    shared_ptr&amp; <B>operator=</B>(unique_ptr&lt;Other, D&gt;&amp;&amp; ap) noexcept; <B>[added with C++11]</B></PRE>

<P>The operators all <A HREF="#release">release</A> the resource currently
<A HREF="#owns">owned</A> by <CODE>*this</CODE> and assign ownership of the
resource named by the <A HREF="#operand_sequence">operand sequence</A> to
<CODE>*this</CODE>. If an operator fails it leaves
<CODE>*this</CODE> unchanged.</P>

<H3><CODE><A NAME="shared_ptr__operator*"></A>shared_ptr::operator*</CODE></H3>

<PRE>Ty&amp; <B>operator*</B>() const noexcept;</PRE>

<P>The indirection operator returns <CODE>*get()</CODE>. Hence, the stored
pointer must not be null.</P>

<H3><CODE><A NAME="shared_ptr__operator-&gt;"></A>shared_ptr::operator-&gt;</CODE></H3>

<PRE>Ty *<B>operator-&gt;</B>() const noexcept;</PRE>

<P>The selection operator returns <CODE>get()</CODE>, so that the
expression <CODE>sp-&gt;member</CODE> behaves the same as <CODE>(sp.get())-&gt;member</CODE>
where <CODE>sp</CODE> is an object of class <CODE>shared_ptr&lt;Ty&gt;</CODE>.
Hence, the stored pointer must not be null, and <CODE>Ty</CODE> must be a class,
structure, or union type with a member <CODE>member</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__operator_bool"></A>shared_ptr::operator bool</CODE></H3>

<PRE>explicit <B>operator bool</B>() const noexcept;</PRE>

<P>The operator returns a value of a type that is convertible to <CODE>bool</CODE>.
The result of the conversion to <CODE>bool</CODE> is <CODE>true</CODE> when
<CODE>get() != 0</CODE>, otherwise <CODE>false</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__owner_before"></A>shared_ptr::owner_before</CODE></H3>

<PRE>template&lt;class Other&gt;
    bool <B>owner_before</B>(const shared_ptr&lt;Other&gt;&amp; ptr) const; <B>[added with C++11]</B>
template&lt;class Other&gt;
    bool <B>owner_before</B>(const weak_ptr&lt;Other&gt;&amp; ptr) const; <B>[added with C++11]</B></PRE>

<P>The template member function returns true if <CODE>*this</CODE> is
<A HREF="lib_stl.html#strict_weak_ordering">ordered before</A> <CODE>ptr</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__reset"></A>shared_ptr::reset</CODE></H3>

<PRE>void <B>reset</B>() noexcept;
template&lt;class Other&gt;
    void <B>reset</B>(Other *ptr;);
template&lt;class Other, class D&gt;
    void <B>reset</B>(Other *ptr, D dtor);
template&lt;class Other, class D, class A&gt;
    void <B>reset</B>(Other *ptr, D dtor, A alloc); <B>[added with C++11]</B></PRE>

<P>The member functions all <A HREF="#release">release</A> the resource currently
<A HREF="#owns">owned</A> by <CODE>*this</CODE> and assign ownership of the
resource named by the <A HREF="#operand_sequence">operand sequence</A> to
<CODE>*this</CODE>. If a member function fails it leaves
<CODE>*this</CODE> unchanged.</P>

<H3><CODE><A NAME="shared_ptr__shared_ptr"></A>shared_ptr::shared_ptr</CODE></H3>

<PRE>constexpr <B>shared_ptr</B>() noexcept;
constexpr <B>shared_ptr</B>(nullptr_t); <B>[added with C++11]</B>&nbsp;
<B>shared_ptr</B>(const shared_ptr&amp; sp) noexcept;
<B>shared_ptr</B>(shared_ptr&amp;&amp; sp); <B>[added with C++11]</B>
template&lt;class Other&gt;
    explicit <B>shared_ptr</B>(Other *ptr);
template&lt;class Other, class D&gt;
    <B>shared_ptr</B>(Other *ptr, D dtor);
template&lt;class D&gt;
    <B>shared_ptr</B>(nullptr_t ptr, D dtor); <B>[added with C++11]</B>
template&lt;class Other, class D, class A&gt;
    <B>shared_ptr</B>(Other *ptr, D dtor, A alloc); <B>[added with C++11]</B>
template&lt;class D, class A&gt;
    <B>shared_ptr</B>(nullptr_t ptr, D dtor, A alloc); <B>[added with C++11]</B>
template&lt;class Other&gt;
    <B>shared_ptr</B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;
template&lt;class Other&gt;
    <B>shared_ptr</B>(shared_ptr&lt;Other&gt;&amp;&amp; sp) noexcept; <B>[added with C++11]</B>
template&lt;class Other&gt;
    explicit <B>shared_ptr</B>(const weak_ptr&lt;Other&gt;&amp; wp);
template&lt;class Other&gt;
    <B>shared_ptr</B>(auto_ptr&lt;Other&gt;&amp;&amp; ap) noexcept;
template&lt;class Other, class D&gt;
    <B>shared_ptr</B>(unique_ptr&lt;Other, D&gt;&amp;&amp; ap); <B>[added with C++11]</B>
template&lt;class Other&gt;
    <B>shared_ptr</B>(const shared_ptr&lt;Other&gt;&amp; sp,
        Ty *ptr) noexcept; <B>[added with C++11]</B></PRE>

<P>All but the last constructor each constructs an object that <A HREF="#owns">owns</A>
the resource named by the <A HREF="#operand_sequence">operand sequence</A>.
The last constructor defines <CODE>ptr</CODE> as a
<B><A NAME="shared_pointer_alias"></A>shared pointer alias</B> for the object
owned by <CODE>sp</CODE>, and shares ownership with <CODE>sp</CODE>.</P>

<P>The constructor <CODE>shared_ptr(const weak_ptr&lt;Other&gt;&amp; wp)</CODE> throws
an exception object of type <A HREF="#bad_weak_ptr">bad_weak_ptr</A>
if <CODE>wp.expired()</CODE>.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
the template constructor
<CODE>shared_ptr(const shared_ptr&lt;Other&gt;&amp; ap)</CODE>
does not participate in overload resolution.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
the template constructor
<CODE>shared_ptr(shared_ptr&lt;Other&gt;&amp;&amp; ap)</CODE>
does not participate in overload resolution.</P>

<H3><CODE><A NAME="shared_ptr__~shared_ptr"></A>shared_ptr::~shared_ptr</CODE></H3>

<PRE><B>~shared_ptr</B>();</PRE>

<P>The destructor <A HREF="#release">releases</A> the resource
<A HREF="#owns">owned</A> by <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__swap"></A>shared_ptr::swap</CODE></H3>

<PRE>void <B>swap</B>(shared_ptr&amp; sp) noexcept;</PRE>

<P>The member function leaves the resource originally <A HREF="#owns">owned</A>
by <CODE>*this</CODE> subsequently owned by <CODE>sp</CODE>, and the resource
originally owned by <CODE>sp</CODE> subsequently owned by <CODE>*this</CODE>.
The function does not change the reference counts for the two resources and
it does not throw any exceptions.</P>

<H3><CODE><A NAME="shared_ptr__unique"></A>shared_ptr::unique</CODE></H3>

<PRE>bool <B>unique</B>() const noexcept;</PRE>

<P>The member function returns <CODE>true</CODE> if
no other <CODE>shared_ptr</CODE> object <A HREF="#owns">owns</A> the
resource that is owned by <CODE>*this</CODE>, otherwise <CODE>false</CODE>.</P>

<H3><CODE><A NAME="shared_ptr__use_count"></A>shared_ptr::use_count</CODE></H3>

<PRE>long <B>use_count</B>() const noexcept;</PRE>

<P>The member function returns the number of <CODE>shared_ptr</CODE> objects
that <A HREF="#owns">own</A> the resource that is owned by <CODE>*this</CODE>.</P>

<H2><CODE><A NAME="static_pointer_cast"></A>static_pointer_cast</CODE></H2>

<PRE>template &lt;class Ty, class Other&gt;  <B>[added with C++11]</B>
    shared_ptr&lt;Ty&gt;
        <B>static_pointer_cast</B>(const shared_ptr&lt;Other&gt;&amp; sp) noexcept;</PRE>

<P>The template function returns an <A HREF="#empty_shared_ptr">empty shared_ptr</A> object
if <CODE>sp</CODE> is an empty <CODE>shared_ptr</CODE> object; otherwise it returns a
<CODE><A HREF="#shared_ptr">shared_ptr</A>&lt;Ty&gt;</CODE> object that
<A HREF="#owns">owns</A> the resource that is owned by <CODE>sp</CODE>. The expression
<CODE>static_cast&lt;Ty*&gt;(sp.get())</CODE> must be valid.</P>

<H2><CODE><A NAME="swap"></A>swap</CODE></H2>

<PRE>template&lt;class Ty&gt; <B>[added with C++11]</B>
    void <B>swap</B>(shared_ptr&lt;Ty&gt;&amp; left,
        shared_ptr&lt;Ty&gt;&amp; right) noexcept;
template&lt;class Ty, class Del&gt; <B>[added with C++11]</B>
    void <B>swap</B>(unique_ptr&lt;Ty, Del&gt;&amp; left,
        unique_ptr&lt;Ty, Del&gt;&amp; right) noexcept;
template&lt;class Ty&gt; <B>[added with C++11]</B>
    void <B>swap</B>(weak_ptr&lt;Ty&gt;&amp; left,
        weak_ptr&lt;Ty&gt;&amp; right) noexcept;</PRE>

<P>The template function calls <CODE>left.swap(right)</CODE>.</P>

<H2><A NAME="undeclare_no_pointers"></A><CODE>undeclare_no_pointers</CODE></H2>

<PRE>void <B>undeclare_no_pointers</B>(char *ptr, size_t size); <B>[added with C++11]</B></PRE>

<P>The function informs any
<A HREF="#garbage_collector">garbage collector</A>
that the range of addresses <CODE>[ptr, ptr + size)</CODE> may now contain
<A HREF="#traceable_pointers">traceable pointers</A>.</P>

<P>The function throws nothing.</P>

<H2><A NAME="undeclare_reachable"></A><CODE>undeclare_reachable</CODE></H2>

<PRE>template&lt;class Ty&gt;
    Ty *<B>undeclare_reachable</B>(Ty *ptr); <B>[added with C++11]</B></PRE>

<P>If <CODE>ptr</CODE> is not null, the function informs any
<A HREF="#garbage_collector">garbage collector</A>
that <CODE>ptr</CODE> is hereafter not
<A HREF="#reachable_pointers">reachable</A>.
It returns a <A HREF="#safely_derived_pointers">safely derived</A> pointer
that compares equal to <CODE>ptr</CODE>.</P>

<P>The function throws nothing.</P>

<H2><A NAME="uninitialized_copy"></A><CODE>uninitialized_copy</CODE></H2>

<PRE>template&lt;class InIt, class FwdIt&gt;
    FwdIt <B>uninitialized_copy</B>(InIt first, InIt last,
        FwdIt dest);</PRE>

<P>The template function effectively executes:</P>

<PRE>while (first != last)
    new ((void *)&amp;*dest++)
        iterator_traits&lt;InIt&gt;::<A HREF="iterator.html#iterator_traits__value_type">value_type</A>(*first++);
return dest;</PRE>

<P>unless the code throws an exception. In that case, all
constructed objects are destroyed and the exception is rethrown.</P>

<H2><A NAME="uninitialized_copy_n"></A><CODE>uninitialized_copy_n</CODE></H2>

<PRE>template&lt;class InIt, class Diff, class FwdIt&gt;
    FwdIt <B>uninitialized_copy_n</B>(InIt first, Diff count,
        FwdIt dest); <B>[added with C++11]</B></PRE>

<P>The template function effectively executes:</P>

<PRE>for (; 0 &lt; count; -- count)
    new ((void *)&amp;*dest++)
        iterator_traits&lt;InIt&gt;::<A HREF="iterator.html#iterator_traits__value_type">value_type</A>(*first++);
return dest;</PRE>

<P>unless the code throws an exception. In that case, all
constructed objects are destroyed and the exception is rethrown.</P>

<H2><A NAME="uninitialized_fill"></A><CODE>uninitialized_fill</CODE></H2>

<PRE>template&lt;class FwdIt, class Ty&gt;
    void <B>uninitialized_fill</B>(FwdIt first, FwdIt last,
        const Ty&amp; val);</PRE>

<P>The template function effectively executes:</P>

<PRE>while (first != last)
    new ((void *)&amp;*first++)
        iterator_traits&lt;FwdIt&gt;::<A HREF="iterator.html#iterator_traits__value_type">value_type</A>(val);</PRE>

<P>unless the code throws an exception. In that case, all
constructed objects are destroyed and the exception is rethrown.</P>

<H2><A NAME="uninitialized_fill_n"></A><CODE>uninitialized_fill_n</CODE></H2>

<PRE>template&lt;class FwdIt, class Size, class Ty&gt;
    FwdIt <B>uninitialized_fill_n</B>(FwdIt first, Size count,
        const Ty&amp; val);</PRE>

<P>The template function effectively executes:</P>

<PRE>while (0 &lt; count--)
    new ((void *)&amp;*first++)
        iterator_traits&lt;FwdIt&gt;::<A HREF="iterator.html#iterator_traits__value_type">value_type</A>(val);
    return (first);</PRE>

<P>unless the code throws an exception. In that case, all
constructed objects are destroyed and the exception is rethrown.</P>

<H2><CODE><A NAME="unique_ptr"></A>unique_ptr</CODE></H2>

<PRE>template&lt;class Ty, class Del = default_delete&lt;Ty&gt; &gt;
    struct <B>unique_ptr</B> { <B>[added with C++11]</B>
    typedef Ty <B><A HREF="#unique_ptr__element_type">element_type</A></B>;
    typedef Del <B><A HREF="#unique_ptr__deleter_type">deleter_type</A></B>;
    typedef T1 <B><A HREF="#unique_ptr__pointer">pointer</A></B>;

    constexpr <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>() noexcept;
    constexpr <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(nullptr_t) noexcept;
    explicit <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(pointer ptr) noexcept;
    <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(pointer ptr,
        typename conditional&lt;is_reference&lt;Del&gt;::value, Del,
            typename add_reference&lt;const Del&gt;::type&gt;::type deleter) noexcept;
    <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(pointer ptr,
        typename remove_reference&lt;Del&gt;::type&amp;&amp; deleter) noexcept;
    <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(unique_ptr&amp;&amp; right) noexcept;
    template&lt;class Ty2, class Del2&gt;
        <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(unique_ptr&lt;Ty2, Del2&gt;&amp;&amp; right) noexcept;
    template&lt;class Ty2&gt;
        <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(auto_ptr&lt;Ty2&gt;&amp;&amp; right) noexcept;

    <B><A HREF="#unique_ptr__~unique_ptr">~unique_ptr</A></B>();

    unique_ptr&amp; <B><A HREF="#unique_ptr__operator2">operator=</A></B>(unique_ptr&amp;&amp; right) noexcept;
    template&lt;class Ty2, class Del2&gt;
        unique_ptr&amp; <B><A HREF="#unique_ptr__operator2">operator=</A></B>(unique_ptr&lt;Ty, Del&gt;&amp;&amp; right) noexcept;
    unique_ptr&amp; <B><A HREF="#unique_ptr__operator2">operator=</A></B>(nullptr_t) noexcept;

    void <B><A HREF="#unique_ptr__swap">swap</A></B>(unique_ptr&amp; right) noexcept;
    pointer <B><A HREF="#unique_ptr__release">release</A></B>() noexcept;
    void <B><A HREF="#unique_ptr__reset">reset</A></B>(pointer ptr = pointer()) noexcept;

    pointer <B><A HREF="#unique_ptr__get">get</A></B>() const noexcept;
    Ty&amp; <B><A HREF="#unique_ptr__operator*">operator*</A></B>() const;
    pointer <B><A HREF="#unique_ptr__operator-&gt;">operator-&gt;</A></B>() const noexcept;
    Del&amp; <B><A HREF="#unique_ptr__get_deleter">get_deleter</A></B>() noexcept;
    const Del&amp; <B><A HREF="#unique_ptr__get_deleter">get_deleter</A></B>() const noexcept;
    explicit <B><A HREF="#unique_ptr__operator_bool">operator bool</A></B>() const noexcept;

    <B>unique_ptr</B>(const unique_ptr&amp; right) = delete;
    unique_ptr&amp; <B>operator=</B>(const unique_ptr&amp; right) = delete;

private:
    pointer stored_ptr;    <I>// exposition only</I>
    Del stored_deleter;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes an object that uniquely manages a resource.
Each <CODE>unique_ptr</CODE> object effectively stores a pointer to the
object that it owns or stores a null pointer. A resource can be owned by no
more than one <CODE>unique_ptr</CODE> object; when the <CODE>unique_ptr</CODE>
object that owns a particular resource is destroyed the resource is freed.
A <CODE>unique_ptr</CODE> object may be moved, but not copied.</P>

<P>The resource is freed by calling a stored <B><A HREF="#deleter">deleter</A></B>
object of type <CODE>Del</CODE> that knows how resources are allocated for
a particular <CODE>unique_ptr</CODE>. The default deleter
<CODE><A HREF="#default_delete">default_delete</A>&lt;Ty&gt;</CODE>
assumes that the resource pointed to by <CODE>ptr</CODE> is allocated with
<CODE>::operator new</CODE>, so it can be freed by calling <CODE>Del()(ptr)</CODE>.
(An explicit specialization <CODE><A HREF="#unique_ptr_arr">unique_ptr&lt;Ty[]&gt;</A></CODE>
manages array objects allocated with <CODE>::operator new[]</CODE>, and has the default deleter
<CODE><A HREF="#default_delete_arr">default_delete&lt;Ty[]&gt;</A></CODE>.)</P>

<P>The stored pointer to a managed resource <CODE>stored_ptr</CODE> has type
<CODE><A HREF="#unique_ptr__pointer">pointer</A></CODE>. It is <CODE>Del::pointer</CODE>
if defined, otherwise <CODE>Ty *</CODE>. The stored deleter object
<CODE>stored_deleter</CODE> should occupy no space in the object if the deleter is stateless.
Note that <CODE>Del</CODE> can be a reference type.</P>

<H3><CODE><A NAME="unique_ptr__deleter_type"></A>unique_ptr::deleter_type</CODE></H3>

<PRE>typedef Del <B>deleter_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Del</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__element_type"></A>unique_ptr::element_type</CODE></H3>

<PRE>typedef Ty <B>element_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__get"></A>unique_ptr::get</CODE></H3>

<PRE>pointer <B>get</B>() const noexcept;</PRE>

<P>The member function returns <CODE>stored_ptr</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__get_deleter"></A>unique_ptr::get_deleter</CODE></H3>

<PRE>Del&amp; <B>get_deleter</B>() noexcept;
const Del&amp; <B>get_deleter</B>() const noexcept;</PRE>

<P>The member function returns a reference to <CODE>stored_deleter</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__operator2"></A>unique_ptr::operator=</CODE></H3>

<PRE>unique_ptr&amp; <B>operator=</B>(unique_ptr&amp;&amp; right) noexcept;
template&lt;class Ty2, class Del2&gt;
    unique_ptr&amp; <B>operator=</B>(unique_ptr&lt;Ty, Del&gt;&amp;&amp; right) noexcept;
unique_ptr&amp; <B>operator=</B>(nullptr_t) noexcept;</PRE>

<P>The first two member operators call <CODE>reset(right.release())</CODE>
and move <CODE>right.stored_deleter</CODE> to <CODE>stored_deleter</CODE>,
then return <CODE>*this</CODE>.</P>

<P>The third member operator calls <CODE>reset()</CODE>,
then returns <CODE>*this</CODE>.</P>

<P>Unless <CODE>is_convertible&lt;Ty2 *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
and <CODE>is_array&lt;Ty2&gt;</CODE>
<A HREF="typetrait.html#holds_false">holds false</A>,
the template operator
<CODE>unique_ptr&amp; <B>operator=</B>(unique_ptr&lt;Ty, Del&gt;&amp;&amp; right)</CODE>
does not participate in overload resolution.</P>

<H3><CODE><A NAME="unique_ptr__operator*"></A>unique_ptr::operator*</CODE></H3>

<PRE>Ty&amp; <B>operator*</B>() const;</PRE>

<P>The member function returns <CODE>*stored_ptr</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__operator-&gt;"></A>unique_ptr::operator-&gt;</CODE></H3>

<PRE>pointer <B>operator-&gt;</B>() const noexcept;</PRE>

<P>The member function returns <CODE>stored_ptr</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__operator_bool"></A>unique_ptr::operator bool</CODE></H3>

<PRE>explicit <B>operator bool</B>() const noexcept;</PRE>

<P>The operator returns a value of a type that is convertible to <CODE>bool</CODE>.
The result of the conversion to <CODE>bool</CODE> is <CODE>true</CODE> when
<CODE>get() != pointer()</CODE>, otherwise <CODE>false</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__pointer"></A>unique_ptr::pointer</CODE></H3>

<PRE>typedef T1 <B>pointer</B>;</PRE>

<P>The type is a synonym for <CODE>Del::pointer</CODE>
if defined, otherwise <CODE>Ty *</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__release"></A>unique_ptr::release</CODE></H3>

<PRE>pointer <B>release</B>() noexcept;</PRE>

<P>The member function stores <CODE>pointer()</CODE> in <CODE>stored_ptr</CODE>
and returns its previous contents.</P>

<H3><CODE><A NAME="unique_ptr__reset"></A>unique_ptr::reset</CODE></H3>

<PRE>void <B>reset</B>(pointer ptr = pointer()) noexcept;</PRE>

<P>If <CODE>ptr == stored_ptr</CODE> the member function does nothing.
Otherwise, if <CODE>ptr != 0</CODE>
it calls <CODE>get_deleter()(stored_ptr)</CODE> and stores
<CODE>ptr</CODE> in <CODE>stored_ptr</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__swap"></A>unique_ptr::swap</CODE></H3>

<PRE>void <B>swap</B>(unique_ptr&amp; right) noexcept;</PRE>

<P>The member function swaps <CODE>stored_ptr</CODE> with <CODE>right.stored_ptr</CODE>
and <CODE>stored_deleter</CODE> with <CODE>right.stored_deleter</CODE>.</P>

<H3><CODE><A NAME="unique_ptr__unique_ptr"></A>unique_ptr::unique_ptr</CODE></H3>

<PRE>constexpr <B>unique_ptr</B>() noexcept;
constexpr <B>unique_ptr</B>(nullptr_t) noexcept;
explicit <B>unique_ptr</B>(pointer ptr) noexcept;
<B>unique_ptr</B>(Ty *ptr,
    typename conditional&lt;is_reference&lt;Del&gt;::value, Del,
        typename add_reference&lt;const Del&gt;::type&gt;::type deleter) noexcept;
<B>unique_ptr</B>(pointer ptr,
    typename remove_reference&lt;Del&gt;::type&amp;&amp; deleter) noexcept;
<B>unique_ptr</B>(unique_ptr&amp;&amp; right) noexcept;
template&lt;class Ty2, class Del2&gt;
    <B>unique_ptr</B>(unique_ptr&lt;Ty2, Del2&gt;&amp;&amp; right) noexcept;
template&lt;class Ty2&gt;
    <B>unique_ptr</B>(auto_ptr&lt;Ty2&gt;&amp;&amp; right) noexcept;</PRE>

<P>The first two constructors construct an object that manages no resource.
The third constructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>.
The fourth constructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>
and <CODE>deleter</CODE> in <CODE>stored_deleter</CODE>.</P>

<P>The fifth costructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>
and moves <CODE>deleter</CODE> into <CODE>stored_deleter</CODE>.
The sixth and seventh constructors store <CODE>right.reset()</CODE> in <CODE>stored_ptr</CODE>
and forward <CODE>right.get_deleter()</CODE> into <CODE>stored_deleter</CODE>.</P>

<P>The last constructor stores <CODE>right.reset()</CODE> in <CODE>stored_ptr</CODE>.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
and <CODE>is_array&lt;Ty2&gt;</CODE>
<A HREF="typetrait.html#holds_false">holds false</A>,
and either <CODE>is_reference&lt;Del2&gt;</CODE> holds true
and <CODE>is_same&lt;Del, Del2&gt;</CODE> holds true
or <CODE>is_reference&lt;Del2&gt;</CODE> holds false
and <CODE>is_convertible&lt;Del, Del2&gt;</CODE> holds true,
the template constructor
<CODE>unique_ptr(unique_ptr&lt;Ty2, Del2&gt;&amp;&amp; right)</CODE>
does not participate in overload resolution.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>
and <CODE>is_same&lt;Del, default_delete&lt;Ty&gt;&gt;</CODE> holds true,
the template constructor
<CODE>unique_ptr(auto_ptr&lt;Ty2&gt;&amp;&amp; right)</CODE>
does not participate in overload resolution.</P>

<H3><CODE><A NAME="unique_ptr__~unique_ptr"></A>unique_ptr::~unique_ptr</CODE></H3>

<PRE><B>~unique_ptr</B>();</PRE>

<P>The destructor calls <CODE>get_deleter()(stored_ptr)</CODE>.</P>

<H2><CODE><A NAME="unique_ptr_arr"></A>unique_ptr&lt;Ty[], Del&gt;</CODE></H2>

<PRE>template&lt;class Ty, class Del&gt;
    struct <B>unique_ptr&lt;Ty[], Del&gt;</B> { <B>[added with C++11]</B>
    typedef Ty <B><A HREF="#unique_ptr__element_type">element_type</A></B>;
    typedef Del <B><A HREF="#unique_ptr__deleter_type">deleter_type</A></B>;
    typedef T1 <B><A HREF="#unique_ptr__pointer">pointer</A></B>;

    constexpr <B><A HREF="#unique_ptr_arr__unique_ptr">unique_ptr</A></B>() noexcept;
    constexpr <B><A HREF="#unique_ptr_arr__unique_ptr">unique_ptr</A></B>(nullptr_t) noexcept;
    explicit <B><A HREF="#unique_ptr__unique_ptr">unique_ptr</A></B>(pointer ptr) noexcept;
    <B><A HREF="#unique_ptr_arr__unique_ptr">unique_ptr</A></B>(pointer ptr,
        typename conditional&lt;is_reference&lt;Del&gt;::value, Del,
            typename add_reference&lt;const Del&gt;::type&gt;::type deleter) noexcept;
    <B><A HREF="#unique_ptr_arr__unique_ptr">unique_ptr</A></B>(pointer ptr,
        typename remove_reference&lt;Del&gt;::type&amp;&amp; deleter) noexcept;
    <B><A HREF="#unique_ptr_arr__unique_ptr">unique_ptr</A></B>(unique_ptr&amp;&amp; right) noexcept;

    <B><A HREF="#unique_ptr__~unique_ptr">~unique_ptr</A></B>();

    unique_ptr&amp; <B><A HREF="#unique_ptr__operator2">operator=</A></B>(unique_ptr&amp;&amp; right) noexcept;
    unique_ptr&amp; <B><A HREF="#unique_ptr__operator2">operator=</A></B>(nullptr_t) noexcept;

    void <B><A HREF="#unique_ptr__swap">swap</A></B>(unique_ptr&amp; right) noexcept;
    pointer <B><A HREF="#unique_ptr__release">release</A></B>() noexcept;
    void <B><A HREF="#unique_ptr__reset">reset</A></B>(pointer ptr = pointer()) noexcept;
    void <B><A HREF="#unique_ptr__reset">reset</A></B>(nullptr_t ptr) noexcept;

    pointer <B><A HREF="#unique_ptr__get">get</A></B>() const noexcept;
    Ty&amp; <B><A HREF="#unique_ptr_arr__operator[]">operator[]</A></B>(size_t idx) const;
    Del&amp; <B><A HREF="#unique_ptr__get_deleter">get_deleter</A></B>() noexcept;
    const Del&amp; <B><A HREF="#unique_ptr__get_deleter">get_deleter</A></B>() const noexcept;
    explicit <B><A HREF="#unique_ptr__operator_bool">operator bool</A></B>() const noexcept;

    <B>unique_ptr</B>(const unique_ptr&amp; right) = delete;
    unique_ptr&amp; <B>operator=</B>(const unique_ptr&amp; right) = delete;
    template&lt;class Ptr2&gt;
        void <B>reset</B>(_Ptr2 ptr) = delete;

private:
    pointer stored_ptr;    <I>// exposition only</I>
    Del stored_deleter;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes an object that uniquely manages an array resource.
Each <CODE>unique_ptr</CODE> object effectively stores a pointer to the array
object that it owns or stores a null pointer. A resource can be owned by no
more than one <CODE>unique_ptr</CODE> object; when the <CODE>unique_ptr</CODE>
object that owns a particular resource is destroyed the resource is freed.
A <CODE>unique_ptr</CODE> object may be moved, but not copied.</P>

<P>The resource is freed by calling a stored <B><A HREF="#deleter">deleter</A></B>
object of type <CODE>Del</CODE> that knows how resources are allocated for
a particular <CODE>unique_ptr</CODE>. The default deleter
<CODE><A HREF="#default_delete">default_delete</A>&lt;Ty[]&gt;</CODE>
assumes that the resource pointed to by <CODE>ptr</CODE> is allocated with
<CODE>::operator new[]</CODE>, so it can be freed by calling <CODE>Del()(ptr)</CODE>.
(The general template <CODE><A HREF="#unique_ptr">unique_ptr&lt;Ty&gt;</A></CODE>
manages non-array objects allocated with <CODE>::operator new</CODE>, and has the default deleter
<CODE><A HREF="#default_delete">default_delete&lt;Ty&gt;</A></CODE>.)</P>

<P>The stored pointer to a managed resource <CODE>stored_ptr</CODE> has type
<CODE><A HREF="#unique_ptr__pointer">pointer</A></CODE>. It is <CODE>Del::pointer</CODE>
if defined, otherwise <CODE>Ty *</CODE>. The stored deleter object
<CODE>stored_deleter</CODE> should occupy no space in the object if the deleter is stateless.
Note that <CODE>Del</CODE> can be a reference type.</P>

<H3><CODE><A NAME="unique_ptr_arr__operator[]"></A>unique_ptr::operator[]</CODE></H3>

<PRE>Ty&amp; <B>operator[]</B>(size_t idx) const;</PRE>

<P>The member function returns <CODE>stored_ptr[idx]</CODE>.</P>

<H3><CODE><A NAME="unique_ptr_arr__unique_ptr"></A>unique_ptr::unique_ptr</CODE></H3>

<PRE>constexpr <B>unique_ptr</B>() noexcept;
constexpr <B>unique_ptr</B>(nullptr_t) noexcept;
explicit <B>unique_ptr</B>(pointer ptr) noexcept;
<B>unique_ptr</B>(Ty *ptr,
    typename conditional&lt;is_reference&lt;Del&gt;::value, Del,
        typename add_reference&lt;const Del&gt;::type&gt;::type deleter) noexcept;
<B>unique_ptr</B>(pointer ptr,
    typename remove_reference&lt;Del&gt;::type&amp;&amp; deleter) noexcept;
<B>unique_ptr</B>(unique_ptr&amp;&amp; right) noexcept;</PRE>

<P>The first two constructors construct an object that manages no resource.
The third constructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>.
The fourth constructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>
and <CODE>deleter</CODE> in <CODE>stored_deleter</CODE>.</P>

<P>The fifth costructor stores <CODE>ptr</CODE> in <CODE>stored_ptr</CODE>
and moves <CODE>deleter</CODE> into <CODE>stored_deleter</CODE>.
The sixth constructor stores <CODE>right.reset()</CODE> in <CODE>stored_ptr</CODE>
and moves <CODE>right.get_deleter()</CODE> into <CODE>stored_deleter</CODE>.</P>

<H2><CODE><A NAME="uses_allocator"></A>uses_allocator</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    struct <B>uses_allocator</B>; <B>[added with C++11]</B></PRE>

<P>The template struct
<A HREF="typetrait.html#holds_true">holds true</A> only if
<CODE>Ty::allocator_type</CODE> exists and
<CODE>is_convertible&lt;Alloc, Ty::allocator_type&gt;</CODE>
holds true.</P>

<P>The template may be specialized, for a library type or user-defined type,
to hold true only if:</P>

<UL>
<LI>the first argument of a constructor has type
<CODE><A HREF="#allocator_arg_t">allocator_arg_t</A></CODE>
and the second argument has type <CODE>Alloc</CODE>, or</LI>

<LI>the last argument of a constructor has type <CODE>Alloc</CODE></LI>
</UL>

<P>A type that meets these requirements is said to be
<B><A NAME="allocator_enabled"></A>allocator enabled</B>.</P>

<H2><CODE><A NAME="weak_ptr"></A>weak_ptr</CODE></H2>

<PRE>template&lt;class Ty&gt; class <B>weak_ptr</B> {  <B>[added with C++11]</B>
public:
    typedef Ty <B><A HREF="#weak_ptr__element_type">element_type</A></B>;

    constexpr <B><A HREF="#weak_ptr__weak_ptr">weak_ptr</A></B>() noexcept;
    <B><A HREF="#weak_ptr__weak_ptr">weak_ptr</A></B>(const weak_ptr&amp;) noexcept;
    template&lt;class Other&gt;
        <B><A HREF="#weak_ptr__weak_ptr">weak_ptr</A></B>(const weak_ptr&lt;Other&gt;&amp;) noexcept;
    template&lt;class Other&gt;
        <B><A HREF="#weak_ptr__weak_ptr">weak_ptr</A></B>(const shared_ptr&lt;Other&gt;&amp;) noexcept;

    weak_ptr&amp; <B><A HREF="#weak_ptr__operator2">operator=</A></B>(const weak_ptr&amp;) noexcept;
    template&lt;class Other&gt;
        weak_ptr&amp; <B><A HREF="#weak_ptr__operator2">operator=</A></B>(const weak_ptr&lt;Other&gt;&amp;) noexcept;
    template&lt;class Other&gt;
        weak_ptr&amp; <B><A HREF="#weak_ptr__operator2">operator=</A></B>(shared_ptr&lt;Other&gt;&amp;) noexcept;

    void <B><A HREF="#weak_ptr__swap">swap</A></B>(weak_ptr&amp; right) noexcept;
    void <B><A HREF="#weak_ptr__reset">reset</A></B>() noexcept;

    long <B><A HREF="#weak_ptr__use_count">use_count</A></B>() const noexcept;
    bool <B><A HREF="#weak_ptr__expired">expired</A></B>() const noexcept;
    shared_ptr&lt;Ty&gt; <B><A HREF="#weak_ptr__lock">lock</A></B>() const noexcept;

    template&lt;class Other&gt;
        bool <B><A HREF="#weak_ptr__owner_before">owner_before</A></B>(const shared_ptr&lt;Other&gt;&amp; ptr); <B>[added with C++11]</B>
    template&lt;class Other&gt;
        bool <B><A HREF="#weak_ptr__owner_before">owner_before</A></B>(const weak_ptr&lt;Other&gt;&amp; ptr); <B>[added with C++11]</B>
    };</PRE>

<P>The template class describes an object that <A HREF="#points_to">points to</A>
a resource that is managed by one or more <CODE><A HREF="#shared_ptr">shared_ptr</A></CODE>
objects. The <CODE>weak_ptr</CODE> objects that point to a resource do not affect the
resource's reference count. Thus, when the last <CODE>shared_ptr</CODE> object
that manages that resource is destroyed the resource will be freed, even if
there are <CODE>weak_ptr</CODE> objects pointing to that resource. This is
essential for avoiding <A HREF="#cycle">cycles</A> in data structures.</P>

<P>A <CODE>weak_ptr</CODE> object <B><A NAME="points_to"></A>points to</B> a resource
if it was constructed from a <CODE>shared_ptr</CODE> object that <A HREF="#owns">owns</A>
that resource, if it was constructed from a <CODE>weak_ptr</CODE> object that
points to that resource, or if that resource was assigned to it with
<CODE><A HREF="#weak_ptr__operator2">operator=</A></CODE>. A <CODE>weak_ptr</CODE> object does
not provide direct access to the resource that it points to. Code that needs to use
the resource does so through a <CODE>shared_ptr</CODE> object that owns that resource,
created by calling the member function <A HREF="#weak_ptr__lock">lock</A>. A
<CODE>weak_ptr</CODE> object has <B><A NAME="expired"></A>expired</B> when the resource that
it points to has been freed because all of the <CODE>shared_ptr</CODE> objects that own
the resource have been destroyed. Calling <CODE>lock</CODE> on a <CODE>weak_ptr</CODE> object
that has expired creates an <A HREF="#empty_shared_ptr">empty shared_ptr</A> object.</P>

<P>An <B><A NAME="empty_weak_ptr"></A>empty weak_ptr</B> object does not point to any
resources and has no control block. Its member function <CODE>lock</CODE> returns
an <A HREF="#empty_shared_ptr">empty shared_ptr</A> object.</P>

<P>A <B><A NAME="cycle"></A>cycle</B> occurs when two or more resources controlled by
<CODE>shared_ptr</CODE> objects hold mutually referencing <CODE>shared_ptr</CODE> objects.
For example, a circular linked list with three elements has a head node <CODE>N0</CODE>;
that node holds a <CODE>shared_ptr</CODE> object that owns the next node, <CODE>N1</CODE>; that
node holds a <CODE>shared_ptr</CODE> object that owns the next node, <CODE>N2</CODE>; that node,
in turn, holds a <CODE>shared_ptr</CODE> object that owns the head node, <CODE>N0</CODE>, closing
the cycle. In this situation, none of the reference counts will every become zero, and
the nodes in the cycle will not be freed. To eliminate the cycle, the last node
<CODE>N2</CODE> should hold a <CODE>weak_ptr</CODE> object pointing to <CODE>N0</CODE> instead
of a <CODE>smart_ptr</CODE> object. Since the <CODE>weak_ptr</CODE> object does not own
<CODE>N0</CODE> it doesn't affect <CODE>N0</CODE>'s reference count, and when the program's
last reference to the head node is destroyed the nodes in the list will also be destroyed.</P>

<H3><CODE><A NAME="weak_ptr__element_type"></A>weak_ptr::element_type</CODE></H3>

<PRE>typedef Ty <B>element_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H3><CODE><A NAME="weak_ptr__expired"></A>weak_ptr::expired</CODE></H3>

<PRE>bool <B>expired</B>() const;</PRE>

<P>The member function returns <CODE>true</CODE> if <CODE>*this</CODE> has
<A HREF="#expired">expired</A>, otherwise <CODE>false</CODE>.</P>

<H3><CODE><A NAME="weak_ptr__lock"></A>weak_ptr::lock</CODE></H3>

<PRE>shared_ptr&lt;Ty&gt; <B>lock</B>() const;</PRE>

<P>The member function returns an <A HREF="#empty_shared_ptr">empty shared_ptr</A>
object if <CODE>*this</CODE> has <A HREF="#expired">expired</A>; otherwise it returns
a <CODE><A HREF="#shared_ptr">shared_ptr</A>&lt;Ty&gt;</CODE> object that
<A HREF="#owns">owns</A>
the resource that <CODE>*this</CODE> <A HREF="#points_to">points to</A>.</P>

<H3><CODE><A NAME="weak_ptr__operator2"></A>weak_ptr::operator=</CODE></H3>

<PRE>weak_ptr&amp; <B>operator=</B>(const weak_ptr&amp; wp);
template&lt;class Other&gt;
    weak_ptr&amp; <B>operator=</B>(const weak_ptr&lt;Other&gt;&amp; wp);
template&lt;class Other&gt;
    weak_ptr&amp; <B>operator=</B>(const shared_ptr&lt;Other&gt;&amp; sp);</PRE>

<P>The operators all <A HREF="#release">release</A> the resource currently
<A HREF="#points_to">pointed to</A> by <CODE>*this</CODE> and assign ownership of the
resource named by the <A HREF="#operand_sequence">operand sequence</A> to
<CODE>*this</CODE>. If an operator fails it leaves
<CODE>*this</CODE> unchanged.</P>

<H3><CODE><A NAME="weak_ptr__owner_before"></A>weak_ptr::owner_before</CODE></H3>

<PRE>template&lt;class Other&gt;
    bool <B>owner_before</B>(const shared_ptr&lt;Other&gt;&amp; ptr); <B>[added with C++11]</B>
template&lt;class Other&gt;
    bool <B>owner_before</B>(const weak_ptr&lt;Other&gt;&amp; ptr); <B>[added with C++11]</B></PRE>

<P>The template member function returns true if <CODE>*this</CODE> is
<A HREF="lib_stl.html#strict_weak_ordering">ordered before</A> <CODE>ptr</CODE>.</P>

<H3><CODE><A NAME="weak_ptr__reset"></A>weak_ptr::reset</CODE></H3>

<PRE>void <B>reset</B>() noexcept;</PRE>

<P>The member function <A HREF="#release">releases</A> the
resource <A HREF="#points_to">pointed to</A> by <CODE>*this</CODE>
and converts <CODE>*this</CODE> to an
<A HREF="#empty_weak_ptr">empty weak_ptr</A> object.</P>

<H3><CODE><A NAME="weak_ptr__swap"></A>weak_ptr::swap</CODE></H3>

<PRE>void <B>swap</B>(weak_ptr&amp; right) noexcept;</PRE>

<P>The member function leaves the resource originally <A HREF="#points_to">pointed to</A>
by <CODE>*this</CODE> subsequently pointed to by <CODE>wp</CODE>, and the resource
originally pointed to by <CODE>wp</CODE> subsequently pointed to by <CODE>*this</CODE>.
The function does not change the reference counts for the two resources and
it does not throw any exceptions.</P>

<H3><CODE><A NAME="weak_ptr__use_count"></A>weak_ptr::use_count</CODE></H3>

<PRE>long <B>use_count</B>() const;</PRE>

<P>The member function returns the number of <CODE>shared_ptr</CODE> objects
that <A HREF="#owns">own</A> the resource
<A HREF="#points_to">pointed to</A> by <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="weak_ptr__weak_ptr"></A>weak_ptr::weak_ptr</CODE></H3>

<PRE>constexpr <B>weak_ptr</B>();
<B>weak_ptr</B>(const weak_ptr&amp; wp);
template&lt;class Other&gt;
    <B>weak_ptr</B>(const weak_ptr&lt;Other&gt;&amp; wp);
template&lt;class Other&gt;
    <B>weak_ptr</B>(const shared_ptr&lt;Other&gt;&amp; sp);</PRE>

<P>The constructors each construct an object that <A HREF="#points_to">points to</A>
the resource named by the <A HREF="#operand_sequence">operand sequence</A>.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
the template constructor
<CODE>weak_ptr(const weak_ptr&lt;Other&gt;&amp; wp)</CODE>
does not participate in overload resolution.</P>

<P>Unless <CODE>is_convertible&lt;Other *, Ty *&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
the template constructor
<CODE>weak_ptr(const shared_ptr&lt;Other&gt;&amp; wp)</CODE>
does not participate in overload resolution.</P>


<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
