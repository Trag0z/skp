<HTML><HEAD>
<TITLE>&lt;istream&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;istream&gt;"></A><CODE>&lt;istream&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#basic_iostream">basic_iostream</A>
&middot; <A HREF="#basic_istream">basic_istream</A>
&middot; <A HREF="#iostream">iostream</A>
&middot; <A HREF="#istream">istream</A>
&middot; <A HREF="#operator&gt;&gt;">operator&gt;&gt;</A>
&middot; <A HREF="#wiostream">wiostream</A>
&middot; <A HREF="#wistream">wistream</A>
&middot; <A HREF="#ws">ws</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="lib_cpp.html#iostreams">iostreams</A>
standard header <B><CODE>&lt;istream&gt;</CODE></B>
to define template class
<CODE><A HREF="#basic_istream">basic_istream</A></CODE>,
which mediates extractions for the iostreams, and the template class.
<CODE><A HREF="#basic_iostream">basic_iostream</A></CODE>,
which mediates both insertions and extractions.
The header also defines a related
<A HREF="ios.html#manipulators">manipulator</A>.
(This header is typically included for you by another
of the iostreams headers. You seldom have occasion to include it
directly.)</P>

<PRE>namespace std {
template&lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_istream">basic_istream</A></B>;
typedef basic_istream&lt;char, char_traits&lt;char&gt; &gt;
    <B><A HREF="#istream">istream</A></B>;
typedef basic_istream&lt;wchar_t, char_traits&lt;wchar_t&gt; &gt;
    <B><A HREF="#wistream">wistream</A></B>;
template&lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_iostream">basic_iostream</A></B>;
typedef basic_iostream&lt;char, char_traits&lt;char&gt; &gt;
    <B><A HREF="#iostream">iostream</A></B>;
typedef basic_iostream&lt;wchar_t, char_traits&lt;wchar_t&gt; &gt;
    <B><A HREF="#wiostream">wiostream</A></B>;

        // EXTRACTORS
template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
        Elem *str);
template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
        Elem&amp; ch);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char *str);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char&amp; ch);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            unsigned char *str);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            unsigned char&amp; ch);

template&lt;class Elem, class Tr, class Ty&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(basic_istream&lt;char, Tr&gt;&amp;&amp; istr,
            Ty&amp; val); <B>[added with C++11]</B>

        // MANIPULATORS
template class&lt;Elem, Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B><A HREF="#ws">ws</A></B>(basic_istream&lt;Elem, Tr&gt;&amp; istr);
}  // namespace std</PRE>

<H2><A NAME="basic_iostream"></A><CODE>basic_iostream</CODE></H2>

<PRE>template &lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B>basic_iostream</B> : public basic_istream&lt;Elem, Tr&gt;,
        public basic_ostream&lt;Elem, Tr&gt; {
public:
    explicit <B>basic_iostream</B>(basic_streambuf&lt;Elem, Tr&gt;&amp; *strbuf);
    virtual <B>~basic_iostream</B>();

protected:
    <B><A HREF="#basic_iostream__basic_iostream">basic_iostream</A></B>(basic_iostream&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#basic_iostream__basic_iostream">basic_iostream</A></B>(const basic_iostream&amp; right) = delete; <B>[added with C++11]</B>
    basic_iostream&amp; <B><A HREF="#basic_iostream__operator2">operator=</A></B>(basic_iostream&amp;&amp; right); <B>[added with C++11]</B>
    basic_iostream&amp; <B><A HREF="#basic_iostream__operator2">operator=</A></B>(const basic_iostream&amp; right) = delete; <B>[added with C++11]</B>
    void <B><A HREF="#basic_iostream__swap">swap</A></B>(basic_iostream&amp; right); <B>[added with C++11]</B>
    };</PRE>

<P>The template class describes an object that controls
insertions, through its base object
<CODE><A HREF="ostream.html#basic_ostream">basic_ostream</A>&lt;Elem, Tr&gt;</CODE>,
and extractions, through its base object
<CODE><A HREF="#basic_istream">basic_istream</A>&lt;Elem, Tr&gt;</CODE>.
The two objects share a common virtual base object
<CODE><A HREF="ios.html#basic_ios">basic_ios</A>&lt;Elem, Tr&gt;</CODE>.
They also manage a common
<A HREF="streambu.html#stream_buffer">stream buffer</A>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined
by the class <CODE>Tr</CODE>.</P>

<H3><A NAME="basic_iostream__basic_iostream"></A><CODE>basic_iostream::basic_iostream</CODE></H3>

<PRE>explicit <B>basic_iostream</B>(basic_streambuf&lt;Elem, Tr&gt; *strbuf);
<B>basic_iostream</B>(basic_iostream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first constructor initializes the base objects
via <CODE>basic_istream(strbuf)</CODE> and <CODE>basic_ostream(strbuf)</CODE>.</P>

<P>The second constructor initializes the base objects by calling
<CODE><A HREF="ios.html#basic_ios__move">move</A>(right)</CODE>.</P>

<H3><A NAME="basic_iostream__operator2"></A><CODE>basic_iostream::operator=</CODE></H3>

<PRE>basic_iostream&amp; <B>operator=</B>(basic_iostream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The member operator calls
<CODE><A HREF="#basic_iostream__swap">swap</A>(right)</CODE>.</P>

<H3><A NAME="basic_iostream__swap"></A><CODE>basic_iostream::swap</CODE></H3>

<PRE>void <B>swap</B>(basic_iostream&amp; right); <B>[added with C++11]</B></PRE>

<P>The member function calls
<CODE><A HREF="#basic_iostream__swap">swap</A>(right)</CODE>.</P>

<H2><A NAME="basic_istream"></A><CODE>basic_istream</CODE></H2>

<HR>
<P><B><CODE><A HREF="#basic_istream__basic_istream">basic_istream</A>
&middot; <A HREF="#basic_istream__gcount">gcount</A>
&middot; <A HREF="#basic_istream__get">get</A>
&middot; <A HREF="#basic_istream__getline">getline</A>
&middot; <A HREF="#basic_istream__ignore">ignore</A>
&middot; <A HREF="#basic_istream__operator2">operator=</A>
&middot; <A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A>
&middot; <A HREF="#basic_istream__peek">peek</A>
&middot; <A HREF="#basic_istream__putback">putback</A>
&middot; <A HREF="#basic_istream__read">read</A>
&middot; <A HREF="#basic_istream__readsome">readsome</A>
&middot; <A HREF="#basic_istream__seekg">seekg</A>
&middot; <A HREF="#basic_istream__sentry">sentry</A>
&middot; <A HREF="#basic_istream__swap">swap</A>
&middot; <A HREF="#basic_istream__sync">sync</A>
&middot; <A HREF="#basic_istream__tellg">tellg</A>
&middot; <A HREF="#basic_istream__unget">unget</A>
</CODE></B></P>
<HR>

<PRE>template &lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B>basic_istream</B>
        : virtual public basic_ios&lt;Elem, Tr&gt; {
public:
    typedef typename basic_ios&lt;Elem, Tr&gt;::char_type char_type;
    typedef typename basic_ios&lt;Elem, Tr&gt;::traits_type traits_type;
    typedef typename basic_ios&lt;Elem, Tr&gt;::int_type int_type;
    typedef typename basic_ios&lt;Elem, Tr&gt;::pos_type pos_type;
    typedef typename basic_ios&lt;Elem, Tr&gt;::off_type off_type;

    explicit <B><A HREF="#basic_istream__basic_istream">basic_istream</A></B>(basic_streambuf&lt;Elem, Tr&gt; *strbuf);

protected:
    <B><A HREF="#basic_istream__basic_istream">basic_istream</A></B>(basic_istream&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#basic_istream__basic_istream">basic_istream</A></B>(const basic_istream&amp; right) = delete; <B>[added with C++11]</B>

    basic_istream&amp; <B><A HREF="#basic_istream__operator2">operator=</A></B>(basic_istream&amp;&amp; right); <B>[added with C++11]</B>
    basic_istream&amp; <B><A HREF="#basic_istream__operator2">operator=</A></B>(const basic_istream&amp; right) = delete; <B>[added with C++11]</B>
    void <B><A HREF="#basic_istream__swap">swap</A></B>(basic_istream&amp; right); <B>[added with C++11]</B>

public:

    class <B><A HREF="#basic_istream__sentry">sentry</A></B>;
    virtual <B>~basic_istream</B>();

    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(
        basic_istream&amp; (*pfn)(basic_istream&amp;));
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(
        ios_base&amp; (*pfn)(ios_base&amp;));
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(
        basic_ios&lt;Elem, Tr&gt;&amp; (*pfn)(basic_ios&lt;Elem, Tr&gt;&amp;));
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(
        basic_streambuf&lt;Elem, Tr&gt; *strbuf);

    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(bool&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(short&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned short&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(int&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned int&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(long&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned long&amp; val);

    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(long long&amp; val); <B>[added with C++11]</B>
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned long long&amp; val); <B>[added with C++11]</B>

    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(void *&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(float&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(double&amp; val);
    basic_istream&amp; <B><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></B>(long double&amp; val);

    streamsize <B><A HREF="#basic_istream__gcount">gcount</A></B>() const;

    int_type <B><A HREF="#basic_istream__get">get</A></B>();
    basic_istream&amp; <B><A HREF="#basic_istream__get">get</A></B>(char_type&amp; ch);
    basic_istream&amp; <B><A HREF="#basic_istream__get">get</A></B>(char_type *str, streamsize count);
    basic_istream&amp;
        <B><A HREF="#basic_istream__get">get</A></B>(char_type *str, streamsize count, char_type delim);
    basic_istream&amp;
        <B><A HREF="#basic_istream__get">get</A></B>(basic_streambuf&lt;char_type, Tr&gt;&amp; strbuf);
    basic_istream&amp;
        <B><A HREF="#basic_istream__get">get</A></B>(basic_streambuf&lt;Elem, Tr&gt;&amp; strbuf, char_type delim);

    basic_istream&amp; <B><A HREF="#basic_istream__getline">getline</A></B>(char_type *str, streamsize count);
    basic_istream&amp; <B><A HREF="#basic_istream__getline">getline</A></B>(char_type *str, streamsize count,
        char_type delim);

    basic_istream&amp; <B><A HREF="#basic_istream__ignore">ignore</A></B>(streamsize count = 1,
        int_type delim = traits_type::eof());
    int_type <B><A HREF="#basic_istream__peek">peek</A></B>();
    basic_istream&amp; <B><A HREF="#basic_istream__read">read</A></B>(char_type *str, streamsize count);
    streamsize <B><A HREF="#basic_istream__readsome">readsome</A></B>(char_type *str, streamsize count);

    basic_istream&amp; <B><A HREF="#basic_istream__putback">putback</A></B>(char_type ch);
    basic_istream&amp; <B><A HREF="#basic_istream__unget">unget</A></B>();

    pos_type <B><A HREF="#basic_istream__tellg">tellg</A></B>();
    basic_istream&amp; <B><A HREF="#basic_istream__seekg">seekg</A></B>(pos_type pos);
    basic_istream&amp; <B><A HREF="#basic_istream__seekg">seekg</A></B>(off_type off,
        ios_base::seek_dir way);
    int <B><A HREF="#basic_istream__sync">sync</A></B>();
    };</PRE>

<P>The template class describes an object that controls
extraction of elements and encoded objects from a
<A HREF="streambu.html#stream_buffer">stream buffer</A>
with elements of type <CODE>Elem</CODE>, also known as
<CODE><A HREF="ios.html#basic_ios__char_type">char_type</A></CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined by the
class <CODE>Tr</CODE>, also known as
<CODE><A HREF="ios.html#basic_ios__traits_type">traits_type</A></CODE>.</P>

<P>Most of the member functions that overload
<CODE><A HREF="#basic_istream__operator&gt;&gt;">operator&gt;&gt;</A></CODE>
are <B><A NAME="formatted_input_functions"></A>formatted input functions</B>.
They follow the pattern:</P>

<PRE>    iostate state = goodbit;
    const sentry ok(*this);
    if (ok)
        try
            {&lt;extract elements and convert
            accumulate flags in state
            store a successful conversion&gt; }
    setstate(state);
    return (*this);</PRE>

<P>Other member functions are
<B><A NAME="unformatted_input_functions"></A>unformatted input functions</B>.
They follow the pattern:</P>

<PRE>    count = 0;    // the value returned by gcount
    iostate state = goodbit;
    const sentry ok(*this, true);
    if (ok)
        try
            {&lt;extract elements and deliver
            count extracted elements in count
            accumulate flags in state&gt; }
    setstate(state);</PRE>

<P>Still other member functions are
<B><A NAME="positioning_functions"></A>positioning functions</B>.
They follow the pattern:</P>

<PRE>iostate state = goodbit;
    const sentry ok(*this, true);
    if (!fail())
        {&lt;perform positioning operation
        accumulate (flags) in state&gt; }
    setstate(state);</PRE>

<P>All groups of functions call
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(eofbit)</CODE>
if they encounter end-of-file while extracting elements.</P>

<P>An object of class <CODE>basic_istream&lt;Elem, Tr&gt;</CODE> stores:</P>

<UL>
<LI>a virtual public base object of class
<B><CODE><A HREF="ios.html#basic_ios">basic_ios</A>&lt;Elem, Tr&gt;</CODE></B></LI>

<LI>an <B><A NAME="extraction_count"></A>extraction count</B>
for the last unformatted input operation (called <CODE>count</CODE>
in the code above)</LI>
</UL>

<H3><A NAME="basic_istream__basic_istream"></A><CODE>basic_istream::basic_istream</CODE></H3>

<PRE>explicit <B>basic_istream</B>(basic_streambuf&lt;Elem, Tr&gt; *strbuf);
<B>basic_istream</B>(basic_istream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="ios.html#basic_ios__init">init</A>(strbuf)</CODE>.
It also stores zero in the
<A HREF="#extraction_count">extraction count</A>.</P>

<P>The second constructor initializes the base class by calling
<CODE><A HREF="ios.html#basic_ios__move">move</A>(right)</CODE>.
It also stores <CODE>right.gcount()</CODE> in the
extraction count and stores zero in the extraction count for <CODE>right</CODE>.</P>

<H3><A NAME="basic_istream__gcount"></A><CODE>basic_istream::gcount</CODE></H3>

<PRE>streamsize <B>gcount</B>() const;</PRE>

<P>The member function returns the
<A HREF="#extraction_count">extraction count</A>.</P>

<H3><A NAME="basic_istream__get"></A><CODE>basic_istream::get</CODE></H3>

<PRE>int_type <B><A HREF="#basic_istream__get">get</A></B>();
basic_istream&amp; <B>get</B>(char_type&amp; ch);
basic_istream&amp; <B>get</B>(char_type *str, streamsize count);
basic_istream&amp; <B>get</B>(char_type *str, streamsize count,
    char_type delim);
basic_istream&amp; <B>get</B>(basic_streambuf&lt;Elem, Tr&gt;&amp; strbuf);
basic_istream&amp; <B>get</B>(basic_streambuf&lt;Elem, Tr&gt;&amp; strbuf,
    char_type delim);</PRE>

<P>The first of these
<A HREF="#unformatted_input_functions">unformatted input functions</A>
extracts an element, if possible, as if by returning
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__sbumpc">sbumpc</A>()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>.
If the function extracts no element, it calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.</P>

<P>The second function extracts the
<A HREF="ios.html#basic_ios__int_type"><CODE>int_type</CODE></A> element
<CODE>meta</CODE> the same way. If <CODE>meta</CODE> compares equal to
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
Otherwise, it stores
<CODE>traits_type::<A HREF="string2.html#char_traits__to_char_type">to_char_type</A>(meta)</CODE>
in <CODE>ch</CODE>. The function returns <CODE>*this</CODE>.</P>

<P>The third function returns <CODE>get(str, count, widen('\n'))</CODE>.</P>

<P>The fourth function extracts up to <CODE>N</CODE> elements,
where <CODE>N = count &lt;= 1 ? 0 : count - 1</CODE>,
and stores them in the array beginning at <CODE>str</CODE>. It always stores
<CODE>char_type()</CODE> after
any extracted elements it stores. In order of testing, extraction stops:</P>

<OL>
<LI>at end of file</LI>

<LI>after the function extracts an element that compares equal to
<CODE>delim</CODE>, in which case the element is put back
to the controlled sequence</LI>

<LI>after the function extracts <CODE>N</CODE> elements</LI>
</OL>

<P>If the function extracts no elements, it calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<P>The fifth function returns <CODE>get(strbuf, widen('\n'))</CODE>.</P>

<P>The sixth function extracts elements and inserts them in
<CODE>strbuf</CODE>. Extraction stops on end-of-file or on an element
that compares equal to <CODE>delim</CODE> (which is not extracted).
It also stops, without extracting the element in question,
if an insertion fails or throws an exception (which is caught
but not rethrown). If the function extracts no elements, it calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__getline"></A><CODE>basic_istream::getline</CODE></H3>

<PRE>basic_istream&amp; <B>getline</B>(char_type *str, streamsize count);
basic_istream&amp; <B>getline</B>(char_type *str, streamsize count,
    char_type delim);</PRE>

<P>The first of these
<A HREF="#unformatted_input_functions">unformatted input functions</A>
returns <CODE>getline(str, count, widen('\n'))</CODE>.</P>

<P>The second function extracts up to <CODE>N</CODE> elements,
where <CODE>N = count &lt;= 1 ? 0 : count - 1</CODE>,
and stores them in the array beginning at <CODE>str</CODE>. It always stores
<CODE>char_type()</CODE> after
any extracted elements it stores. In order of testing, extraction stops:</P>

<OL>
<LI>at end of file</LI>

<LI>after the function extracts an element that compares equal to
<CODE>delim</CODE>, in which case the element is neither put back nor
appended to the controlled sequence</LI>

<LI>after the function extracts <CODE>N</CODE> elements</LI>
</OL>

<P>If the function extracts no elements or <CODE>N</CODE> elements, it calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__ignore"></A><CODE>basic_istream::ignore</CODE></H3>

<PRE>basic_istream&amp; <B>ignore</B>(streamsize count = 1,
    int_type delim = traits_type::eof());</PRE>

<P>The <A HREF="#unformatted_input_functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements and discards them.
If <CODE>count</CODE> equals
<CODE>numeric_limits&lt;int&gt;::<A HREF="limits2.html#numeric_limits__max">max</A>()</CODE>,
however, it is taken as arbitrarily large.
Extraction stops early on end-of-file or
on an element <CODE>ch</CODE> such that
<CODE>traits_type::<A HREF="string2.html#char_traits__to_int_type">to_int_type</A>(ch)</CODE>
compares equal to <CODE>delim</CODE> (which is also extracted).
The function returns <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__operator2"></A><CODE>basic_istream::operator=</CODE></H3>

<PRE>basic_istream&amp; <B>operator=</B>(basic_istream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The member operator calls
<CODE><A HREF="#basic_istream__swap">swap</A>(right)</CODE>.</P>

<H3><A NAME="basic_istream__operator&gt;&gt;"></A><CODE>basic_istream::operator&gt;&gt;</CODE></H3>

<PRE>basic_istream&amp; <B>operator&gt;&gt;</B>(
    basic_istream&amp; (*pfn)(basic_istream&amp;));
basic_istream&amp; <B>operator&gt;&gt;</B>(
    ios_base&amp; (*pfn)(ios_base&amp;));
basic_istream&amp; <B>operator&gt;&gt;</B>(
    basic_ios&lt;Elem, Tr&gt;&amp; (*pfn)(basic_ios&lt;Elem, Tr&gt;&amp;));
basic_istream&amp; <B>operator&gt;&gt;</B>(
    basic_streambuf&lt;Elem, Tr&gt; *strbuf);
basic_istream&amp; <B>operator&gt;&gt;</B>(bool&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(short&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned short&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(int&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned int&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(long&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned long&amp; val);

basic_istream&amp; <B>operator&gt;&gt;</B>(long long&amp; val); <B>[added with C++11]</B>
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned long long&amp; val); <B>[added with C++11]</B>

basic_istream&amp; <B>operator&gt;&gt;</B>(void *&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(float&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(double&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(long double&amp; val);</PRE>

<P>The first member function ensures that an expression of the
form <CODE>istr &gt;&gt; ws</CODE> calls
<CODE><A HREF="#ws">ws</A>(istr)</CODE>, then returns <CODE>*this</CODE>.
The second and third functions ensure that other
<A HREF="ios.html#manipulators">manipulators</A>,
such as <CODE><A HREF="ios.html#hex">hex</A></CODE> behave
similarly.</P>

<P>The function:</P>

<PRE>basic_istream&amp; <B>operator&gt;&gt;</B>(
    basic_streambuf&lt;Elem, Tr&gt; *strbuf);</PRE>

<P>extracts elements, if <CODE>strbuf</CODE> is not a null pointer,
and inserts them in <CODE>strbuf</CODE>. Extraction stops on end-of-file.
It also stops, without extracting the element in question,
if an insertion fails or throws an exception (which is caught
but not rethrown).
If the function extracts no elements, it calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<P>The remaining functions constitute the
<A HREF="#formatted_input_functions">formatted input functions</A>.</P>

<P>The function:</P>

<PRE>basic_istream&amp; <B>operator&gt;&gt;</B>(bool&amp; val);</PRE>

<P>extracts a complete, nonempty boolean input field and converts it to a boolean value.
If successful, it stores the result in <CODE>val</CODE>.
The function returns <CODE>*this</CODE>.</P>

<P>A boolean input field takes one of two forms.
If <CODE>iosbase.flags() &amp;
ios_base::<A HREF="ios.html#ios_base__boolalpha">boolalpha</A></CODE>
is false, it is the same as an integer input field, except that the
converted value must be either 0 (for false) or 1 (for true).
Otherwise, the sequence must match either
<CODE>"false"</CODE>
(for false), or
<CODE>"true"</CODE>
(for true).</P>

<P>The functions:</P>

<PRE>basic_istream&amp; <B>operator&gt;&gt;</B>(short&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned short&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(int&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned int&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(long&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned long&amp; val);

basic_istream&amp; <B>operator&gt;&gt;</B>(long long&amp; val); <B>[added with C++11]</B>
basic_istream&amp; <B>operator&gt;&gt;</B>(unsigned long long&amp; val); <B>[added with C++11]</B>

basic_istream&amp; <B>operator&gt;&gt;</B>(void *&amp; val);</PRE>

<P>each extract a complete, nonempty integer input field and convert it to a numeric value.
If successful, and the converted value can be represented as the type of <CODE>val</CODE>,
it stores the result in <CODE>val</CODE>.</P>

<P>If the converted value cannot
be represented as the type of <CODE>val</CODE>, the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<P>The integer input field is converted by the same rules used by the
<A HREF="lib_scan.html#Scan_Functions">scan functions</A>
for matching and converting a series of <I>char</I> elements from a file.
(Each such <I>char</I> element is assumed to map to an equivalent element
of type <CODE>Elem</CODE> by a simple, one-to-one, mapping, as described
below.) If the type of <CODE>val</CODE> is <CODE>void *&amp;</CODE>, the equivalent
<A HREF="lib_scan.html#scan_conversion_specification">scan conversion
specification</A> is <CODE>p</CODE>.
Otherwise the conversion specification is determined as follows:</P>

<UL>
<LI>If <CODE>iosbase.<A HREF="ios.html#ios_base__flags">flags</A>() &amp;
ios_base::<A HREF="ios.html#ios_base__basefield">basefield</A> ==
ios_base::<A HREF="ios.html#ios_base__oct">oct</A></CODE>, the
conversion specification is <CODE>lo</CODE> or <CODE>llo</CODE>.</LI>

<LI>If <CODE>iosbase.flags() &amp; ios_base::basefield ==
ios_base::<A HREF="ios.html#ios_base__hex">hex</A></CODE>, the
conversion specification is <CODE>lx</CODE> or <CODE>llx</CODE>.</LI>

<LI>If <CODE>iosbase.flags() &amp; ios_base::basefield == 0</CODE>, the
conversion specification is <CODE>li</CODE> or <CODE>lli</CODE>.</LI>

<LI>Otherwise, the conversion specification is <CODE>ld</CODE>, <CODE>lu</CODE>, <CODE>lld</CODE>, or <CODE>llu</CODE>.</LI>
</UL>

<P>The functions:</P>

<PRE>basic_istream&amp; <B>operator&gt;&gt;</B>(float&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(double&amp; val);
basic_istream&amp; <B>operator&gt;&gt;</B>(long double&amp; val);</PRE>

<P>each are same as the above functions except that they extract a floating-point input field.
The equivalent scan conversion specifier is <CODE>lf</CODE> or <CODE>Lf</CODE>.</P>

<H3><A NAME="basic_istream__peek"></A><CODE>basic_istream::peek</CODE></H3>

<PRE>int_type <B>peek</B>();</PRE>

<P>The <A HREF="#unformatted_input_functions">unformatted input function</A>
extracts an element, if possible, as if by returning
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__sgetc">sgetc</A>()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>.</P>

<H3><A NAME="basic_istream__putback"></A><CODE>basic_istream::putback</CODE></H3>

<PRE>basic_istream&amp; <B>putback</B>(char_type ch);</PRE>

<P>The <A HREF="#positioning_functions">positioning function</A>
first clears <CODE>eofbit</CODE> (before constructing <CODE>sentry</CODE>), then
puts back <CODE>ch</CODE>, if possible, as if by calling
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__sputbackc">sputbackc</A>()</CODE>.
If <CODE><A HREF="ios.html#basic_ios__rdbuf">rdbuf</A>()</CODE>
is a null pointer, or if the call to <CODE>sputbackc</CODE> returns
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(badbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__read"></A><CODE>basic_istream::read</CODE></H3>

<PRE>basic_istream&amp; <B>read</B>(char_type *str, streamsize count);</PRE>

<P>The <A HREF="#unformatted_input_functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
Extraction stops early on end-of-file, in which case the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__readsome"></A><CODE>basic_istream::readsome</CODE></H3>

<PRE>streamsize <B>readsome</B>(char_type *str, streamsize count);</PRE>

<P>The <A HREF="#unformatted_input_functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
If <CODE><A HREF="ios.html#basic_ios__good">good</A>()</CODE> is
false, the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
Otherwise, it assigns the value of
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__in_avail">in_avail</A>()</CODE>
to <CODE>N</CODE>. If <CODE>N &lt; 0</CODE>, the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(eofbit)</CODE>.
Otherwise, it replaces the value stored in <CODE>N</CODE> with
the smaller of <CODE>count</CODE> and <CODE>N</CODE>, then calls
<CODE><A HREF="#basic_istream__read">read</A>(str, N)</CODE>.
In any case, the function returns
<CODE><A HREF="#basic_istream__gcount">gcount</A>()</CODE>.</P>

<H3><A NAME="basic_istream__seekg"></A><CODE>basic_istream::seekg</CODE></H3>

<PRE>basic_istream&amp; <B>seekg</B>(pos_type pos);
basic_istream&amp; <B>seekg</B>(off_type off,
    ios_base::seek_dir way);</PRE>

<P>Both <A HREF="#positioning_functions">positioning function</A>
first clear <CODE>eofbit</CODE> (before constructing <CODE>sentry</CODE>).</P>

<P>If <CODE><A HREF="ios.html#basic_ios__fail">fail</A>()</CODE> is false,
the first <A HREF="#positioning_functions">positioning function</A> calls
<CODE>newpos = <A HREF="ios.html#basic_ios__rdbuf">rdbuf</A>()-&gt;
<A HREF="streambu.html#basic_streambuf__pubseekpos">pubseekpos</A>(pos,
<A HREF="ios.html#ios_base__in">in</A>)</CODE>,
for some <CODE>pos_type</CODE> temporary object <CODE>newpos</CODE>.
If <CODE>fail()</CODE> is false, the second positioning function calls
<CODE>newpos = rdbuf()-&gt;
<A HREF="streambu.html#basic_streambuf__pubseekoff">pubseekoff</A>(off, way,
<A HREF="ios.html#ios_base__in">in</A>)</CODE>.
In either case, if <CODE>(off_type)newpos == (off_type)(-1)</CODE>
(the positioning operation fails) the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
Both functions return <CODE>*this</CODE>.</P>

<H3><A NAME="basic_istream__sentry"></A><CODE>basic_istream::sentry</CODE></H3>

<PRE>class <B>sentry</B> {
public:
    explicit <B>sentry</B>(basic_istream&amp; istr,
        bool noskip = false);
    explicit <B>operator bool</B>() const;

    <B>sentry</B>(const sentry&amp; right) = delete; <B>[added with C++11]</B>
    sentry&amp; <B>operator=</B>(const sentry&amp; right) = delete; <B>[added with C++11]</B>
    };</PRE>

<P>The nested class describes an object whose declaration structures the
<A HREF="#formatted_input_functions">formatted input functions</A> and the
<A HREF="#unformatted_input_functions">unformatted input functions</A>.
If <CODE><A HREF="ios.html#basic_ios__good">good</A>()</CODE>
is true, the constructor:</P>

<UL>
<LI>calls <CODE>istr.<A HREF="ios.html#basic_ios__tie">tie</A>-&gt;
<A HREF="ostream.html#basic_ostream__flush">flush</A>()</CODE>
if <CODE>tie()</CODE> is not a null pointer</LI>

<LI>effectively calls <CODE><A HREF="#ws">ws</A>(istr)</CODE> if
<CODE><A HREF="ios.html#ios_base__flags">flags</A>() &amp;
<A HREF="ios.html#ios_base__skipws">skipws</A></CODE> is nonzero</LI>
</UL>

<P>If, after any such preparation,
<CODE>good()</CODE> is false, the constructor calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, the constructor stores the value returned by <CODE>good()</CODE>
in <B>status</B>.
A later call to <CODE>operator bool()</CODE> delivers this stored value.</P>

<H3><A NAME="basic_istream__swap"></A><CODE>basic_istream::swap</CODE></H3>

<PRE>void <B>swap</B>(basic_istream&amp; right); <B>[added with C++11]</B></PRE>

<P>The member function calls
<CODE><A HREF="ios.html#basic_ios__swap">swap</A>(right)</CODE>.
It also exchanges the
<A HREF="#extraction_count">extraction count</A>
with the extraction count for <CODE>right</CODE>.</P>

<H3><A NAME="basic_istream__sync"></A><CODE>basic_istream::sync</CODE></H3>

<PRE>int <B>sync</B>();</PRE>

<P>If <CODE><A HREF="ios.html#basic_ios__rdbuf">rdbuf</A>()</CODE> is
a null pointer,
the <A HREF="#positioning_functions">positioning function</A> returns -1.
Otherwise, it calls
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__pubsync">pubsync</A>()</CODE>.
If that returns -1, the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(badbit)</CODE>
and returns -1. Otherwise, the function returns zero.</P>

<H3><A NAME="basic_istream__tellg"></A><CODE>basic_istream::tellg</CODE></H3>

<PRE>pos_type <B>tellg</B>();</PRE>

<P>If <CODE><A HREF="ios.html#basic_ios__fail">fail</A>()</CODE> is false,
the <A HREF="#positioning_functions">positioning function</A> returns
<CODE><A HREF="ios.html#basic_ios__rdbuf">rdbuf</A>()-&gt;
<A HREF="streambu.html#basic_streambuf__pubseekoff">pubseekoff</A>(0,
<A HREF="ios.html#ios_base__cur">cur</A>,
<A HREF="ios.html#ios_base__in">in</A>)</CODE>.
Otherwise, it returns <CODE>pos_type(-1)</CODE>.</P>

<H3><A NAME="basic_istream__unget"></A><CODE>basic_istream::unget</CODE></H3>

<PRE>basic_istream&amp; <B>unget</B>();</PRE>

<P>The <A HREF="#positioning_functions">positioning function</A>
first clears <CODE>eofbit</CODE> (before constructing <CODE>sentry</CODE>), then
puts back the previous element in the stream, if possible, as if by calling
<CODE>rdbuf()-&gt;<A HREF="streambu.html#basic_streambuf__sungetc">sungetc</A>()</CODE>.
If <CODE><A HREF="ios.html#basic_ios__rdbuf">rdbuf</A>()</CODE>
is a null pointer, or if the call to <CODE>sungetc</CODE> returns
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(badbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H2><A NAME="iostream"></A><CODE>iostream</CODE></H2>

<PRE>typedef basic_iostream&lt;char, char_traits&lt;char&gt; &gt; <B>iostream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_iostream"><CODE>basic_iostream</CODE></A>, specialized
for elements of type <I>char</I> with default
<A HREF="string2.html#character_traits">character traits</A>.</P>

<H2><A NAME="istream"></A><CODE>istream</CODE></H2>

<PRE>typedef basic_istream&lt;char, char_traits&lt;char&gt; &gt; <B>istream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istream"><CODE>basic_istream</CODE></A>, specialized
for elements of type <I>char</I> with default
<A HREF="string2.html#character_traits">character traits</A>.</P>

<H2><A NAME="operator&gt;&gt;"></A><CODE>operator&gt;&gt;</CODE></H2>

<PRE>template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
            Elem *str);
template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
            Elem&amp; ch);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char *str);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char&amp; ch);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            unsigned char *str);
template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            unsigned char&amp; ch);

template&lt;class Elem, class Tr, class Ty&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp;&amp; istr,
            Ty&amp; val); <B>[added with C++11]</B></PRE>

<P>The template function:</P>

<PRE>template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;Elem, Tr&gt;&amp; istr, Elem *str);</PRE>

<P>extracts up to <CODE>N - 1</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
If <CODE>istr.<A HREF="ios.html#ios_base__width">width</A>()</CODE> is greater
than zero, <CODE>N</CODE> is <CODE>istr.width()</CODE>; otherwise it is
the size of
the largest array of <CODE>Elem</CODE> that can be declared.
The function always stores
<CODE>Elem()</CODE> after
any extracted elements it stores. Extraction stops early on end-of-file,
on a character with value <CODE>Elem(0)</CODE> (which is not extracted),
or on any element (which is not extracted) that would be discarded by
<CODE><A HREF="#ws">ws</A></CODE>.
If the function extracts no elements, it calls
<CODE>istr.<A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, it calls <CODE>istr.width(0)</CODE> and
returns <CODE>istr</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;Elem, Tr&gt;&amp; istr, char&amp; ch);</PRE>

<P>extracts an element, if possible, and stores it in <CODE>ch</CODE>.
Otherwise, it calls
<CODE>is.<A HREF="ios.html#basic_ios__setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>istr</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char *str);</PRE>

<P>returns <CODE>istr &gt;&gt; (char *)str</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            signed char&amp; ch);</PRE>

<P>returns <CODE>istr &gt;&gt; (char&amp;)ch</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
       <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
           unsigned char *str);</PRE>

<P>returns <CODE>istr &gt;&gt; (char *)str</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Tr&gt;
    basic_istream&lt;char, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp; istr,
            unsigned char&amp; ch);</PRE>

<P>returns <CODE>istr &gt;&gt; (char&amp;)ch</CODE>.</P>

<P>The template function:</P>

<PRE>template&lt;class Elem, class Tr, class Ty&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <B>operator&gt;&gt;</B>(basic_istream&lt;char, Tr&gt;&amp;&amp; istr,
            Ty&amp; val); <B>[added with C++11]</B></PRE>

<P>returns <CODE>istr &gt;&gt; val</CODE> (and converts an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A> to
<CODE>istr</CODE> to an lvalue in the process).</P>

<H2><A NAME="wiostream"></A><CODE>wiostream</CODE></H2>

<PRE>typedef basic_iostream&lt;wchar_t, char_traits&lt;wchar_t&gt; &gt;
    <B>wiostream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_iostream"><CODE>basic_iostream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE> with default
<A HREF="string2.html#character_traits">character traits</A>.</P>

<H2><A NAME="wistream"></A><CODE>wistream</CODE></H2>

<PRE>typedef basic_istream&lt;wchar_t, char_traits&lt;wchar_t&gt; &gt;
    <B>wistream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istream"><CODE>basic_istream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE> with default
<A HREF="string2.html#character_traits">character traits</A>.</P>

<H2><A NAME="ws"></A><CODE>ws</CODE></H2>

<PRE>template class&lt;Elem, Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B>ws</B>(basic_istream&lt;Elem, Tr&gt;&amp; istr);</PRE>

<P>The manipulator extracts and discards any elements
<CODE>ch</CODE> for which
<CODE><A HREF="ctype.html#isspace">isspace</A>((unsigned char)<A HREF="ios.html#basic_ios__narrow">narrow</A>(ch, '\0'))</CODE>
is true.</P>

<P>The function calls
<CODE><A HREF="ios.html#basic_ios__setstate">setstate</A>(eofbit)</CODE>
if it encounters end-of-file while extracting elements.
It returns <CODE>istr</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
