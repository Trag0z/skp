<HTML><HEAD>
<TITLE>&lt;queue&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;queue&gt;"></A><CODE>&lt;queue&gt;</CODE></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;queue&gt;</CODE></B>
to define the template classes <CODE>priority_queue</CODE> and
<CODE>queue</CODE>, and several supporting templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Container&gt;
    class <B><A HREF="#queue">queue</A></B>;
template&lt;class Ty, class Container, class Pr&gt;
    class <B><A HREF="#priority_queue">priority_queue</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);

template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#swap">swap</A></B>(queue&lt;Ty, Container&gt;&amp; left,
        queue&lt;Ty, Container&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B>
template&lt;class Ty, class Container, class Pr&gt;
    bool <B><A HREF="#swap">swap</A></B>(priority_queue&lt;Ty, Container, Pr&gt;&amp; left,
        priority_queue&lt;Ty, Container, Pr&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B>

template&lt;class Ty, class Container, class Alloc&gt;
    struct <B><A HREF="#uses_allocator">uses_allocator</A></B>&lt;queue&lt;Ty, Container&gt;, alloc&gt;; <B>[added with C++11]</B>
template&lt;class Ty, class Container, class Pr, class Alloc&gt;
    struct <B><A HREF="#uses_allocator">uses_allocator</A></B>&lt;priority_queue&lt;Ty, Container, Pr&gt;, alloc&gt;; <B>[added with C++11]</B>
}  // namespace std</PRE>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator!=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator==</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#queue"><CODE>queue</CODE></A>. The function returns
<CODE>left.<A HREF="#queue__c">c</A> == right.c</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#queue"><CODE>queue</CODE></A>. The function returns
<CODE>left.<A HREF="#queue__c">c</A> &lt; right.c</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="priority_queue"></A><CODE>priority_queue</CODE></H2>

<PRE>template&lt;class Ty,
    class Container = vector&lt;Ty&gt;,
    class Pr = less&lt;typename Container::value_type&gt; &gt;
    class priority_queue {
public:
    typedef Container <B><A HREF="#priority_queue__container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#priority_queue__value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#priority_queue__size_type">size_type</A></B>;
    typedef typename Container::reference <B><A HREF="#priority_queue__reference">reference</A></B>;
    typedef typename Container::const_reference <B><A HREF="#priority_queue__const_reference">const_reference</A></B>;

    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>();
    explicit <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred);
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
        const container_type&amp; cont);
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const priority_queue&amp; right);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(InIt first, InIt last,
            const Pr&amp; pred);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(InIt first, InIt last,
            const Pr&amp; pred, const container_type&amp; cont);

    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
        container_type&amp;&amp; cont); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(priority_queue&amp;&amp; right)
        noexcept(is_nothrow_move_constructible&lt;Container&gt;::value
            &amp;&amp; is_nothrow_move_constructible&lt;Prr&gt;::value); <B>[added with C++11]</B>
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(InIt first, InIt last,
            const Pr&amp; pred, container_type&amp;&amp; cont); <B>[added with C++11]</B>

    template&lt;class Allloc&gt;
        explicit <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
            const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const priority_queue&amp; right,
            const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
            container_type&amp;&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(priority_queue&amp;&amp; right,
            const Alloc&amp; al); <B>[added with C++11]</B>

    priority_queue <B><A HREF="#priority_queue__operator2">operator=</A></B>(priority_queue&amp;&amp; right)
        noexcept(is_nothrow_move_assignable&lt;Container&gt;::value
            &amp;&amp; is_nothrow_move_assignable&lt;Prr&gt;::value); <B>[added with C++11]</B>
    void <B><A HREF="#priority_queue__swap">swap</A></B>(priority_queue&amp; right)
        noexcept(noexcept(swap(c, right.c))
            &amp;&amp; noexcept(swap(comp, right.comp))); <B>[added with C++11]</B>

    bool <B><A HREF="#priority_queue__empty">empty</A></B>() const;
    size_type <B><A HREF="#priority_queue__size">size</A></B>() const;
    const_reference <B><A HREF="#priority_queue__top">top</A></B>() const;
    void <B><A HREF="#priority_queue__push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#priority_queue__push">push</A></B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
    template&lt;class... Ty&gt;
        void <B><A HREF="#priority_queue__emplace">emplace</A></B>(Ty&amp;&amp;... val); <B>[added with C++11]</B>
    void <B><A HREF="#priority_queue__pop">pop</A></B>();

protected:
    Container <B><A HREF="#priority_queue__c">c</A></B>;
    Pr <B><A HREF="#priority_queue__comp">comp</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="priority_queue__c"></A><CODE>c</CODE></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#priority_queue__value_type">value_type</A></CODE>.</P>

<P>The sequence is ordered using a protected object named
<B><A NAME="priority_queue__comp"></A><CODE>comp</CODE></B>.
After each insertion or removal of the top element (at position zero),
for the iterators <CODE>P0</CODE> and <CODE>Pi</CODE>
designating elements at positions <CODE>0</CODE>
and <CODE>I</CODE>, <CODE>comp(*P0, *Pi)</CODE> is false.
(For the default template parameter
<CODE><A HREF="functio2.html#less">less</A>&lt;typename Container::value_type&gt;</CODE>
the top element of the sequence compares largest, or highest priority.)</P>

<P>An object of class <CODE>Container</CODE> must supply
random-access iterators and
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE> and
<CODE><A HREF="vector.html#vector">vector</A></CODE>
(both of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    typedef T1 <B>iterator</B>;
    typedef T2 <B>reference</B>;
    typedef T3 <B>const_reference</B>;

    <B>Container</B>();
    template&lt;class InIt&gt;
        <B>Container</B>(InIt first, InIt last);

    template&lt;class InIt&gt;
        void <B>insert</B>(iterator where, InIt first, InIt last);
    iterator <B>begin</B>();
    iterator <B>end</B>();
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    const_reference <B>front</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    template&lt;class... Ty&gt;
        void <B>emplace_back</B>(const Ty&amp;... val); <B>[added with C++11]</B>
    void <B>pop_back</B>();</PRE>

<P>Here, <CODE>T0</CODE>, <CODE>T1</CODE>, <CODE>T2</CODE>, and <CODE>T3</CODE>
are unspecified types that meet the stated requirements.</P>

<P>Moreover, beginning with <B>C++11</B>,
it must be possible to swap two <CODE>Container</CODE>
objects by calling the standard function <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="priority_queue__const_reference"></A>priority_queue::const_reference</CODE></H3>

<PRE>typedef typename Container::const_reference <B>const_reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::const_reference</CODE>.</P>

<H3><CODE><A NAME="priority_queue__container_type"></A>priority_queue::container_type</CODE></H3>

<PRE>typedef typename Container::container_type <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="priority_queue__empty"></A>priority_queue::empty</CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="priority_queue__emplace"></A>priority_queue::emplace</CODE></H3>

<PRE>template&lt;class... Ty&gt;
    void <B>emplace</B>(Ty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function executes:</P>

<PRE>c.emplace_back(forward&lt;Ty&gt;(val)...);
push_heap(c.begin(), c.end(), comp);</PRE>

<H3><CODE><A NAME="priority_queue__operator2"></A>priority_queue::operator=</CODE></H3>

<PRE>priority_queue&gt; <B>operator=</B>(priority_queue&amp;&amp; right)
    noexcept(is_nothrow_move_assignable&lt;Container&gt;::value
        &amp;&amp; is_nothrow_move_assignable&lt;Prr&gt;::value); <B>[added with C++11]</B></PRE>

<P>The operator moves <CODE>right</CODE>, as an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>
to <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="priority_queue__pop"></A>priority_queue::pop</CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty, then reorders it.</P>

<H3><CODE><A NAME="priority_queue__priority_queue"></A>priority_queue::priority_queue</CODE></H3>

<PRE><B>priority_queue</B>();
explicit <B>priority_queue</B>(const Pr&amp; pred);
<B>priority_queue</B>(const Pr&amp; pred,
    const container_type&amp; cont);
<B>priority_queue</B>(const priority_queue&amp; right);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred, const container_type&amp; cont);

<B>priority_queue</B>(const Pr&amp; pred,
    container_type&amp;&amp; cont)
        noexcept(is_nothrow_move_constructible&lt;Container&gt;::value
            &amp;&amp; is_nothrow_move_constructible&lt;Prr&gt;::value); <B>[added with C++11]</B>&nbsp;
<B>priority_queue</B>(priority_queue&amp;&amp; right); <B>[added with C++11]</B>
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred, container_type&amp;&amp; cont); <B>[added with C++11]</B></PRE>
<PRE>template&lt;class Allloc&gt;
    explicit <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
        const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const priority_queue&amp; right,
        const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(const Pr&amp; pred,
        container_type&amp;&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    <B><A HREF="#priority_queue__priority_queue">priority_queue</A></B>(priority_queue&amp;&amp; right,
        const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>All constructors with an argument <CODE>cont</CODE>
initialize the stored object with
<CODE><A HREF="#priority_queue__c">c</A>(cont)</CODE>.
The remaining constructors initialize the stored object with
<CODE>c()</CODE>, to specify an
empty initial controlled sequence.
The constructors with arguments <CODE>first</CODE> and <CODE>last</CODE> then call
<CODE>c.insert(c.end(), first, last)</CODE>.</P>

<P>The three constructors:</P>

<PRE><B>priority_queue</B>(const Pr&amp; pred,
    container_type&amp;&amp; cont)
        noexcept(is_nothrow_move_constructible&lt;Container&gt;::value
            &amp;&amp; is_nothrow_move_constructible&lt;Prr&gt;::value); <B>[added with C++11]</B>&nbsp;
<B>priority_queue</B>(priority_queue&amp;&amp; right); <B>[added with C++11]</B>
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred, container_type&amp;&amp; cont); <B>[added with C++11]</B></PRE>

<P>behave the same as earlier ones, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The remaining group behave the same as earlier constructors, but
with an added allocator argument.
Unless
<CODE><A HREF="memory.html#uses_allocator">uses_allocator</A>&lt;Container, Alloc&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
these constructors do not participate in overload resolution.</P>

<P>All constructors also store a function object in
<CODE><A HREF="#priority_queue__comp">comp</A></CODE>.
The function object <CODE>comp</CODE> is the argument <CODE>pred</CODE>, if present.
For the copy constructor, it is <CODE>right.comp</CODE>.
Otherwise, it is <CODE>Pr()</CODE>.</P>

<P>A non-empty initial controlled sequence is then ordered by calling
<CODE><A HREF="algorith.html#make_heap">make_heap</A>(c.begin(),
c.end(), comp)</CODE>.</P>


<H3><CODE><A NAME="priority_queue__push"></A>priority_queue::push</CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);
void <B>push</B>(value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence, then reorders it.</P>

<P>The second member functions is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="priority_queue__reference"></A>priority_queue::reference</CODE></H3>

<PRE>typedef typename Container::reference <B>reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::reference</CODE>.</P>

<H3><CODE><A NAME="priority_queue__size"></A>priority_queue::size</CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="priority_queue__size_type"></A>priority_queue::size_type</CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="priority_queue__swap"></A>priority_queue::swap</CODE></H3>

<PRE>void <B>swap</B>(priority_queue&amp; right)
    noexcept(noexcept(swap(c, right.c))
        &amp;&amp; noexcept(swap(comp, right.comp))); <B>[added with C++11]</B></PRE>

<P>The template function swaps <CODE>right</CODE> with <CODE>*this</CODE>,
using <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="priority_queue__top"></A>priority_queue::top</CODE></H3>

<PRE>const_reference <B>top</B>() const;</PRE>

<P>The member function returns a reference to the first (highest priority)
element of the controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="priority_queue__value_type"></A>priority_queue::value_type</CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<H2><A NAME="queue"></A><CODE>queue</CODE></H2>

<PRE>template&lt;class Ty,
    class Container = deque&lt;Ty&gt; &gt;
    class queue {
public:
    typedef Container <B><A HREF="#queue__container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#queue__value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#queue__size_type">size_type</A></B>;
    typedef typename Container::reference <B><A HREF="#queue__reference">reference</A></B>;
    typedef typename Container::const_reference <B><A HREF="#queue__const_reference">const_reference</A></B>;

    <B><A HREF="#queue__queue">queue</A></B>();
    <B><A HREF="#queue__queue">queue</A></B>(const queue&amp; right);
    explicit <B><A HREF="#queue__queue">queue</A></B>(const container_type&amp; cont);
    <B><A HREF="#queue__queue">queue</A></B>(queue&amp;&amp; right)
        noexcept(is_nothrow_move_constructible&lt;Container&gt;::value); <B>[added with C++11]</B>
    explicit <B><A HREF="#queue__queue">queue</A></B>(container_type&amp;&amp; cont); <B>[added with C++11]</B>

    explicit <B><A HREF="#queue__queue">queue</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#queue__queue">queue</A></B>(const queue&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#queue__queue">queue</A></B>(const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#queue__queue">queue</A></B>(queue&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#queue__queue">queue</A></B>(container_type&amp;&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>

    queue <B><A HREF="#queue__operator2">operator=</A></B>(queue&amp;&amp; right)
        noexcept(is_nothrow_move_assignable&lt;Container&gt;::value); <B>[added with C++11]</B>
    void <B><A HREF="#queue__swap">swap</A></B>(queue&amp; right)
        noexcept(noexcept(swap(c, right.c))); <B>[added with C++11]</B>

    bool <B><A HREF="#queue__empty">empty</A></B>() const;
    size_type <B><A HREF="#queue__size">size</A></B>() const;

    reference <B><A HREF="#queue__back">back</A></B>();
    const_reference <B><A HREF="#queue__back">back</A></B>() const;
    reference <B><A HREF="#queue__front">front</A></B>();
    const_reference <B><A HREF="#queue__front">front</A></B>() const;

    void <B><A HREF="#queue__push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#queue__push">push</A></B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
    template&lt;class... Ty&gt;
        void <B><A HREF="#queue__emplace">emplace</A></B>(Ty&amp;&amp;... val); <B>[added with C++11]</B>
    void <B><A HREF="#queue__pop">pop</A></B>();

protected:
    Container <B><A HREF="#queue__c">c</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="queue__c"></A><CODE>c</CODE></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#queue__value_type">value_type</A></CODE>.</P>

<P>An object of class <CODE>Container</CODE> must supply
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE> and
<CODE><A HREF="list.html#list">list</A></CODE>
(both of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    typedef T1 <B>reference</B>;
    typedef T2 <B>const_reference</B>;

    <B>Container</B>();
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    reference <B>front</B>();
    const_reference <B>front</B>() const;
    reference <B>back</B>();
    const_reference <B>back</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    template&lt;class... Ty&gt;
        void <B>emplace_back</B>(const Ty&amp;... val); <B>[added with C++11]</B>
    void <B>pop_front</B>();

    bool <B>operator==</B>(const Container&amp; cont) const;
    bool <B>operator!=</B>(const Container&amp; cont) const;
    bool <B>operator&lt;</B>(const Container&amp; cont) const;
    bool <B>operator&gt;</B>(const Container&amp; cont) const;
    bool <B>operator&lt;=</B>(const Container&amp; cont) const;
    bool <B>operator&gt;=</B>(const Container&amp; cont) const;</PRE>

<P>Here, <CODE>T0</CODE>, <CODE>T1</CODE>, and <CODE>T2</CODE> are unspecified
types that meet the stated requirements.</P>

<P>Moreover, beginning with <B>C++11</B>,
it must be possible to swap two <CODE>Container</CODE>
objects by calling the standard function <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="queue__back"></A>queue::back</CODE></H3>

<PRE>reference <B>back</B>();
const_reference <B>back</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue__const_reference"></A>queue::const_reference</CODE></H3>

<PRE>typedef typename Container::const_reference <B>const_reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::const_reference</CODE>.</P>

<H3><CODE><A NAME="queue__container_type"></A>queue::container_type</CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="queue__emplace"></A>queue::emplace</CODE></H3>

<PRE>template&lt;class... Ty&gt;
    void <B>emplace</B>(Ty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function executes:</P>

<PRE>c.emplace_back(forward&lt;Ty&gt;(val)...);</PRE>

<H3><CODE><A NAME="queue__empty"></A>queue::empty</CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="queue__front"></A>queue::front</CODE></H3>

<PRE>reference <B>front</B>();
const_reference <B>front</B>() const;</PRE>

<P>The member function returns a reference to the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue__operator2"></A>queue::operator=</CODE></H3>

<PRE>queue&gt; <B>operator=</B>(queue&amp;&amp; right)
    noexcept(is_nothrow_move_assignable&lt;Container&gt;::value); <B>[added with C++11]</B></PRE>

<P>The operator moves <CODE>right</CODE> to <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="queue__pop"></A>queue::pop</CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue__push"></A>queue::push</CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);
void <B>push</B>(value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<P>The second member functions is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="queue__queue"></A>queue::queue</CODE></H3>

<PRE><B>queue</B>();
<B>queue</B>(const queue&amp; right);
explicit <B>queue</B>(const container_type&amp; cont);
<B>queue</B>(queue&amp;&amp; right); <B>[added with C++11]</B>
explicit <B>queue</B>(container_type&amp;&amp; cont)
    noexcept(is_nothrow_move_constructible&lt;Container&gt;::value); <B>[added with C++11]</B>

explicit <B>queue</B>(const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>queue</B>(const queue&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>queue</B>(const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>queue</B>(queue&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>queue</B>(container_type&amp;&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>The first constructor initializes the stored object with
<CODE><A HREF="#queue__c">c</A>()</CODE>, to specify an
empty initial controlled sequence.
The second constructor initializes the stored object with
<CODE>right.c</CODE>, to specify an
initial controlled sequence that is a copy of the sequence controlled
by <CODE>right.c</CODE>.
The third constructor initializes the stored object with
<CODE><A HREF="#queue__c">c</A>(cont)</CODE>, to specify an
initial controlled sequence that is a copy of the sequence controlled
by <CODE>cont</CODE>.</P>


<P>The fourth constructor is a move constructor, and the fifth is the
same as the third but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The remaining group behave the same as earlier constructors, but
with an added allocator argument. Unless
<CODE><A HREF="memory.html#uses_allocator">uses_allocator</A>&lt;Container, Alloc&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
these constructors do not participate in overload resolution.</P>

<H3><CODE><A NAME="queue__reference"></A>queue::reference</CODE></H3>

<PRE>typedef typename Container::reference <B>reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::reference</CODE>.</P>

<H3><CODE><A NAME="queue__size"></A>queue::size</CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="queue__size_type"></A>queue::size_type</CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="queue__swap"></A>queue::swap</CODE></H3>

<PRE>void <B>swap</B>(queue&amp;&amp; right)
    noexcept(noexcept(swap(c, right.c))); <B>[added with C++11]</B></PRE>

<P>The template function swaps <CODE>right</CODE> with <CODE>*this</CODE>,
using <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="queue__value_type"></A>queue::value_type</CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<H2><CODE><A NAME="swap"></A>swap</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>swap</B>(queue&lt;Ty, Container&gt;&amp; left,
        queue&lt;Ty, Container&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B>
template&lt;class Ty, class Container, class Pr&gt;
    bool <B>swap</B>(priority_queue&lt;Ty, Container, Pr&gt;&amp; left,
        priority_queue&lt;Ty, Container, Pr&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B></PRE>

<P>The template function executes
<CODE>left.swap(right)</CODE>.</P>

<H2><CODE><A NAME="uses_allocator"></A>uses_allocator</CODE></H2>

<PRE>template&lt;class Ty, class Container, class Alloc&gt;
    struct <B>uses_allocator</B>&lt;queue&lt;Ty, Container&gt;, alloc&gt;; <B>[added with C++11]</B>
template&lt;class Ty, class Container, class Pr, class Alloc&gt;
    struct <B>uses_allocator</B>&lt;priority_queue&lt;Ty, Container, Pr&gt;, alloc&gt;; <B>[added with C++11]</B></PRE>

<P>The specializations
<A HREF="typetrait.html#holds_true">hold true</A> only if
<CODE><A HREF="memory.html#uses_allocator">uses_allocator</A>&lt;Container, Alloc&gt;</CODE>
holds true.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
