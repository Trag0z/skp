<HTML><HEAD>
<TITLE>STL Container -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="Containers"></A>STL Containers</H1><HR>

<P>A <B><A HREF="#Containers">container</A></B> is an
<A HREF="index.html#STL">STL</A> template class
that manages a sequence of elements.
Such elements can be of any object type that supplies
a copy constructor, a destructor, and an assignment operator
(all with sensible behavior, of course).
The destructor may not throw an exception.
This document describes the properties required of all such
containers, in terms of a generic template class <CODE>Container</CODE>.
An actual container template class may have additional template parameters.
It will certainly have additional member functions.</P>

<P>The STL template container classes are:</P>

<PRE>    <A HREF="deque.html#deque">deque</A>&nbsp;
    <A HREF="forward_list.html#forward_list">forward_list</A>&nbsp;
    <A HREF="list.html#list">list</A>&nbsp;
    <A HREF="map.html#map">map</A>&nbsp;
    <A HREF="map.html#multimap">multimap</A>&nbsp;
    <A HREF="set.html#multiset">multiset</A>&nbsp;
    <A HREF="set.html#set">set</A>&nbsp;
    <A HREF="unordered_map.html#unordered_map">unordered_map</A>&nbsp;
    <A HREF="unordered_map.html#unordered_multimap">unordered_multimap</A>&nbsp;
    <A HREF="unordered_set.html#unordered_multiset">unordered_multiset</A>&nbsp;
    <A HREF="unordered_set.html#unordered_set">unordered_set</A>&nbsp;
    <A HREF="vector.html#vector">vector</A></PRE>

<PRE>namespace std {
template&lt;class Ty&gt;
    class <B><A HREF="#Container">Container</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const Container&lt;Ty&gt;&amp; left,
        const Container&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    void <B><A HREF="#swap">swap</A></B>(
        Container&lt;Ty&gt;&amp; left,
        Container&lt;Ty&gt;&amp; right);
}  // namespace std</PRE>

<H2><A NAME="Container"></A><CODE>Container</CODE></H2>

<HR>
<P><B><CODE><A HREF="#Container__allocator_type">allocator_type</A>
&middot; <A HREF="#Container__begin">begin</A>
&middot; <A HREF="#Container__cbegin">cbegin</A>
&middot; <A HREF="#Container__cend">cend</A>
&middot; <A HREF="#Container__const_pointer">const_pointer</A>
&middot; <A HREF="#Container__const_void_pointer">const_void_pointer</A>
&middot; <A HREF="#Container__clear">clear</A>
&middot; <A HREF="#Container__const_iterator">const_iterator</A>
&middot; <A HREF="#Container__const_reference">const_reference</A>
&middot; <A HREF="#Container__const_reverse_iterator">const_reverse_iterator</A>
&middot; <A HREF="#Container__crbegin">crbegin</A>
&middot; <A HREF="#Container__crend">crend</A>
&middot; <A HREF="#Container__difference_type">difference_type</A>
&middot; <A HREF="#Container__empty">empty</A>
&middot; <A HREF="#Container__end">end</A>
&middot; <A HREF="#Container__get_allocator">get_allocator</A>
&middot; <A HREF="#Container__erase">erase</A>
&middot; <A HREF="#Container__iterator">iterator</A>
&middot; <A HREF="#Container__max_size">max_size</A>
&middot; <A HREF="#Container__pointer">pointer</A>
&middot; <A HREF="#Container__rbegin">rbegin</A>
&middot; <A HREF="#Container__reference">reference</A>
&middot; <A HREF="#Container__rend">rend</A>
&middot; <A HREF="#Container__reverse_iterator">reverse_iterator</A>
&middot; <A HREF="#Container__size">size</A>
&middot; <A HREF="#Container__size_type">size_type</A>
&middot; <A HREF="#Container__swap">swap</A>
&middot; <A HREF="#Container__value_type">value_type</A>
&middot; <A HREF="#Container__void_pointer">void_pointer</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Ty,
    class Alloc&gt;
    class <B>Container</B> {
public:
    typedef Ty <B><A HREF="#Container__value_type">value_type</A></B>;
    typedef Alloc <B><A HREF="#Container__allocator_type">allocator_type</A></B>;

    typedef T1 <B><A HREF="#Container__pointer">pointer</A></B>;
    typedef T2 <B><A HREF="#Container__const_pointer">const_pointer</A></B>;
    typedef T3 <B><A HREF="#Container__void_pointer">void_pointer</A></B>;
    typedef T4 <B><A HREF="#Container__const_void_pointer">const_void_pointer</A></B>;

    typedef Ty&amp; <B><A HREF="#Container__reference">reference</A></B>;
    typedef const Ty&amp; <B><A HREF="#Container__const_reference">const_reference</A></B>;

    typedef T5 <B><A HREF="#Container__size_type">size_type</A></B>;
    typedef T6 <B><A HREF="#Container__difference_type">difference_type</A></B>;

    typedef T7 <B><A HREF="#Container__iterator">iterator</A></B>;
    typedef T8 <B><A HREF="#Container__const_iterator">const_iterator</A></B>;
    typedef T9 <B><A HREF="#Container__reverse_iterator">reverse_iterator</A></B>;
    typedef T10 <B><A HREF="#Container__const_reverse_iterator">const_reverse_iterator</A></B>;

    iterator <B><A HREF="#Container__begin">begin</A></B>();
    const_iterator <B><A HREF="#Container__begin">begin</A></B>() const;
    iterator <B><A HREF="#Container__end">end</A></B>();
    const_iterator <B><A HREF="#Container__end">end</A></B>() const;
    reverse_iterator <B><A HREF="#Container__rbegin">rbegin</A></B>();
    const_reverse_iterator <B><A HREF="#Container__rbegin">rbegin</A></B>() const;
    reverse_iterator <B><A HREF="#Container__rend">rend</A></B>();
    const_reverse_iterator <B><A HREF="#Container__rend">rend</A></B>() const;

    const_iterator <B><A HREF="#Container__cbegin">cbegin</A></B>() const; <B>[added with C++11]</B>
    const_iterator <B><A HREF="#Container__cend">cend</A></B>() const; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#Container__crbegin">crbegin</A></B>() const; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#Container__crend">crend</A></B>() const; <B>[added with C++11]</B>

    allocator_type <B><A HREF="#Container__get_allocator">get_allocator</A></B>() const;
    size_type <B><A HREF="#Container__size">size</A></B>() const;
    size_type <B><A HREF="#Container__max_size">max_size</A></B>() const;
    bool <B><A HREF="#Container__empty">empty</A></B>() const;
    iterator <B><A HREF="#Container__erase">erase</A></B>(iterator where);
    iterator <B><A HREF="#Container__erase">erase</A></B>(iterator first, iterator last);
    void <B><A HREF="#Container__clear">clear</A></B>() noexcept;
    void <B><A HREF="#Container__swap">swap</A></B>(Container&amp; right);
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements,
typically of type <CODE>Ty</CODE>.
The sequence is stored in different ways, depending on the
actual container.</P>

<P>A container constructor or member function may find occasion
to call the copy constructor <CODE>Ty(const Ty&amp;)</CODE>,
the move constructor <CODE>Ty(Ty&amp;&amp;)</CODE>,
the copy assign function <CODE>Ty::operator=(const Ty&amp;)</CODE>
or the move assign function <CODE>Ty::operator=(Ty&amp;&amp;)</CODE>.
If such a call throws
an exception, the container object is obliged to maintain its integrity,
and to rethrow any exception it catches. You can safely swap, assign to,
erase, or destroy a container object
after it throws one of these exceptions.
In general, however, you cannot otherwise predict the state of the
sequence controlled by the container object.</P>

<P>A few additional caveats:</P>

<UL>
<LI>If the expression <CODE>~Ty()</CODE> throws an exception, the
resulting state of the container object is undefined.</LI>

<LI>If the stored allocator object <CODE>al</CODE> throws an exception,
other than as a result of a call to <CODE>al.allocate</CODE>,
the resulting state of the container object is undefined.</LI>

<LI>If the container stores a function object <CODE>comp</CODE>,
to determine how to order the controlled sequence, and <CODE>comp</CODE>
throws an exception of any kind, the resulting state of the container
object is undefined.</LI>
</UL>

<P>The container classes defined by STL satisfy several additional
requirements, as described in the following paragraphs.</P>

<P>Container template class
<CODE><A HREF="list.html">list</A></CODE> provides deterministic,
and useful, behavior even in the presence of the exceptions
described above. For example, if an exception is thrown during the
insertion of one or more elements, the container is left unaltered
and the exception is rethrown.</P>

<P>For <I>all</I> the container classes defined by STL,
if an exception is thrown during calls to the following member
functions:</P>

<PRE><B><A NAME="Container__insert"></A>insert</B> // single element inserted at end
<B><A NAME="Container__push_back"></A>push_back</B>&nbsp;
<B><A NAME="Container__push_front"></A>push_front</B></PRE>

<P>the container is left unaltered and the exception is rethrown.</P>

<P>For <I>all</I> the container classes defined by STL,
no exception is thrown during calls to the following member
functions:</P>

<PRE><B><A NAME="Container__pop_back"></A>pop_back</B>&nbsp;
<B><A NAME="Container__pop_front"></A>pop_front</B></PRE>

<P>The member function <CODE><A HREF="#Container__erase">erase</A></CODE>
throws an exception only if a
<B><A NAME="copy_operation"></A>copy operation</B>
(assignment or copy construction) throws an exception.</P>

<P>Moreover, no exception is thrown while copying an iterator returned by a
member function.</P>

<P>The member function <CODE><A HREF="#Container__swap">swap</A></CODE>
makes additional promises for <I>all</I> container classes defined by STL:</P>

<UL>
<LI>The member function throws an exception only if the container stores
an allocator object <CODE>al</CODE>,
and <CODE>al</CODE> throws an exception when copied,
or if the container stores a function object <CODE>comp</CODE>,
to determine how to order the controlled sequence, and <CODE>comp</CODE>
throws an exception when copied.</LI>

<LI>Unless otherwise specified,
references, pointers, and iterators that designate elements of
the controlled sequences being swapped remain valid.</LI>
</UL>

<P>An object of a container class defined by STL
allocates and frees storage for the sequence it controls
through a stored object of type <CODE>Alloc</CODE>,
which is typically a template parameter. Such an
<A HREF="memory.html#allocator_object">allocator object</A> must have
the same external interface as an object of class
<A HREF="memory.html#allocator"><CODE>allocator</CODE>&lt;Ty&gt;</A>.
In particular, <CODE>Alloc</CODE> must be the same type as
<CODE>Alloc::rebind&lt;value_type&gt;::other</CODE></P>

<P>For <I>all</I> container classes defined by STL, the member function:</P>

<PRE>Alloc <B><A HREF="#Container__get_allocator">get_allocator</A></B>() const;</PRE>

<P>returns a copy of the stored allocator object.</P>

<P>Beginning with C++11, an allocator can contain additional
member types and functions. Moreover, an allocator can omit
many of the member types and functions supplied by template
class <CODE>allocator</CODE>. Containers are expected to
mediate nearly all accesses to allocators through the class
<CODE><A HREF="memory.html#allocator_traits">allocator_traits</A>&lt;Alloc&gt;</CODE>.</P>

<P>Note that the stored allocator object is <I>not</I> necessarily
copied when the container
object is assigned. All constructors initialize the value stored
in <CODE>allocator</CODE>, to <CODE>Alloc()</CODE> if the constructor contains
no allocator parameter.</P>

<P>A container class defined by STL can assume that:</P>

<UL>
<LI>All objects of class <CODE>Alloc</CODE> need not compare equal.
(You can maintain multiple pools of storage.)</LI>

<LI>Type <CODE>Alloc::const_pointer</CODE> need not be the same as
<CODE>const Ty *</CODE>, and type <CODE>Alloc::pointer</CODE>
need not be the same as <CODE>Ty *</CODE>.
(A pointer can be a class.)</LI>

<LI><CODE>Alloc::allocate</CODE> and <CODE>Alloc::deallocate</CODE>
traffic in <CODE>Alloc::pointer</CODE> objects.</LI>

<LI>You can convert an <CODE>Alloc::pointer</CODE> object to a
<CODE>Ty *</CODE> object (and you must do so to construct or
destroy an object)</LI>

<LI>You <I>cannot</I> necessarily convert a
<CODE>Ty *</CODE> object to an <CODE>Alloc::pointer</CODE> object.</LI>
</UL>

<H3><CODE><A NAME="Container__allocator_type"></A>Container::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for <CODE>Alloc</CODE>.</P>

<H3><CODE><A NAME="Container__begin"></A>Container::begin</CODE></H3>

<PRE>const_iterator <B>begin</B>() const;
iterator <B>begin</B>();</PRE>

<P>The member function returns an iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P>

<H3><CODE><A NAME="Container__cbegin"></A>Container::cbegin</CODE></H3>

<PRE>const_iterator <B>cbegin</B>() const; <B>[added with C++11]</B></PRE>

<P>The member functions return a random-access iterator that points at the
first element of the sequence (or just beyond the end of an empty sequence).</P>

<H3><CODE><A NAME="Container__cend"></A>Container::cend</CODE></H3>

<PRE>const_reference <B>cend</B>() const; <B>[added with C++11]</B></PRE>

<P>The member functions return a random-access iterator that points just
beyond the end of the sequence.</P>

<H3><CODE><A NAME="Container__clear"></A>Container::clear</CODE></H3>

<PRE>void <B>clear</B>() noexcept;</PRE>

<P>The member function calls
<CODE><A HREF="#Container__erase">erase</A>(
<A HREF="#Container__begin">begin</A>(),
<A HREF="#Container__end">end</A>())</CODE>.</P>

<H3><CODE><A NAME="Container__const_iterator"></A>Container::const_iterator</CODE></H3>

<PRE>typedef T8 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
iterator for the controlled sequence.
It is described here as a
synonym for the unspecified type <CODE>T8</CODE>.</P>

<H3><CODE><A NAME="Container__const_pointer"></A>Container::const_pointer</CODE></H3>

<PRE>typedef T2 <B>const_pointer</B>;</PRE>

<P>The type describes an object that can serve as a
pointer to constant allocated storage.
It is described here as a
synonym for the unspecified type <CODE>T2</CODE>.</P>

<H3><CODE><A NAME="Container__const_reference"></A>Container::const_reference</CODE></H3>

<PRE>typedef const Ty&amp; <B>const_reference</B>;</PRE>

<P>The type describes a constant reference
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="Container__const_reverse_iterator"></A>Container::const_reverse_iterator</CODE></H3>

<PRE>typedef T10 <B>const_reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant reverse
iterator for the controlled sequence. It is described here as a
synonym for the unspecified type <CODE>T10</CODE> (typically
<CODE><A HREF="iterator.html#reverse_iterator">reverse_iterator</A>
&lt;<A HREF="#Container__const_iterator">const_iterator</A>&gt;</CODE>).</P>

<H3><CODE><A NAME="Container__const_void_pointer"></A>Container::const_void_pointer</CODE></H3>

<PRE>typedef T4 <B>const_void_pointer</B>;</PRE>

<P>The type describes an object that can serve as a
generic pointer to constant allocated storage.
It is described here as a
synonym for the unspecified type <CODE>T4</CODE>.</P>

<H3><CODE><A NAME="Container__crbegin"></A>Container::crbegin</CODE></H3>

<PRE>const_reverse_iterator <B>crbegin</B>() const; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points just beyond
the end of the controlled sequence. Hence, it designates the beginning
of the reverse sequence.</P>

<H3><CODE><A NAME="Container__crend"></A>Container::crend</CODE></H3>

<PRE>const_reverse_iterator <B>crend</B>() const; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points at the first
element of the sequence (or just beyond the end of an empty sequence)). Hence,
it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="Container__difference_type"></A>Container::difference_type</CODE></H3>

<PRE>typedef T6 <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence. It is described here as a
synonym for the unspecified type <CODE>T6</CODE>
(typically <CODE>Alloc::difference_type</CODE>).</P>

<H3><CODE><A NAME="Container__empty"></A>Container::empty</CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="Container__end"></A>Container::end</CODE></H3>

<PRE>const_iterator <B>end</B>() const;
iterator <B>end</B>();</PRE>

<P>The member function returns an iterator that points
just beyond the end of the sequence.</P>

<H3><CODE><A NAME="Container__erase"></A>Container::erase</CODE></H3>

<PRE>iterator <B>erase</B>(iterator where);
iterator <B>erase</B>(iterator first, iterator last);</PRE>

<P>The first member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>. The second member function
removes the elements of the controlled sequence
in the range <CODE>[first, last)</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#Container__end">end</A>()</CODE> if no such element exists.</P>

<P>The member functions throw an exception only if a copy operation
throws an exception.</P>

<H3><CODE><A NAME="Container__get_allocator"></A>Container::get_allocator</CODE></H3>

<PRE>allocator_type <B>get_allocator</B>() const;</PRE>

<P>The member function returns a copy of the stored allocator object.</P>

<H3><CODE><A NAME="Container__iterator"></A>Container::iterator</CODE></H3>

<PRE>typedef T7 <B>iterator</B>;</PRE>

<P>The type describes an object that can serve as an
iterator for the controlled sequence.
It is described here as a
synonym for the unspecified type <CODE>T7</CODE>.
An object of type <CODE>iterator</CODE> can be cast
to an object of type
<CODE><A HREF="#Container__const_iterator">const_iterator</A></CODE>.</P>

<H3><CODE><A NAME="Container__max_size"></A>Container::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const;</PRE>

<P>The member function returns the length of the longest sequence that
the object can control, in constant time regardless of the length of the
controlled sequence.</P>

<H3><CODE><A NAME="Container__pointer"></A>Container::pointer</CODE></H3>

<PRE>typedef T1 <B>pointer</B>;</PRE>

<P>The type describes an object that can serve as a
pointer to allocated storage.
It is described here as a
synonym for the unspecified type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="Container__rbegin"></A>Container::rbegin</CODE></H3>

<PRE>const_reverse_iterator <B>rbegin</B>() const;
reverse_iterator <B>rbegin</B>();</PRE>

<P>The member function returns a reverse iterator that designates the
last element of the controlled sequence. Hence, it designates the
beginning of the reverse sequence.</P>

<H3><CODE><A NAME="Container__reference"></A>Container::reference</CODE></H3>

<PRE>typedef Ty&amp; <B>reference</B>;</PRE>

<P>The type describes a reference to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="Container__rend"></A>Container::rend</CODE></H3>

<PRE>const_reverse_iterator <B>rend</B>() const;
reverse_iterator <B>rend</B>();</PRE>

<P>The member function returns a reverse iterator that designates the
(fictitious) element before the first element of the controlled
sequence. Hence, it points just beyond the end of the reverse sequence.</P>

<H3><CODE><A NAME="Container__reverse_iterator"></A>Container::reverse_iterator</CODE></H3>

<PRE>typedef T10 <B>reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a reverse iterator
for the controlled sequence. It is described here as a
synonym for the unspecified type <CODE>T10</CODE> (typically
<CODE><A HREF="iterator.html#reverse_iterator">reverse_iterator</A>
&lt;<A HREF="#Container__iterator">iterator</A>&gt;</CODE>).</P>

<H3><CODE><A NAME="Container__size"></A>Container::size</CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence,
in constant time regardless of the length of the controlled sequence.</P>

<H3><CODE><A NAME="Container__size_type"></A>Container::size_type</CODE></H3>

<PRE>typedef T5 <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence. It is described here as a
synonym for the unspecified type <CODE>T5</CODE>
(typically <CODE>Alloc::size_type</CODE>).</P>

<H3><CODE><A NAME="Container__swap"></A>Container::swap</CODE></H3>

<PRE>void <B>swap</B>(Container&amp; right);</PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. If
<CODE><A HREF="#Container__get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time. Otherwise,
it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P>

<H3><CODE><A NAME="Container__value_type"></A>Container::value_type</CODE></H3>

<PRE>typedef T4 <B>value_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.
It is described here as a
synonym for the unspecified type <CODE>T4</CODE>
(typically <CODE>Alloc::value_type</CODE>).</P>

<H3><CODE><A NAME="Container__void_pointer"></A>Container::void_pointer</CODE></H3>

<PRE>typedef T3 <B>void_pointer</B>;</PRE>

<P>The type describes an object that can serve as a
generic pointer to allocated storage.
It is described here as a
synonym for the unspecified type <CODE>T3</CODE>.</P>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator!=</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator==</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#Container"><CODE>Container</CODE></A>. The function returns
<CODE>left.<A HREF="#Container__size">size</A>() == right.size() &amp;&amp;
<A HREF="algorith.html#equal">equal</A>(left.
<A HREF="#Container__begin">begin</A>(), left.
<A HREF="#Container__end">end</A>(), right.begin())</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator&lt;</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#Container"><CODE>Container</CODE></A>. The function returns
<CODE><A HREF="algorith.html#lexicographical_compare">lexicographical_compare</A>(left.
<A HREF="#Container__begin">begin</A>(), left.
<A HREF="#Container__end">end</A>(), right.begin(), right.end())</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator&lt;=</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator&gt;</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    bool <B>operator&gt;=</B>(
        const Container &lt;Ty&gt;&amp; left,
        const Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="swap"></A><CODE>swap</CODE></H2>

<PRE>template&lt;class Ty&gt;
    void <B>swap</B>(
        Container &lt;Ty&gt;&amp; left,
        Container &lt;Ty&gt;&amp; right);</PRE>

<P>The template function executes
<CODE>left.<A HREF="#Container__swap">swap</A>(right)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
