<HTML><HEAD>
<TITLE>&lt;random&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><CODE><A NAME="&lt;random&gt;"></A>&lt;random&gt;</CODE></H1>

<P>[added with C++11]</P><HR>

<P><B><CODE><A HREF="#bernoulli_distribution">bernoulli_distribution</A>
&middot; <A HREF="#binomial_distribution">binomial_distribution</A>
&middot; <A HREF="#discard_block">discard_block</A>
&middot; <A HREF="#exponential_distribution">exponential_distribution</A>
&middot; <A HREF="#gamma_distribution">gamma_distribution</A>
&middot; <A HREF="#geometric_distribution">geometric_distribution</A>
&middot; <A HREF="#linear_congruential">linear_congruential</A>
&middot; <A HREF="#mersenne_twister">mersenne_twister</A>
&middot; <A HREF="#minstd_rand0">minstd_rand0</A>
&middot; <A HREF="#minstd_rand">minstd_rand</A>
&middot; <A HREF="#mt19937">mt19937</A>
&middot; <A HREF="#normal_distribution">normal_distribution</A>
&middot; <A HREF="#operator_ne">operator!=</A>
&middot; <A HREF="#operator_eq">operator==</A>
&middot; <A HREF="#operator_lsh">operator&lt;&lt;</A>
&middot; <A HREF="#operator_rsh">operator&gt;&gt;</A>
&middot; <A HREF="#poisson_distribution">poisson_distribution</A>
&middot; <A HREF="#random_device">random_device</A>
&middot; <A HREF="#ranlux_base_01">ranlux_base_01</A>
&middot; <A HREF="#ranlux3">ranlux3</A>
&middot; <A HREF="#ranlux3_01">ranlux3_01</A>
&middot; <A HREF="#ranlux4">ranlux4</A>
&middot; <A HREF="#ranlux4_01">ranlux4_01</A>
&middot; <A HREF="#ranlux64_base_01">ranlux64_base_01</A>
&middot; <A HREF="#subtract_with_carry">subtract_with_carry</A>
&middot; <A HREF="#subtract_with_carry_01">subtract_with_carry_01</A>
&middot; <A HREF="#uniform_int">uniform_int</A>
&middot; <A HREF="#uniform_real">uniform_real</A>
&middot; <A HREF="#variate_generator">variate_generator</A>
&middot; <A HREF="#xor_combine">xor_combine</A>
</CODE></B></P>

<P><B><CODE><A HREF="#cauchy_distribution">cauchy_distribution</A>
&middot; <A HREF="#chi_squared_distribution">chi_squared_distribution</A>
&middot; <A HREF="#default_random_engine">default_random_engine</A>
&middot; <A HREF="#discard_block_engine">discard_block_engine</A>
&middot; <A HREF="#discrete_distribution">discrete_distribution</A>
&middot; <A HREF="#extreme_value_distribution">extreme_value_distribution</A>
&middot; <A HREF="#fisher_f_distribution">fisher_f_distribution</A>
&middot; <A HREF="#generate_canonical">generate_canonical</A>
&middot; <A HREF="#independent_bits_engine">independent_bits_engine</A>
&middot; <A HREF="#knuth_b">knuth_b</A>
&middot; <A HREF="#linear_congruential_engine">linear_congruential_engine</A>
&middot; <A HREF="#lognormal_distribution">lognormal_distribution</A>
&middot; <A HREF="#mersenne_twister_engine">mersenne_twister_engine</A>
&middot; <A HREF="#mt19937_64">mt19937_64</A>
&middot; <A HREF="#negative_binomial_distribution">negative_binomial_distribution</A>
&middot; <A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A>
&middot; <A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A>
&middot; <A HREF="#ranlux24">ranlux24</A>
&middot; <A HREF="#ranlux24_base">ranlux24_base</A>
&middot; <A HREF="#ranlux48">ranlux48</A>
&middot; <A HREF="#ranlux48_base">ranlux48_base</A>
&middot; <A HREF="#seed_seq">seed_seq</A>
&middot; <A HREF="#shuffle_order_engine">shuffle_order_engine</A>
&middot; <A HREF="#student_t_distribution">student_t_distribution</A>
&middot; <A HREF="#subtract_with_carry_engine">subtract_with_carry_engine</A>
&middot; <A HREF="#uniform_int_distribution">uniform_int_distribution</A>
&middot; <A HREF="#uniform_real_distribution">uniform_real_distribution</A>
&middot; <A HREF="#weibull_distribution">weibull_distribution</A>
</CODE></B></P>
<HR>

<P>Include the standard
header <B><CODE>&lt;random&gt;</CODE></B> to define a host of
<A HREF="lib_rand.html#random_number_generator">random number generators</A>.
For an overview of concepts related to this header, see
<A HREF="lib_rand.html#Random_Number_Generators">Random Number Generators</A>.</P>

<PRE>namespace std {
    // UTILITIES
template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <B><A HREF="#generate_canonical">generate_canonical</A></B>(Engine&amp; gen); <B>[added with C++11]</B>
class <B><A HREF="#seed_seq">seed_seq</A></B>; <B>[added with C++11]</B>

template&lt;class Engine,
    class Dist&gt;
    class <B><A HREF="#variate_generator">variate_generator</A></B>; <B>[removed in final C++11]</B>

    // SIMPLE ENGINES
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B><A HREF="#linear_congruential">linear_congruential</A></B>;
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <B><A HREF="#mersenne_twister">mersenne_twister</A></B>;
template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry">subtract_with_carry</A></B>;
template&lt;class RealType,
    int W, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry_01">subtract_with_carry_01</A></B>;
class <B><A HREF="#random_device">random_device</A></B>;

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B><A HREF="#linear_congruential_engine">linear_congruential_engine</A></B>; <B>[added with C++11]</B>
template&lt;class UIntType,
    size_t W, size_t N, size_t M, size_t R,
    UIntType A, size_t U,
    UIntType D, size_t S,
    UIntType B, size_t T,
    UIntType C, size_t L,
    UIntType F&gt;
    class <B><A HREF="#mersenne_twister_engine">mersenne_twister_engine</A></B>; <B>[added with C++11]</B>
template&lt;class UIntType,
    int W, int S, int R&gt;
    class <B><A HREF="#subtract_with_carry_engine">subtract_with_carry_engine</A></B>; <B>[added with C++11]</B>

    // COMPOUND ENGINES
template&lt;class Engine,
    int P, int R&gt;
    class <B><A HREF="#discard_block">discard_block</A></B>;
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <B><A HREF="#xor_combine">xor_combine</A></B>;

template&lt;class Engine,
    size_t P, size_t R&gt;
    class <B><A HREF="#discard_block_engine">discard_block_engine</A></B>; <B>[added with C++11]</B>
template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <B><A HREF="#independent_bits_engine">independent_bits_engine</A></B>; <B>[added with C++11]</B>
template&lt;class Engine,
    size_t K&gt;
    class <B><A HREF="#shuffle_order_engine">shuffle_order_engine</A></B>; <B>[added with C++11]</B>

    // ENGINES WITH PREDEFINED PARAMETERS
typedef linear_congruential_engine&lt;<I>ui-type</I>, 16807, 0, 2147483647&gt; <B><A HREF="#minstd_rand0">minstd_rand0</A></B>;
typedef linear_congruential_engine&lt;<I>ui-type</I>, 48271, 0, 2147483647&gt; <B><A HREF="#minstd_rand">minstd_rand</A></B>;
typedef mersenne_twister&lt;<I>ui-type</I>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <B><A HREF="#mt19937">mt19937</A></B>;
typedef mersenne_twister_engine&lt;<I>ui-type</I>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0x0ff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <B><A HREF="#mt19937_64">mt19937_64</A></B>; <B>[added with C++11]</B>
typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <B><A HREF="#ranlux_base_01">ranlux_base_01</A></B>;
typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <B><A HREF="#ranlux64_base_01">ranlux64_base_01</A></B>;
typedef discard_block&lt;subtract_with_carry&lt;<I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    223, 24&gt; <B><A HREF="#ranlux3">ranlux3</A></B>;
typedef discard_block&lt;subtract_with_carry&lt;<I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <B><A HREF="#ranlux4">ranlux4</A></B>;
typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <B><A HREF="#ranlux3_01">ranlux3_01</A></B>;
typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <B><A HREF="#ranlux4_01">ranlux4_01</A></B>;

typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <B><A HREF="#knuth_b">knuth_b</A></B>; <B>[added with C++11]</B>
typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 24, 10, 24&gt;
    <B><A HREF="#ranlux24_base">ranlux24_base</A></B>; <B>[added with C++11]</B>
typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <B><A HREF="#ranlux24">ranlux24</A></B>; <B>[added with C++11]</B>
typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 48, 5, 12&gt;
    <B><A HREF="#ranlux48_base">ranlux48_base</A></B>; <B>[added with C++11]</B>
typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <B><A HREF="#ranlux48">ranlux48</A></B>; <B>[added with C++11]</B>

typedef Rand <B><A HREF="#default_random_engine">default_random_engine</A></B>; <B>[added with C++11]</B>

    // DISTRIBUTIONS
class <B><A HREF="#bernoulli_distribution">bernoulli_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#binomial_distribution">binomial_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#geometric_distribution">geometric_distribution</A></B>;
template&lt;class IntType = int, class RealType = double&gt;
    class <B><A HREF="#poisson_distribution">poisson_distribution</A></B>;
template&lt;class IntType = int&gt;
    class <B><A HREF="#uniform_int">uniform_int</A></B>;

template&lt;class RealType = double&gt;
    class <B><A HREF="#exponential_distribution">exponential_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#gamma_distribution">gamma_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#normal_distribution">normal_distribution</A></B>;
template&lt;class RealType = double&gt;
    class <B><A HREF="#uniform_real">uniform_real</A></B>;

template&lt;class IntType = int&gt;
    class <B><A HREF="#discrete_distribution">discrete_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class IntType = int&gt;
    class <B><A HREF="#negative_binomial_distribution">negative_binomial_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class IntType = int&gt;
    class <B><A HREF="#uniform_int_distribution">uniform_int_distribution</A></B>; <B>[added with C++11]</B>

template&lt;class RealType = double&gt;
    class <B><A HREF="#cauchy_distribution">cauchy_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#chi_squared_distribution">chi_squared_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#extreme_value_distribution">extreme_value_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#fisher_f_distribution">fisher_f_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#lognormal_distribution">lognormal_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#student_t_distribution">student_t_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#uniform_real_distribution">uniform_real_distribution</A></B>; <B>[added with C++11]</B>
template&lt;class RealType = double&gt;
    class <B><A HREF="#weibull_distribution">weibull_distribution</A></B>; <B>[added with C++11]</B>

    // OPERATORS
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B><A HREF="#operator_eq">operator==</A></B>( <B>[added with C++11]</B>
        const shuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B><A HREF="#operator_ne">operator!=</A></B>( <B>[added with C++11]</B>
        const shuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_lsh">operator&lt;&lt;</A></B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, R&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B><A HREF="#operator_rsh">operator&gt;&gt;</A></B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);

    namespace tr1 {
using std::bernoulli_distribution; <B>[added with C++11]</B>
using std::binomial_distribution;
using std::discard_block; using std::exponential_distribution;
using std::gamma_distribution; using std::geometric_distribution;
using std::linear_congruential; using std::mersenne_twister;
using std::minstd_rand; using std::minstd_rand0;
using std::mt19937; using std::normal_distribution;
using std::poisson_distribution; using std::random_device;
using std::ranlux4; using std::ranlux3;
using std::ranlux3_01; using std::ranlux4;
using std::ranlux4_01; using std::ranlux64_base_01;
using std::ranlux_base_01; using std::subtract_with_carry;
using std::subtract_with_carry_01; using std::uniform_int;
using std::uniform_real; using std::variate_generator;
using std::xor_combine;

using std::cauchy_distribution; using std::chi_squared_distribution;
using std::discard_block_engine; using std::discrete_distribution;
using std::extreme_value_distribution; using std::fisher_f_distribution;
using std::generate_canonical;
using std::knuth_b; using std::independent_bits_engine;
using std::linear_congruential_engine; using std::lognormal_distribution;
using std::mersenne_twister_engine; using std::mt19937_64;
using std::negative_binomial_distribution;
using std::piecewise_constant_distribution; piecewise_linear_distribution;
using std::ranlux24; using std::ranlux24_base; using std::ranlux48;
using std::ranlux48_base; using std::seed_seq;
using std::shuffle_order_engine; using std::student_t_distribution;
using std::subtract_with_carry_engine;
using std::uniform_int_distribution; using std::uniform_real_distribution;
using std::weibull_distribution;
    } // namespace tr1
}  // namespace std</PRE>

<H2><CODE><A NAME="bernoulli_distribution"></A>bernoulli_distribution</CODE></H2>

<PRE>class <B>bernoulli_distribution</B> {
public:
    typedef int <B><A HREF="#bernoulli_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef bool <B><A HREF="#bernoulli_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#bernoulli_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#bernoulli_distribution__bernoulli_distribution">bernoulli_distribution</A></B>(double p0 = 0.5);
    explicit <B><A HREF="#bernoulli_distribution__bernoulli_distribution">bernoulli_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    double <B><A HREF="#bernoulli_distribution__p">p</A></B>() const;
    param_type <B><A HREF="#bernoulli_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#bernoulli_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#bernoulli_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#bernoulli_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#bernoulli_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#bernoulli_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#bernoulli_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    double <B>stored_p</B>;  <I>// exposition only</I>
    };</PRE>

<P>The class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of type <CODE>bool</CODE>, returning <CODE>true</CODE> with a
probability given by the argument to the constructor.</P>

<H3><CODE><A NAME="bernoulli_distribution__bernoulli_distribution"></A>bernoulli_distribution::bernoulli_distribution</CODE></H3>

<PRE><B>explicit bernoulli_distribution</B>(double p0 = 0.5);
explicit <B>bernoulli_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &le; p0 &amp;&amp; p0 &le; 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__input_type"></A>bernoulli_distribution::input_type</CODE></H3>

<PRE>typedef int <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for <CODE>int</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__max"></A>bernoulli_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns <CODE>true</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__min"></A>bernoulli_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns <CODE>false</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__operator()"></A>bernoulli_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integer values and returns <CODE>true</CODE>
with probability given by the stored value <CODE>stored_p</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__p"></A>bernoulli_distribution::p</CODE></H3>

<PRE>double <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__param"></A>bernoulli_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="bernoulli_distribution__param_type"></A>bernoulli_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef bernoulli_distribution distribution_type;

    param_type(double p0 = 0.5);
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="bernoulli_distribution__reset"></A>bernoulli_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="bernoulli_distribution__result_type"></A>bernoulli_distribution::result_type</CODE></H3>

<PRE>typedef bool <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>bool</CODE>.</P>

<H2><CODE><A NAME="binomial_distribution"></A>binomial_distribution</CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++11]</B>
    class <B>binomial_distribution</B> {
public:
    typedef T1 <B><A HREF="#binomial_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef IntType <B><A HREF="#binomial_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#binomial_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#binomial_distribution__binomial_distribution">binomial_distribution</A></B>(result_type t0 = 1,
        RealType p0 = RealType(0.5));
    explicit <B><A HREF="#binomial_distribution__binomial_distribution">binomial_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#binomial_distribution__t">t</A></B>() const;
    RealType <B><A HREF="#binomial_distribution__p">p</A></B>() const;
    param_type <B><A HREF="#binomial_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#binomial_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#binomial_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#binomial_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#binomial_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#binomial_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#binomial_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    result_type <B>stored_t</B>;  <I>// exposition only</I>
    RealType <B>stored_p</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed with a binomial
distribution.</P>

<H3><CODE><A NAME="binomial_distribution__binomial_distribution"></A>binomial_distribution::binomial_distribution</CODE></H3>

<PRE><B>binomial_distribution</B>(result_type t0 = 1,
    RealType p0 = RealType(0.5));
explicit <B>binomial_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt;= t0 &amp;&amp; 0.0 &lt;= p0 &amp;&amp; p0 &lt;= 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE> and whose stored value <CODE>stored_t</CODE> holds
the value <CODE>t0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__input_type"></A>binomial_distribution::input_type</CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__max"></A>binomial_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__min"></A>binomial_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__operator()"></A>binomial_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> occurring with probability:</P>

<P><IMG SRC="binomial_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__p"></A>binomial_distribution::p</CODE></H3>

<PRE>RealType <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__param"></A>binomial_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__param_type"></A>binomial_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(result_type t0 = 1, RealType p0 = RealType(0.5));
    result_type t() const;
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="binomial_distribution__reset"></A>binomial_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="binomial_distribution__result_type"></A>binomial_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="binomial_distribution__t"></A>binomial_distribution::t</CODE></H3>

<PRE>result_type <B>t</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_t</CODE>.</P>

<H2><CODE><A NAME="cauchy_distribution"></A>cauchy_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>cauchy_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#cauchy_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#cauchy_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#cauchy_distribution__cauchy_distribution">cauchy_distribution</A></B>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#cauchy_distribution__cauchy_distribution">cauchy_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#cauchy_distribution__a">a</A></B>() const;
    result_type <B><A HREF="#cauchy_distribution__b">b</A></B>() const;
    param_type <B><A HREF="#cauchy_distribution__param">param</A></B>() const;
    void <B><A HREF="#cauchy_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#cauchy_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#cauchy_distribution__max">max</A></B>() const;
    void <B><A HREF="#cauchy_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#cauchy_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#cauchy_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Cauchy distribution.</P>

<H3><CODE><A NAME="cauchy_distribution__a"></A>cauchy_distribution::a</CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__b"></A>cauchy_distribution::b</CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__cauchy_distribution"></A>cauchy_distribution::cauchy_distribution</CODE></H3>

<PRE><B>cauchy_distribution</B>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <B>cauchy_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__max"></A>cauchy_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__min"></A>cauchy_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__operator()"></A>cauchy_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="cauchy_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__param"></A>cauchy_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="cauchy_distribution__param_type"></A>cauchy_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef cauchy_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="cauchy_distribution__reset"></A>cauchy_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="cauchy_distribution__result_type"></A>cauchy_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="chi_squared_distribution"></A>chi_squared_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>chi_squared_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#chi_squared_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#chi_squared_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#chi_squared_distribution__chi_squared_distribution">chi_squared_distribution</A></B>(RealType n0 = 1);
    explicit <B><A HREF="#chi_squared_distribution__chi_squared_distribution">chi_squared_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#chi_squared_distribution__n">n</A></B>() const;
    param_type <B><A HREF="#chi_squared_distribution__param">param</A></B>() const;
    void <B><A HREF="#chi_squared_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#chi_squared_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#chi_squared_distribution__max">max</A></B>() const;
    void <B><A HREF="#chi_squared_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#chi_squared_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#chi_squared_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a chi-squared distribution.</P>

<H3><CODE><A NAME="chi_squared_distribution__chi_squared_distribution"></A>chi_squared_distribution::chi_squared_distribution</CODE></H3>

<PRE><B>chi_squared_distribution</B>(RealType n0 = 1);
explicit <B>chi_squared_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__max"></A>chi_squared_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__min"></A>chi_squared_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__n"></A>chi_squared_distribution::n</CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__operator()"></A>chi_squared_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="chi_squared_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__param"></A>chi_squared_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="chi_squared_distribution__param_type"></A>chi_squared_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef chi_squared_distribution&lt;RealType&gt; distribution_type;

    param_type(int n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="chi_squared_distribution__reset"></A>chi_squared_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="chi_squared_distribution__result_type"></A>chi_squared_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="default_random_engine"></A>default_random_engine</CODE></H2>

<PRE>typedef Rand <B>default_random_engine</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for <CODE>Rand</CODE>, a predefined
<A HREF="lib_rand.html#engine">engine</A>.</P>

<H2><CODE><A NAME="discard_block"></A>discard_block</CODE></H2>

<PRE>template&lt;class Engine,
    int P, int R&gt;
    class <B>discard_block</B> {
public:
    typedef Engine <B><A HREF="#discard_block__base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#discard_block__result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#discard_block__block_size">block_size</A></B> = P;
    static constexpr int <B><A HREF="#discard_block__used_block">used_block</A></B> = R;

    <B><A HREF="#discard_block__discard_block">discard_block</A></B>();
    explicit <B><A HREF="#discard_block__discard_block">discard_block</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#discard_block__discard_block">discard_block</A></B>(base_type&amp;&amp; eng);
    template&lt;class Gen&gt;
        <B><A HREF="#discard_block__discard_block">discard_block</A></B>(Gen&amp; gen);
    void <B><A HREF="#discard_block__seed">seed</A></B>();
    template&lt;class Gen&gt;
        void <B><A HREF="#discard_block__seed">seed</A></B>(Gen&amp; gen);

    const base_type&amp; <B><A HREF="#discard_block__base">base</A></B>() const;
    result_type <B><A HREF="#discard_block__min">min</A></B>() const;
    result_type <B><A HREF="#discard_block__max">max</A></B>() const;
    result_type <B><A HREF="#discard_block__operator()">operator()</A></B>();

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#compound_engine">compound engine</A>
that produces values by discarding some of the values returned by its base engine. Each
cycle of the compound engine begins by returning <CODE>R</CODE> values successively produced
by the base engine and ends by discarding <CODE>P - R</CODE> such values.
The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>
followed by the number of calls to <CODE>operator()</CODE> that have occurred since the
beginning of the current cycle.</P>

<P>The value of the template argument <CODE>R</CODE> must be
positive and less than or
equal to the value of the template argument <CODE>P</CODE>.</P>

<H3><CODE><A NAME="discard_block__base"></A>discard_block::base</CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="discard_block__base_type"></A>discard_block::base_type</CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="discard_block__block_size"></A>discard_block::block_size</CODE></H3>

<PRE>static constexpr int <B>block_size</B> = P;</PRE>

<P>The static const variable holds the value of the template argument <CODE>P</CODE>, the number
of values in each cycle.</P>

<H3><CODE><A NAME="discard_block__discard_block"></A>discard_block::discard_block</CODE></H3>

<PRE><B>discard_block</B>();
explicit <B>discard_block</B>(const base_type&amp; eng);
explicit <B>discard_block</B>(base_type&amp;&amp; eng);
template&lt;class Gen&gt;
    <B>discard_block</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs a <CODE>discard_block</CODE> object with a default-initialized
engine. The second constructor constructs a <CODE>discard_block</CODE> object with a copy of an
engine object. The third constructor constructs a <CODE>discard_block</CODE> object by moving the
engine object. The fourth constructor constructs a <CODE>discard_block</CODE> object with an engine
initialized from a generator.</P>

<H3><CODE><A NAME="discard_block__max"></A>discard_block::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_eng.max()</CODE>.</P>

<H3><CODE><A NAME="discard_block__min"></A>discard_block::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_eng.min()</CODE>.</P>

<H3><CODE><A NAME="discard_block__operator()"></A>discard_block::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="discard_block__result_type"></A>discard_block::result_type</CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="discard_block__seed"></A>discard_block::seed</CODE></H3>

<PRE>void <B>seed</B>();
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
calls <CODE>stored_eng.seed()</CODE> and sets <CODE>count</CODE> to 0.
The second seed function calls <CODE>stored_eng.seed(gen)</CODE>
and sets <CODE>count</CODE> to 0.</P>

<H3><CODE><A NAME="discard_block__used_block"></A>discard_block::used_block</CODE></H3>

<PRE>static constexpr int <B>used_block</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>, the number
of values to return at the beginning of each cycle.</P>

<H2><CODE><A NAME="discard_block_engine"></A>discard_block_engine</CODE></H2>

<PRE>template&lt;class Engine,
    int P, int R&gt;
    class <B>discard_block_engine</B> { <B>[added with C++11]</B>
public:
    typedef Engine <B><A HREF="#discard_block_engine__base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#discard_block_engine__result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#discard_block_engine__block_size">block_size</A></B> = P;
    static constexpr int <B><A HREF="#discard_block_engine__used_block">used_block</A></B> = R;

    <B><A HREF="#discard_block_engine__discard_block_engine">discard_block_engine</A></B>();
    explicit <B><A HREF="#discard_block_engine__discard_block_engine">discard_block_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#discard_block_engine__discard_block_engine">discard_block_engine</A></B>(base_type&amp;&amp; eng);
    explicit <B><A HREF="#discard_block_engine__discard_block_engine">discard_block_engine</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#discard_block_engine__discard_block_engine">discard_block_engine</A></B>(Seed_seq&amp; seq);
    void <B><A HREF="#discard_block_engine__seed">seed</A></B>();
    void <B><A HREF="#discard_block_engine__seed">seed</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#discard_block_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    const base_type&amp; <B><A HREF="#discard_block_engine__base">base</A></B>() const noexcept;
    static constexpr result_type <B><A HREF="#discard_block_engine__min">min</A></B>();
    static constexpr result_type <B><A HREF="#discard_block_engine__max">max</A></B>();
    result_type <B><A HREF="#discard_block_engine__operator()">operator()</A></B>();
    void <B><A HREF="#discard_block_engine__discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#compound_engine">compound engine</A>
that produces values by discarding some of the values returned by its base engine. Each
cycle of the compound engine begins by returning <CODE>R</CODE> values successively produced
by the base engine and ends by discarding <CODE>P - R</CODE> such values.
The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>
followed by the number of calls to <CODE>operator()</CODE> that have occurred since the
beginning of the current cycle.</P>

<P>The value of the template argument <CODE>R</CODE> must be
positive and less than or
equal to the value of the template argument <CODE>P</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine__base"></A>discard_block_engine::base</CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const noexcept;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="discard_block_engine__base_type"></A>discard_block_engine::base_type</CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="discard_block_engine__block_size"></A>discard_block_engine::block_size</CODE></H3>

<PRE>static constexpr int <B>block_size</B> = P;</PRE>

<P>The static const variable holds the value of the template argument <CODE>P</CODE>, the number
of values in each cycle.</P>

<H3><CODE><A NAME="discard_block_engine__discard"></A>discard_block_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="discard_block_engine__discard_block_engine"></A>discard_block_engine::discard_block_engine</CODE></H3>

<PRE><B>discard_block_engine</B>();
explicit <B>discard_block_engine</B>(const base_type&amp; eng);
explicit <B>discard_block_engine</B>(base_type&amp;&amp; eng);
explicit <B>discard_block_engine</B>(result_type x0);
template&lt;class Seed_seq&gt;
    explicit <B>discard_block_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>discard_block_engine</CODE>
object with a default-initialized engine.
The second constructor constructs a <CODE>discard_block_engine</CODE>
object with a copy of an engine object.
The third constructor constructs a <CODE>discard_block_engine</CODE>
object by moving the engine object.
The fourth constructor constructs a <CODE>discard_block_engine</CODE>
object with its engine initialized by <CODE>stored_engine(x0)</CODE>.</P>

<P>The fifth constructor constructs a <CODE>discard_block_engine</CODE>
object with its engine initialized by <CODE>stored_engine(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the fifth constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="discard_block_engine__max"></A>discard_block_engine::max</CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine__min"></A>discard_block_engine::min</CODE></H3>

<PRE>static result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine__operator()"></A>discard_block_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="discard_block_engine__result_type"></A>discard_block_engine::result_type</CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="discard_block_engine__seed"></A>discard_block_engine::seed</CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
template&lt;class Seed_seq&gt;
    void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
calls <CODE>stored_eng.seed()</CODE> and sets <CODE>count</CODE> to 0.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>
and sets <CODE>count</CODE> to 0.
The third seed function calls <CODE>stored_eng.seed(seq)</CODE>
and sets <CODE>count</CODE> to 0.</P>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the third function does not participate in overload resolution.</P>

<H3><CODE><A NAME="discard_block_engine__used_block"></A>discard_block_engine::used_block</CODE></H3>

<PRE>static constexpr int <B>used_block</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>, the number
of values to return at the beginning of each cycle.</P>

<H2><CODE><A NAME="discrete_distribution"></A>discrete_distribution</CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>discrete_distribution</B> { <B>[added with C++11]</B>
public:
    typedef IntType <B><A HREF="#discrete_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#discrete_distribution__param_type">param_type</A></B>;

    <B><A HREF="#discrete_distribution__discrete_distribution">discrete_distribution</A></B>();
    <B><A HREF="#discrete_distribution__discrete_distribution">discrete_distribution</A></B>(initializer_list&lt;double&gt; init);
    template&lt;class Fn&gt;
        <B><A HREF="#discrete_distribution__discrete_distribution">discrete_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#discrete_distribution__discrete_distribution">discrete_distribution</A></B>(const param_type&amp; par0);

    vector&lt;double&gt; <B><A HREF="#discrete_distribution__probabilities">probabilities</A></B>() const;
    param_type <B><A HREF="#discrete_distribution__param">param</A></B>() const;
    void <B><A HREF="#discrete_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#discrete_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#discrete_distribution__max">max</A></B>() const;
    void <B><A HREF="#discrete_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#discrete_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#discrete_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    vector&lt;double&gt; <B>stored_p</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed according to
a uniform-width histogram of probabilities.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE>discrete_distribution</CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="discrete_distribution__discrete_distribution"></A>discrete_distribution::discrete_distribution</CODE></H3>

<PRE><B>discrete_distribution</B>();
<B>discrete_distribution</B>(initializer_list&lt;double&gt; init);
template&lt;class Fn&gt;
    <B>discrete_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>discrete_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements in <CODE>init</CODE>
are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
has one element with value 1.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>,
then normalized so that the sum of all elements is 1.
If the sequence is empty, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> uniform subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fourth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__max"></A>discrete_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__min"></A>discrete_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__operator()"></A>discrete_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> in the range <CODE>[0, stored_p.size() - 1)</CODE>
occurring with probability <CODE>stored_p[i]</CODE> and all other values of <CODE>i</CODE>
occurring with probability zero.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__param"></A>discrete_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__param_type"></A>discrete_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef discrete_distribution&lt;IntType&gt; distribution_type;

    param_type();
    param_type(initializer_list&lt;double&gt; init);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);
    vector&lt;double&gt; probabilities() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="discrete_distribution__probabilities"></A>discrete_distribution::probabilities</CODE></H3>

<PRE>vector&lt;double&gt; <B>probabilities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="discrete_distribution__reset"></A>discrete_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="discrete_distribution__result_type"></A>discrete_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="exponential_distribution"></A>exponential_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>exponential_distribution</B> {
public:
    typedef RealType <B><A HREF="#exponential_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef RealType <B><A HREF="#exponential_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#exponential_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#exponential_distribution__exponential_distribution">exponential_distribution</A></B>(result_type lambda0 = result_type(1.0));
    explicit <B><A HREF="#exponential_distribution__exponential_distribution">exponential_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#exponential_distribution__lambda">lambda</A></B>() const;
    param_type <B><A HREF="#exponential_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#exponential_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#exponential_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#exponential_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#exponential_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#exponential_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#exponential_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    result_type <B>stored_lambda</B>;   <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with an exponential
distribution.</P>

<H3><CODE><A NAME="exponential_distribution__exponential_distribution"></A>exponential_distribution::exponential_distribution</CODE></H3>

<PRE><B>exponential_distribution</B>(result_type lambda0 = result_type(1.0));
explicit <B>exponential_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; lambda0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_lambda</CODE>
holds the value <CODE>lambda0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__input_type"></A>exponential_distribution::input_type</CODE></H3>

<PRE>typedef RealType <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__lambda"></A>exponential_distribution::lambda</CODE></H3>

<PRE>result_type <B>lambda</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_lambda</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__max"></A>exponential_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__min"></A>exponential_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__operator()"></A>exponential_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="exponential_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__param"></A>exponential_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="exponential_distribution__param_type"></A>exponential_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef exponential_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type lambda0 = result_type(1.0));
    result_type lambda() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="exponential_distribution__reset"></A>exponential_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="exponential_distribution__result_type"></A>exponential_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="extreme_value_distribution"></A>extreme_value_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>extreme_value_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#extreme_value_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#extreme_value_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#extreme_value_distribution__extreme_value_distribution">extreme_value_distribution</A></B>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#extreme_value_distribution__extreme_value_distribution">extreme_value_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#extreme_value_distribution__a">a</A></B>() const;
    result_type <B><A HREF="#extreme_value_distribution__b">b</A></B>() const;
    param_type <B><A HREF="#extreme_value_distribution__param">param</A></B>() const;
    void <B><A HREF="#extreme_value_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#extreme_value_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#extreme_value_distribution__max">max</A></B>() const;
    void <B><A HREF="#extreme_value_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#extreme_value_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#extreme_value_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with an extreme-value (a.k.a. Gumbel Type I, log Weibull,
or Fisher-Tippett Type I) distribution.</P>

<H3><CODE><A NAME="extreme_value_distribution__a"></A>extreme_value_distribution::a</CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__b"></A>extreme_value_distribution::b</CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__extreme_value_distribution"></A>extreme_value_distribution::extreme_value_distribution</CODE></H3>

<PRE><B>extreme_value_distribution</B>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <B>extreme_value_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__max"></A>extreme_value_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__min"></A>extreme_value_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__operator()"></A>extreme_value_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="extreme_value_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__param"></A>extreme_value_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="extreme_value_distribution__param_type"></A>extreme_value_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef extreme_value_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="extreme_value_distribution__reset"></A>extreme_value_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="extreme_value_distribution__result_type"></A>extreme_value_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="fisher_f_distribution"></A>fisher_f_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>fisher_f_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#fisher_f_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#fisher_f_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#fisher_f_distribution__fisher_f_distribution">fisher_f_distribution</A></B>(RealType m0 = 1,
        RealType n0 = 1);
    explicit <B><A HREF="#fisher_f_distribution__fisher_f_distribution">fisher_f_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#fisher_f_distribution__m">m</A></B>() const;
    RealType <B><A HREF="#fisher_f_distribution__n">n</A></B>() const;
    param_type <B><A HREF="#fisher_f_distribution__param">param</A></B>() const;
    void <B><A HREF="#fisher_f_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#fisher_f_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#fisher_f_distribution__max">max</A></B>() const;
    void <B><A HREF="#fisher_f_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#fisher_f_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#fisher_f_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_m</B>;  <I>// exposition only</I>
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Fisher F distribution.</P>

<H3><CODE><A NAME="fisher_f_distribution__fisher_f_distribution"></A>fisher_f_distribution::fisher_f_distribution</CODE></H3>

<PRE><B>fisher_f_distribution</B>(RealType m0 = 1,
    RealType n0 = 1);
explicit <B>fisher_f_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; m0
&amp;&amp; 0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_m</CODE>
holds the value <CODE>m0</CODE> and whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__m"></A>fisher_f_distribution::m</CODE></H3>

<PRE>RealType <B>m</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_m</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__max"></A>fisher_f_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__min"></A>fisher_f_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__n"></A>fisher_f_distribution::n</CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__operator()"></A>fisher_f_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="fisher_f_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__param"></A>fisher_f_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="fisher_f_distribution__param_type"></A>fisher_f_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef fisher_f_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType m0 = 1, RealType n0 = 1);
    RealType m() const;
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="fisher_f_distribution__reset"></A>fisher_f_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="fisher_f_distribution__result_type"></A>fisher_f_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="gamma_distribution"></A>gamma_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>gamma_distribution</B> {
public:
    typedef T1 <B><A HREF="#gamma_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef RealType <B><A HREF="#gamma_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#gamma_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#gamma_distribution__gamma_distribution">gamma_distribution</A></B>(result_type alpha0 = result_type(1.0),
        result_type beta0 = result_type(1.0)); <B>[beta added with C++11]</B>
    explicit <B><A HREF="#gamma_distribution__gamma_distribution">gamma_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#gamma_distribution__alpha">alpha</A></B>() const;
    result_type <B><A HREF="#gamma_distribution__beta">beta</A></B>() const; <B>[added with C++11]</B>
    param_type <B><A HREF="#gamma_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#gamma_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#gamma_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#gamma_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#gamma_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#gamma_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#gamma_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    result_type <B>stored_alpha</B>;    <I>// exposition only</I>
    result_type <B>stored_beta</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a gamma distribution.</P>

<H3><CODE><A NAME="gamma_distribution__alpha"></A>gamma_distribution::alpha</CODE></H3>

<PRE>result_type <B>alpha</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_alpha</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__beta"></A>gamma_distribution::beta</CODE></H3>

<PRE>result_type <B>beta</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the stored value <CODE>stored_beta</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__gamma_distribution"></A>gamma_distribution::gamma_distribution</CODE></H3>

<PRE><B>gamma_distribution</B>(result_type alpha0 = result_type(1.0));
    result_type beta0 = result_type(1.0)); <B>[beta added with C++11]</B>
explicit <B>gamma_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; alpha0
&amp;&amp;0.0 &lt; beta0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_alpha</CODE>
holds the value <CODE>alpha0</CODE> and whose stored value <CODE>stored_beta</CODE>
holds the value <CODE>beta0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__input_type"></A>gamma_distribution::input_type</CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__max"></A>gamma_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__min"></A>gamma_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__operator()"></A>gamma_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="gamma_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__param"></A>gamma_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="gamma_distribution__param_type"></A>gamma_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef gamma_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type alpha0 = result_type(1.0),
        RealType beta0 result_type(1.0));
    RealType alpha() const;
    RealType beta() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="gamma_distribution__reset"></A>gamma_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="gamma_distribution__result_type"></A>gamma_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H2><CODE><A NAME="generate_canonical"></A>generate_canonical</CODE></H2>

<PRE>template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <B>generate_canonical</B>(Engine&amp; gen); <B>[added with C++11]</B></PRE>

<P>The template function calls <CODE>gen()</CODE> repeatedly and packs the returned
values into a floating-point value <CODE>x</CODE> of type <CODE>RealType</CODE> until it has
gathered the specified number of mantissa bits in <CODE>x</CODE>.
The specified number is the smaller of <CODE>bits</CODE> (which must be nonzero)
and the full number of mantissa bits in <CODE>RealType</CODE>. The first
call supplies the lowest-order bits. The function returns <CODE>x</CODE>.</P>

<H2><CODE><A NAME="geometric_distribution"></A>geometric_distribution</CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++11]</B>
    class <B>geometric_distribution</B> {
public:
    typedef T1 <B><A HREF="#geometric_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef IntType <B><A HREF="#geometric_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#geometric_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#geometric_distribution__geometric_distribution">geometric_distribution</A></B>(RealType p0 = RealType(0.5));
    explicit <B><A HREF="#geometric_distribution__geometric_distribution">geometric_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    RealType <B><A HREF="#geometric_distribution__p">p</A></B>() const;
    param_type <B><A HREF="#geometric_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#geometric_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#geometric_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#geometric_distribution__max">max</A></B>() const;
    void <B><A HREF="#geometric_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#geometric_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#geometric_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    RealType <B>stored_p</B>;          <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a geometric distribution.</P>

<H3><CODE><A NAME="geometric_distribution__geometric_distribution"></A>geometric_distribution::geometric_distribution</CODE></H3>

<PRE><B>geometric_distribution</B>(RealType p0 = RealType(0.5));
explicit <B>geometric_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; p0 &amp;&amp; p0 &lt; 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE> holds
the value <CODE>p0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__input_type"></A>geometric_distribution::input_type</CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__max"></A>geometric_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__min"></A>geometric_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__operator()"></A>geometric_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> occurring with probability:</P>

<P><IMG SRC="geometric_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__p"></A>geometric_distribution::p</CODE></H3>

<PRE>RealType <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__param"></A>geometric_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="geometric_distribution__param_type"></A>geometric_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType p0 = RealType(0.5));
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="geometric_distribution__reset"></A>geometric_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="geometric_distribution__result_type"></A>geometric_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="independent_bits_engine"></A>independent_bits_engine</CODE></H2>

<PRE>template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <B>independent_bits_engine</B> { <B>[added with C++11]</B>
public:
    typedef Engine <B><A HREF="#independent_bits_engine__base_type">base_type</A></B>;
    typedef UIntType <B><A HREF="#independent_bits_engine__result_type">result_type</A></B>;

    <B><A HREF="#independent_bits_engine__independent_bits_engine">independent_bits_engine</A></B>();
    explicit <B><A HREF="#independent_bits_engine__independent_bits_engine">independent_bits_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#independent_bits_engine__independent_bits_engine">independent_bits_engine</A></B>(base_type&amp;&amp; eng);
    explicit <B><A HREF="#independent_bits_engine__independent_bits_engine">independent_bits_engine</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#independent_bits_engine__independent_bits_engine">independent_bits_engine</A></B>(Seed_seq&amp; seq);
    void <B><A HREF="#independent_bits_engine__seed">seed</A></B>();
    void <B><A HREF="#independent_bits_engine__seed">seed</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#independent_bits_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    const base_type&amp; <B><A HREF="#independent_bits_engine__base">base</A></B>() const noexcept;
    static constexpr result_type <B><A HREF="#independent_bits_engine__min">min</A></B>();
    static constexpr result_type <B><A HREF="#independent_bits_engine__max">max</A></B>();
    result_type <B><A HREF="#independent_bits_engine__operator()">operator()</A></B>();
    void <B><A HREF="#independent_bits_engine__discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;       <I>// exposition only</I>
    int <B>count</B>;               <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#compound_engine">compound engine</A>
that produces values by repacking bits as needed from the values
returned by its base engine. Each resulting <CODE>W</CODE>-bit value
consists of <CODE>N</CODE> fields combined as follows:</P>

<UL>
<LI>The first <CODE>N0</CODE> fields consist of the low-order
<CODE>W0</CODE> bits of values returned by the base engine that are
less than <CODE>Y0</CODE>, packed in descending order of significance.
Values that are too large are discarded.</LI>

<LI>The remaining <CODE>N - N0</CODE> fields consist of the low-order
<CODE>W0 + 1</CODE> bits of values returned by the base engine that are
less than <CODE>Y1</CODE>, packed in descending order of significance.
Values that are too large are discarded.</LI>
</UL>

<P>The parameters above (other than <CODE>W</CODE>) are determined
as follows:</P>

<UL>
<LI><CODE>R</CODE> is the full range of values returned by the
base engine (<CODE>stored_eng.max() - stored_eng.min() + 1</CODE>,
assuming no wraparound occurs.)</LI>

<LI><CODE>M</CODE> is <CODE>floor(log2(R))</CODE>.</LI>

<LI><CODE>N</CODE> is initially <CODE>W / M + (W % M != 0)</CODE>.</LI>

<LI><CODE>W0</CODE> is <CODE>W / N</CODE>.</LI>

<LI><CODE>N0</CODE> is <CODE>N - W % N</CODE>.</LI>

<LI><CODE>Y0</CODE> is <CODE>(R &gt;&gt; W0) &lt;&lt; W0</CODE>.</LI>

<LI><CODE>Y1</CODE> is <CODE>(R &gt;&gt; W0 + 1) &lt;&lt; W0 + 1</CODE>.</LI>

<LI>If <CODE>Y0 / N &lt; R - Y0</CODE> then <CODE>N</CODE> is incremented
and the previous four parameters are redetermined.</LI>
</UL>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is
the state of <CODE>stored_eng</CODE>.
The value of the template argument <CODE>W</CODE> must be greater than zero
and not greater than the number of bits representable in <CODE>result_type</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine__base"></A>independent_bits_engine::base</CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const noexcept;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="independent_bits_engine__base_type"></A>independent_bits_engine::base_type</CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="independent_bits_engine__discard"></A>independent_bits_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="independent_bits_engine__independent_bits_engine"></A>independent_bits_engine::independent_bits_engine</CODE></H3>

<PRE><B>independent_bits_engine</B>();
explicit <B>independent_bits_engine</B>(const base_type&amp; eng);
explicit <B>independent_bits_engine</B>(base_type&amp;&amp; eng);
explicit <B>independent_bits_engine</B>(result_type x0);
template&lt;class Seed_seq&gt;
    explicit <B>independent_bits_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>independent_bits_engine</CODE> object with a default-initialized
engine. The second constructor constructs a <CODE>independent_bits_engine</CODE> object with a copy of an
engine object. The third constructor constructs a <CODE>independent_bits_engine</CODE> object by moving an
engine object. The fourth constructor constructs a <CODE>independent_bits_engine</CODE> object with its engine
initialized by <CODE>stored_engine(x0)</CODE>.</P>

<P>The fifth constructor constructs a
<CODE>independent_bits_engine</CODE> object with its engine initialized by
<CODE>stored_engine(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the fifth constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="independent_bits_engine__max"></A>independent_bits_engine::max</CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine__min"></A>independent_bits_engine::min</CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine__operator()"></A>independent_bits_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="independent_bits_engine__result_type"></A>independent_bits_engine::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="independent_bits_engine__seed"></A>independent_bits_engine::seed</CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
template&lt;class Seed_seq&gt;
    void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
calls <CODE>stored_eng.seed()</CODE>.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>.
The second seed function calls <CODE>stored_eng.seed(seq)</CODE>.</P>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the third function does not participate in overload resolution.</P>

<H2><CODE><A NAME="knuth_b"></A>knuth_b</CODE></H2>

<PRE>typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <B>knuth_b</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>shuffle_order_engine</CODE>
with a specialization of the template <CODE>linear_congruential</CODE>.</P>

<H2><CODE><A NAME="linear_congruential"></A>linear_congruential</CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B>linear_congruential</B> {
public:
    typedef UIntType <B><A HREF="#linear_congruential__result_type">result_type</A></B>;
    static constexpr UIntType <B><A HREF="#linear_congruential__multiplier">multiplier</A></B> = A;
    static constexpr UIntType <B><A HREF="#linear_congruential__increment">increment</A></B> = C;
    static constexpr UIntType <B><A HREF="#linear_congruential__modulus">modulus</A></B> = M;

    <B><A HREF="#linear_congruential__linear_congruential">linear_congruential</A></B>();
    explicit <B><A HREF="#linear_congruential__linear_congruential">linear_congruential</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#linear_congruential__linear_congruential">linear_congruential</A></B>(Gen&amp; gen);
    void <B><A HREF="#linear_congruential__seed">seed</A></B>(unsigned long x0 = 1);
    template&lt;class Gen&gt;
        void <B><A HREF="#linear_congruential__seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#linear_congruential__min">min</A></B>() const;
    result_type <B><A HREF="#linear_congruential__max">max</A></B>() const;
    result_type <B><A HREF="#linear_congruential__operator()">operator()</A></B>();

private:
    result_type <B>stored_value</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="linear_congruential__recurrence_relation"></A>recurrence relation</B>&nbsp;
<CODE>x(i) = (A * x(i-1) + C) mod M</CODE>. The engine's
<A HREF="lib_rand.html#state">state</A> is the last value returned, or the seed
value if no call has been made to <CODE>operator()</CODE>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>A</CODE> and <CODE>C</CODE> must be less than <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__increment"></A>linear_congruential::increment</CODE></H3>

<PRE>static constexpr UIntType <B>increment</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__linear_congruential"></A>linear_congruential::linear_congruential</CODE></H3>

<PRE><B>linear_congruential</B>();
explicit <B>linear_congruential</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>linear_congruential</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__max"></A>linear_congruential::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__min"></A>linear_congruential::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>C == 0 ? 1 : 0</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__modulus"></A>linear_congruential::modulus</CODE></H3>

<PRE>static constexpr UIntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__multiplier"></A>linear_congruential::multiplier</CODE></H3>

<PRE>static constexpr UIntType <B>multiplier</B> = A;</PRE>

<P>The static const variable holds the value of template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__operator()"></A>linear_congruential::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates a new <CODE>stored_value</CODE> by applying
the <A HREF="#linear_congruential__recurrence_relation">recurrence relation</A> to the old value of
<CODE>stored_value</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__result_type"></A>linear_congruential::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="linear_congruential__seed"></A>linear_congruential::seed</CODE></H3>

<PRE>void <B>seed</B>(unsigned long x0 = 1);
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A> sets the stored value
<CODE>stored_value</CODE> to 1 if <CODE>C mod M == 0</CODE> and
<CODE>x0 mod M == 0</CODE>, otherwise it sets the stored value to <CODE>x0 mod M</CODE>.
The second seed function calls <CODE>seed(gen())</CODE>.</P>

<H2><CODE><A NAME="linear_congruential_engine"></A>linear_congruential_engine</CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <B>linear_congruential_engine</B> { <B>[added with C++11]</B>
public:
    typedef UIntType <B><A HREF="#linear_congruential_engine__result_type">result_type</A></B>;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine__multiplier">multiplier</A></B> = A;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine__increment">increment</A></B> = C;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine__modulus">modulus</A></B> = M;
    static constexpr UIntType <B><A HREF="#linear_congruential_engine__default_seed">default_seed</A></B> = 1U;

    explicit <B><A HREF="#linear_congruential_engine__linear_congruential_engine">linear_congruential_engine</A></B>(result_type x0 = default_seed);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#linear_congruential_engine__linear_congruential_engine">linear_congruential_engine</A></B>(Seed_seq&amp; seq);
    void <B><A HREF="#linear_congruential_engine__seed">seed</A></B>(result_type x0 = default_seed);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#linear_congruential_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    static constexpr result_type <B><A HREF="#linear_congruential_engine__min">min</A></B>();
    static constexpr result_type <B><A HREF="#linear_congruential_engine__max">max</A></B>();
    result_type <B><A HREF="#linear_congruential_engine__operator()">operator()</A></B>();
    void <B><A HREF="#linear_congruential_engine__discard">discard</A></B>(unsigned long long count)();

private:
    result_type <B>stored_value</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="linear_congruential_engine__recurrence_relation"></A>recurrence relation</B>&nbsp;
<CODE>x(i) = (A * x(i-1) + C) mod M</CODE>. The engine's
<A HREF="lib_rand.html#state">state</A> is the last value returned, or the seed
value if no call has been made to <CODE>operator()</CODE>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>A</CODE> and <CODE>C</CODE> must be less than <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__default_seed"></A>linear_congruential_engine::default_seed</CODE></H3>

<PRE>static constexpr UIntType <B>default_seed</B> = 1U;</PRE>

<P>The static const variable holds the default seed value <CODE>1U</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__discard"></A>linear_congruential_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="linear_congruential_engine__increment"></A>linear_congruential_engine::increment</CODE></H3>

<PRE>static constexpr UIntType <B>increment</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__linear_congruential_engine"></A>linear_congruential_engine::linear_congruential_engine</CODE></H3>

<PRE>explicit <B>linear_congruential_engine</B>(result_type x0 = default_seed);
template&lt;class Seed_seq&gt;
    explicit <B>linear_congruential_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="linear_congruential_engine__max"></A>linear_congruential_engine::max</CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__min"></A>linear_congruential_engine::min</CODE></H3>

<PRE>static constexpr result_type <B>min</B>() const;</PRE>

<P>The static member function returns <CODE>C == 0 ? 1 : 0</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__modulus"></A>linear_congruential_engine::modulus</CODE></H3>

<PRE>static constexpr UIntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__multiplier"></A>linear_congruential_engine::multiplier</CODE></H3>

<PRE>static constexpr UIntType <B>multiplier</B> = A;</PRE>

<P>The static const variable holds the value of template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__operator()"></A>linear_congruential_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates a new <CODE>stored_value</CODE> by applying
the <A HREF="#linear_congruential_engine__recurrence_relation">recurrence relation</A> to the old value of
<CODE>stored_value</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__result_type"></A>linear_congruential_engine::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="linear_congruential_engine__seed"></A>linear_congruential_engine::seed</CODE></H3>

<PRE>void <B>seed</B>(result_type x0 = default_seed);
template&lt;class Seed_seq&gt;
    void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A> sets the stored value
<CODE>stored_value</CODE> to 1 if <CODE>C mod M == 0</CODE> and
<CODE>x0 mod M == 0</CODE>, otherwise it sets the stored value to <CODE>x0 mod M</CODE>.
The second seed function calls <CODE>seed(x)</CODE>,
where <CODE>x</CODE> is determined as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>3 + k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[3 + k])</CODE>.</LI>

<LI><CODE>x</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[3]</CODE>, which supplies the lowest-order bits.</LI>
</UL>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second function does not participate in overload resolution.</P>

<H2><CODE><A NAME="lognormal_distribution"></A>lognormal_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>lognormal_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#lognormal_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#lognormal_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#lognormal_distribution__lognormal_distribution">lognormal_distribution</A></B>(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    explicit <B><A HREF="#lognormal_distribution__lognormal_distribution">lognormal_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#lognormal_distribution__m">m</A></B>() const;
    result_type <B><A HREF="#lognormal_distribution__s">s</A></B>() const;
    param_type <B><A HREF="#lognormal_distribution__param">param</A></B>() const;
    void <B><A HREF="#lognormal_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#lognormal_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#lognormal_distribution__max">max</A></B>() const;
    void <B><A HREF="#lognormal_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#lognormal_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#lognormal_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a log normal distribution.</P>

<H3><CODE><A NAME="lognormal_distribution__lognormal_distribution"></A>lognormal_distribution::lognormal_distribution</CODE></H3>

<PRE><B>lognormal_distribution</B>(result_type m0 = result_type(0.0),
    result_type s0 = result_type(1.0));
explicit <B>lognormal_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; s0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_m</CODE>
holds the value <CODE>m0</CODE> and whose stored value <CODE>stored_s</CODE> holds
the value <CODE>s0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__m"></A>lognormal_distribution::m</CODE></H3>

<PRE>result_type <B>m</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_m</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__max"></A>lognormal_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__min"></A>lognormal_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__operator()"></A>lognormal_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="lognormal_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__param"></A>lognormal_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__param_type"></A>lognormal_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef lognormal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    result_type m() const;
    result_type s() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="lognormal_distribution__reset"></A>lognormal_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="lognormal_distribution__result_type"></A>lognormal_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="lognormal_distribution__s"></A>lognormal_distribution::s</CODE></H3>

<PRE>result_type <B>s</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_s</CODE>.</P>

<H2><CODE><A NAME="mersenne_twister"></A>mersenne_twister</CODE></H2>

<PRE>template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <B>mersenne_twister</B> {
public:
    typedef UIntType <B><A HREF="#mersenne_twister__result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#mersenne_twister__word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#mersenne_twister__state_size">state_size</A></B> = N;
    static constexpr int <B><A HREF="#mersenne_twister__shift_size">shift_size</A></B> = M;
    static constexpr int <B><A HREF="#mersenne_twister__mask_bits">mask_bits</A></B> = R;
    static constexpr UIntType <B><A HREF="#mersenne_twister__parameter_a">parameter_a</A></B> = A;
    static constexpr int <B><A HREF="#mersenne_twister__output_u">output_u</A></B> = U;
    static constexpr int <B><A HREF="#mersenne_twister__output_s">output_s</A></B> = S;
    static constexpr UIntType <B><A HREF="#mersenne_twister__output_b">output_b</A></B> = B;
    static constexpr int <B><A HREF="#mersenne_twister__output_t">output_t</A></B> = T;
    static constexpr UIntType <B><A HREF="#mersenne_twister__output_c">output_c</A></B> = C;
    static constexpr int <B><A HREF="#mersenne_twister__output_l">output_l</A></B> = L;

    <B><A HREF="#mersenne_twister__mersenne_twister">mersenne_twister</A></B>();
    explicit <B><A HREF="#mersenne_twister__mersenne_twister">mersenne_twister</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#mersenne_twister__mersenne_twister">mersenne_twister</A></B>(Gen&amp; gen);
    void <B><A HREF="#mersenne_twister__seed">seed</A></B>();
    void <B><A HREF="#mersenne_twister__seed">seed</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        void <B><A HREF="#mersenne_twister__seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#mersenne_twister__min">min</A></B>() const;
    result_type <B><A HREF="#mersenne_twister__max">max</A></B>() const;
    result_type <B><A HREF="#mersenne_twister__operator()">operator()</A></B>();
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>.
It holds a large integral value with <CODE>W * (N - 1) + R</CODE> bits.
It extracts <CODE>W</CODE> bits at a time from this large value, and when it
has used all the bits it twists the large value by shifting and mixing the bits so that it has
a new set of bits to extract from. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>N</CODE> <CODE>W</CODE>-bit values used if <CODE>operator()</CODE>
has been called at least <CODE>N</CODE> times, otherwise the <CODE>M</CODE>
<CODE>W</CODE>-bit values that have been used and
the last <CODE>N - M</CODE> values of the
<A HREF="lib_rand.html#seed_function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>2<SUP>W</SUP> - 1</CODE>. The values of the
other template arguments must satisfy the following requirements:</P>

<UL>
<LI><CODE>1 &lt; M &lt;= N</CODE></LI>
<LI><CODE>0 &lt;= R, U, S, T, L &lt;= W</CODE></LI>
<LI><CODE>0 &lt;= A, B, C &lt;= 2<SUP>W</SUP> - 1</CODE></LI>
<LI><CODE>W * (N - 1) + R</CODE> must be a Mersenne prime</LI>
</UL>

<P>The generator <B><A NAME="mersenne_twister__twists"></A>twists</B> the large value that it
holds by executing the following code:</P>

<PRE>    for (int i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] &amp; LMASK) &lt;&lt; (W - 1) | (x[i + 1] &amp; HMASK) &gt;&gt; 1;
        if (temp &amp; 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (int i = 0; i &lt; N; ++i)
            x[i] = y[i];</PRE>

<P>where <CODE>LMASK</CODE> is an unsigned <CODE>W</CODE>-bit value with its
low <CODE>R</CODE> bits set to 1 and the rest of its bits set to 0,
and <CODE>HMASK</CODE> is the complement of <CODE>LMASK</CODE>.</P>

<P>The generator holds a current index <CODE>idx</CODE> initialized to 0.
It <SPAN><A NAME="mersenne_twister__extracts"></A>extracts</SPAN> bits
by executing the following code:</P>

<PRE>    temp = x[idx++];
    temp = temp ^ (temp &gt;&gt; U);
    temp = temp ^ ((temp &lt;&lt; S) &amp; B);
    temp = temp ^ ((temp &lt;&lt; T) &amp; C);
    temp = temp ^ (temp &gt;&gt; L);</PRE>

<P>When <CODE>idx</CODE> reaches <CODE>N</CODE> the generator
<A HREF="#mersenne_twister__twists">twists</A> the stored value
and sets <CODE>idx</CODE> back to 0.</P>

<H3><CODE><A NAME="mersenne_twister__mask_bits"></A>mersenne_twister::mask_bits</CODE></H3>

<PRE>static constexpr int <B>mask_bits</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__max"></A>mersenne_twister::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="mersenne_twister__mersenne_twister"></A>mersenne_twister::mersenne_twister</CODE></H3>

<PRE><B>mersenne_twister</B>();
explicit <B>mersenne_twister</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>mersenne_twister</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__min"></A>mersenne_twister::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="mersenne_twister__operator()"></A>mersenne_twister::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function <A HREF="#mersenne_twister__extracts">extracts</A> the
next value in the sequence and returns it.</P>

<H3><CODE><A NAME="mersenne_twister__output_b"></A>mersenne_twister::output_b</CODE></H3>

<PRE>static constexpr UIntType <B>output_b</B> = B;</PRE>

<P>The static const variable holds the value of the template argument <CODE>B</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__output_c"></A>mersenne_twister::output_c</CODE></H3>

<PRE>static constexpr UIntType <B>output_c</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__output_l"></A>mersenne_twister::output_l</CODE></H3>

<PRE>static constexpr int <B>output_l</B> = L;</PRE>

<P>The static const variable holds the value of the template argument <CODE>L</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__output_s"></A>mersenne_twister::output_s</CODE></H3>

<PRE>static constexpr int <B>output_s</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__output_t"></A>mersenne_twister::output_t</CODE></H3>

<PRE>static constexpr int <B>output_t</B> = T;</PRE>

<P>The static const variable holds the value of the template argument <CODE>T</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__output_u"></A>mersenne_twister::output_u</CODE></H3>

<PRE>static constexpr int <B>output_u</B> = U;</PRE>

<P>The static const variable holds the value of the template argument <CODE>U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__parameter_a"></A>mersenne_twister::parameter_a</CODE></H3>

<PRE>static constexpr UIntType <B>parameter_a</B> = A;</PRE>

<P>The static const variable holds the value of the template argument <CODE>A</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__result_type"></A>mersenne_twister::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__seed"></A>mersenne_twister::seed</CODE></H3>

<PRE>template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);
void <B>seed</B>();
void <B>seed</B>(unsigned long x0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
generates <CODE>N</CODE> values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE> and then <A HREF="#mersenne_twister__twists">twists</A>
the resulting large integer value. Each value is <CODE>gen() % 2<SUP>W</SUP></CODE>.</P>

<P>The second seed function calls <CODE>seed(4357)</CODE>.</P>

<P>The third seed function sets the oldest historical value <CODE>h[0]</CODE> to
<CODE>x0 mod 2<SUP>W</SUP></CODE>, then iteratively sets each successive historical value
<CODE>h[i]</CODE> to <CODE>(i + 1812433253 * (h[i - 1] &gt;&gt; (W - 2))) mod 2<SUP>W</SUP></CODE>,
for <CODE>i</CODE> ranging from <CODE>1</CODE> to <CODE>N - 1</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__shift_size"></A>mersenne_twister::shift_size</CODE></H3>

<PRE>static constexpr int <B>shift_size</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__state_size"></A>mersenne_twister::state_size</CODE></H3>

<PRE>static constexpr int <B>state_size</B> = N;</PRE>

<P>The static const variable holds the value of the template argument <CODE>N</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister__word_size"></A>mersenne_twister::word_size</CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="mersenne_twister_engine"></A>mersenne_twister_engine</CODE></H2>

<PRE>template&lt;class UIntType,
    size_t W, size_t N, size_t M, size_t R,
    UIntType A, size_t U,
    UIntType D, size_t S,
    UIntType B, size_t T,
    UIntType C, size_t L
    UIntType F&gt;
    class <B>mersenne_twister_engine</B> { <B>[added with C++11]</B>
public:
    typedef UIntType <B><A HREF="#mersenne_twister_engine__result_type">result_type</A></B>;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__word_size">word_size</A></B> = W;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__state_size">state_size</A></B> = N;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__shift_size">shift_size</A></B> = M;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__mask_bits">mask_bits</A></B> = R;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine__xor_mask">xor_mask</A></B> = A;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__tempering_u">tempering_u</A></B> = U;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__tempering_d">tempering_d</A></B> = D;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__tempering_s">tempering_s</A></B> = S;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine__tempering_b">tempering_b</A></B> = B;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__tempering_t">tempering_t</A></B> = T;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine__tempering_c">tempering_c</A></B> = C;
    static constexpr size_t <B><A HREF="#mersenne_twister_engine__tempering_l">tempering_l</A></B> = L;
    static constexpr UIntType <B><A HREF="#mersenne_twister_engine__initialization_multiplier">initialization_multiplier</A></B> = C;
    static constexpr result_type <B><A HREF="#mersenne_twister_engine__default_seed">default_seed</A></B> = 5489U;

    explicit <B><A HREF="#mersenne_twister_engine__mersenne_twister_engine">mersenne_twister_engine</A></B>(unsigned long x0 = default_seed);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#mersenne_twister_engine__mersenne_twister_engine">mersenne_twister_engine</A></B>(Seed_seq&amp; seq);
    void <B><A HREF="#mersenne_twister_engine__seed">seed</A></B>(unsigned long x0 = default_seed);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#mersenne_twister_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    result_type <B><A HREF="#mersenne_twister_engine__min">min</A></B>() const;
    result_type <B><A HREF="#mersenne_twister_engine__max">max</A></B>() const;
    result_type <B><A HREF="#mersenne_twister_engine__operator()">operator()</A></B>();
    void <B><A HREF="#mersenne_twister_engine__discard">discard</A></B>(unsigned long long count)();
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>.
It holds a large integral value with <CODE>W * (N - 1) + R</CODE> bits.
It extracts <CODE>W</CODE> bits at a time from this large value, and when it
has used all the bits it twists the large value by shifting and mixing the bits so that it has
a new set of bits to extract from. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>N</CODE> <CODE>W</CODE>-bit values used if <CODE>operator()</CODE>
has been called at least <CODE>N</CODE> times, otherwise the <CODE>M</CODE>
<CODE>W</CODE>-bit values that have been used and
the last <CODE>N - M</CODE> values of the
<A HREF="lib_rand.html#seed_function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>2<SUP>W</SUP> - 1</CODE>. The values of the
other template arguments must satisfy the following requirements:</P>

<UL>
<LI><CODE>0 &lt; M &lt;= N</CODE></LI>
<LI><CODE>0 &lt;= {R, 2 * U, S, T, L} &lt;= W</CODE></LI>
<LI><CODE>0 &lt;= {A, B, C, D, F} &lt;= 2<SUP>W</SUP> - 1</CODE></LI>
<LI><CODE>W * (N - 1) + R</CODE> must be a Mersenne prime</LI>
</UL>

<P>The generator <B><A NAME="mersenne_twister_engine__twists"></A>twists</B> the large value that it
holds by executing the following code:</P>

<PRE>    for (size_t i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] &amp; LMASK) &lt;&lt; (W - 1) | (x[i + 1] &amp; HMASK) &gt;&gt; 1;
        if (temp &amp; 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (size_t i = 0; i &lt; N; ++i)
            x[i] = y[i];</PRE>

<P>where <CODE>LMASK</CODE> is an unsigned <CODE>W</CODE>-bit value with its
low <CODE>R</CODE> bits set to 1 and the rest of its bits set to 0,
and <CODE>HMASK</CODE> is the complement of <CODE>LMASK</CODE>.</P>

<P>The generator holds a current index <CODE>idx</CODE> initialized to 0.
It <SPAN><A NAME="mersenne_twister_engine__extracts"></A>extracts</SPAN> bits
by executing the following code:</P>

<PRE>    temp = x[idx++];
    temp = temp ^ ((temp &gt;&gt; U) &amp; D);
    temp = temp ^ ((temp &lt;&lt; S) &amp; B);
    temp = temp ^ ((temp &lt;&lt; T) &amp; C);
    temp = temp ^ (temp &gt;&gt; L);</PRE>

<P>When <CODE>idx</CODE> reaches <CODE>N</CODE> the generator
<A HREF="#mersenne_twister_engine__twists">twists</A> the stored value
and sets <CODE>idx</CODE> back to 0.</P>

<H3><CODE><A NAME="mersenne_twister_engine__default_seed"></A>mersenne_twister_engine::default_seed</CODE></H3>

<PRE>static constexpr result_type <B>default_seed</B> = 5489U;</PRE>

<P>The static const variable holds the default seed value <CODE>5489U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__discard"></A>mersenne_twister_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="mersenne_twister_engine__initialization_multiplier"></A>mersenne_twister_engine::initialization_multiplier</CODE></H3>

<PRE>static constexpr UIntType <B>initialization_multiplier</B> = F;</PRE>

<P>The static const variable holds the value of the template argument <CODE>F</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__mask_bits"></A>mersenne_twister_engine::mask_bits</CODE></H3>

<PRE>static constexpr size_t <B>mask_bits</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__max"></A>mersenne_twister_engine::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="mersenne_twister_engine__mersenne_twister_engine"></A>mersenne_twister_engine::mersenne_twister_engine</CODE></H3>

<PRE>explicit <B>mersenne_twister_engine</B>(unsigned long x0 = default_seed);
template&lt;class Seed_seq&gt;
    <B>explicit mersenne_twister_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="mersenne_twister_engine__min"></A>mersenne_twister_engine::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="mersenne_twister_engine__operator()"></A>mersenne_twister_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function <A HREF="#mersenne_twister_engine__extracts">extracts</A> the
next value in the sequence and returns it.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_b"></A>mersenne_twister_engine::tempering_b</CODE></H3>

<PRE>static constexpr UIntType <B>tempering_b</B> = B;</PRE>

<P>The static const variable holds the value of the template argument <CODE>B</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_c"></A>mersenne_twister_engine::tempering_c</CODE></H3>

<PRE>static constexpr UIntType <B>tempering_c</B> = C;</PRE>

<P>The static const variable holds the value of the template argument <CODE>C</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_d"></A>mersenne_twister_engine::tempering_d</CODE></H3>

<PRE>static constexpr UIntType <B>tempering_d</B> = D;</PRE>

<P>The static const variable holds the value of the template argument <CODE>D</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_l"></A>mersenne_twister_engine::tempering_l</CODE></H3>

<PRE>static constexpr size_t <B>tempering_l</B> = L;</PRE>

<P>The static const variable holds the value of the template argument <CODE>L</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_s"></A>mersenne_twister_engine::tempering_s</CODE></H3>

<PRE>static constexpr size_t <B>tempering_s</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_t"></A>mersenne_twister_engine::tempering_t</CODE></H3>

<PRE>static constexpr size_t <B>tempering_t</B> = T;</PRE>

<P>The static const variable holds the value of the template argument <CODE>T</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__tempering_u"></A>mersenne_twister_engine::tempering_u</CODE></H3>

<PRE>static constexpr size_t <B>tempering_u</B> = U;</PRE>

<P>The static const variable holds the value of the template argument <CODE>U</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__result_type"></A>mersenne_twister_engine::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__seed"></A>mersenne_twister_engine::seed</CODE></H3>

<PRE>void <B>seed</B>(result_type x0 = default_seed);
template&lt;class Seed_seq&gt;
    void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first seed function sets the oldest historical value <CODE>h[0]</CODE> to
<CODE>x0 mod 2<SUP>W</SUP></CODE>, then iteratively sets each successive historical value
<CODE>h[i]</CODE> to <CODE>(i + F * (h[i - 1] &gt;&gt; (W - 2))) mod 2<SUP>W</SUP></CODE>,
for <CODE>i</CODE> ranging from <CODE>1</CODE> to <CODE>N - 1</CODE>.</P>

<P>The second seed function sets the <CODE>N</CODE> historical values beginning with
<CODE>h[0]</CODE> as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>N * k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[N * k])</CODE>.</LI>

<LI>Each <CODE>h[i]</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[i * k]</CODE>, which supplies the lowest-order bits.</LI>
</UL>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second function does not participate in overload resolution.</P>

<H3><CODE><A NAME="mersenne_twister_engine__shift_size"></A>mersenne_twister_engine::shift_size</CODE></H3>

<PRE>static constexpr size_t <B>shift_size</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__state_size"></A>mersenne_twister_engine::state_size</CODE></H3>

<PRE>static constexpr size_t <B>state_size</B> = N;</PRE>

<P>The static const variable holds the value of the template argument <CODE>N</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__word_size"></A>mersenne_twister_engine::word_size</CODE></H3>

<PRE>static constexpr size_t <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H3><CODE><A NAME="mersenne_twister_engine__xor_mask"></A>mersenne_twister_engine::xor_mask</CODE></H3>

<PRE>static constexpr UIntType <B>xor_mask</B> = A;</PRE>

<P>The static const variable holds the value of the template argument <CODE>A</CODE>.</P>

<H2><CODE><A NAME="minstd_rand"></A>minstd_rand</CODE></H2>
<PRE>typedef linear_congruential_engine&lt; <I>ui-type</I>, 48271, 0, 2147483647&gt; <B>minstd_rand</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>linear_congruential_engine</CODE>.</P>

<H2><CODE><A NAME="minstd_rand0"></A>minstd_rand0</CODE></H2>

<PRE>typedef linear_congruential_engine&lt; <I>ui-type</I>, 16807, 0, 2147483647&gt; <B>minstd_rand0</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>linear_congruential_engine</CODE>.</P>

<H2><CODE><A NAME="mt19937"></A>mt19937</CODE></H2>
<PRE>typedef mersenne_twister&lt; <I>ui-type</I>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <B>mt19937</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>mersenne_twister</CODE>.</P>

<H2><CODE><A NAME="mt19937_64"></A>mt19937_64</CODE></H2>
<PRE>typedef mersenne_twister_engine&lt;<I>ui-type</I>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0xfff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <B>mt19937_64</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>mersenne_twister_engine</CODE>.</P>

<H2><CODE><A NAME="negative_binomial_distribution"></A>negative_binomial_distribution</CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>negative_binomial_distribution</B> { <B>[added with C++11]</B>
public:
    typedef IntType <B><A HREF="#negative_binomial_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#negative_binomial_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#negative_binomial_distribution__negative_binomial_distribution">negative_binomial_distribution</A></B>(result_type k0 = 1,
        double p0 = 0.5);
    explicit <B><A HREF="#negative_binomial_distribution__negative_binomial_distribution">negative_binomial_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#negative_binomial_distribution__k">k</A></B>() const;
    double <B><A HREF="#negative_binomial_distribution__p">p</A></B>() const;
    param_type <B><A HREF="#negative_binomial_distribution__param">param</A></B>() const;
    void <B><A HREF="#negative_binomial_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#negative_binomial_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#negative_binomial_distribution__max">max</A></B>() const;
    void <B><A HREF="#negative_binomial_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#negative_binomial_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#negative_binomial_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_k</B>;  <I>// exposition only</I>
    double <B>stored_p</B>;       <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type distributed with a binomial
distribution.</P>

<H3><CODE><A NAME="negative_binomial_distribution__k"></A>negative_binomial_distribution::k</CODE></H3>

<PRE>result_type <B>k</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_k</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__max"></A>negative_binomial_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__min"></A>negative_binomial_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__negative_binomial_distribution"></A>negative_binomial_distribution::negative_binomial_distribution</CODE></H3>

<PRE><B>negative_binomial_distribution</B>(result_type k0 = 1,
    double p0 = 0.5);
explicit <B>negative_binomial_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; k0 &amp;&amp; 0.0 &lt; p0 &amp;&amp; p0 &lt;= 1.0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_p</CODE>
holds the value <CODE>p0</CODE> and whose stored value <CODE>stored_k</CODE> holds
the value <CODE>k0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__operator()"></A>negative_binomial_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
integral values with each value <CODE>i</CODE> occurring with probability:</P>

<P><IMG SRC="negative_binomial_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__p"></A>negative_binomial_distribution::p</CODE></H3>

<PRE>double <B>p</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__param"></A>negative_binomial_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="negative_binomial_distribution__param_type"></A>negative_binomial_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef negative_binomial_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type t0 = 1, double p0 = 0.5);
    result_type k() const;
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="negative_binomial_distribution__reset"></A>negative_binomial_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="negative_binomial_distribution__result_type"></A>negative_binomial_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="normal_distribution"></A>normal_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>normal_distribution</B> {
public:
    typedef T1 <B><A HREF="#normal_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef RealType <B><A HREF="#normal_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#normal_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#normal_distribution__normal_distribution">normal_distribution</A></B>(result_type mean0 = result_type(0.0),
        result_type sigma0 = result_type(1.0));
    explicit <B><A HREF="#normal_distribution__normal_distribution">normal_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#normal_distribution__mean">mean</A></B>() const;
    result_type <B><A HREF="#normal_distribution__sigma">sigma</A></B>() const;
    result_type <B><A HREF="#normal_distribution__stddev">stddev</A></B>() const; <B>[added with C++11]</B>
    param_type <B><A HREF="#normal_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#normal_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#normal_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#normal_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#normal_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#normal_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#normal_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    result_type <B>stored_mean</B>;     <I>// exposition only</I>
    result_type <B>stored_sigma</B>;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a normal distribution.</P>

<H3><CODE><A NAME="normal_distribution__input_type"></A>normal_distribution::input_type</CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__max"></A>normal_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__mean"></A>normal_distribution::mean</CODE></H3>

<PRE>result_type <B>mean</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_mean</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__min"></A>normal_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__normal_distribution"></A>normal_distribution::normal_distribution</CODE></H3>

<PRE><B>normal_distribution</B>(result_type mean0 = result_type(0.0),
    result_type sigma0 = result_type(1.0));
explicit <B>normal_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; sigma0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_mean</CODE>
holds the value <CODE>mean0</CODE> and whose stored value <CODE>stored_sigma</CODE>
holds the value <CODE>sigma0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__operator()"></A>normal_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="normal_distribution.gif"></P>

<H3><CODE><A NAME="normal_distribution__param"></A>normal_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__param_type"></A>normal_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef normal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type mean0 = result_type(0.0),
        RealType sigma0 = result_type(1.0));
    RealType mean() const;
    RealType sigma() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="normal_distribution__reset"></A>normal_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="normal_distribution__result_type"></A>normal_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__sigma"></A>normal_distribution::sigma</CODE></H3>

<PRE>result_type <B>sigma</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_sigma</CODE>.</P>

<H3><CODE><A NAME="normal_distribution__stddev"></A>normal_distribution::stddev</CODE></H3>

<PRE>result_type <B>stddev</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the stored value <CODE>stored_sigma</CODE>.</P>

<H2><CODE><A NAME="operator_ne"></A>operator!=</CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator!=</B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator!=</B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator!=</B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B>operator!=</B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B>operator!=</B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B>operator!=</B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B>operator!=</B>( <B>[added with C++11]</B>
        const shuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);</PRE>

<P>The template operators return <CODE>!(left == right)</CODE>.</P>

<H2><CODE><A NAME="operator_eq"></A>operator==</CODE></H2>

<PRE>template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator==</B>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator==</B>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator==</B>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <B>operator==</B>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <B>operator==</B>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <B>operator==</B>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <B>operator==</B>( <B>[added with C++11]</B>
        const shuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);</PRE>

<P>The template operators return true if their engine operands have the same
stored parameters and state. (They generate the same sequence.)</P>

<H2><CODE><A NAME="operator_lsh"></A>operator&lt;&lt;</CODE></H2>

<PRE>template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_ostream&lt;Elem, Traits&gt;&amp; <B>operator&lt;&lt;</B>( <B>[added with C++11]</B>
        basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);</PRE>

<P>The template function inserts into the stream <CODE>ostr</CODE>
sufficient information about <CODE>right</CODE> to restore its stored
parameters with a subsequent extract. The stream must insert integer
values as decimals.</P>

<H2><CODE><A NAME="operator_rsh"></A>operator&gt;&gt;</CODE></H2>

<PRE>template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    basic_istream&lt;Elem, Traits&gt;&amp; <B>operator&gt;&gt;</B>( <B>[added with C++11]</B>
        basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);</PRE>

<P>The template function extracts from the stream <CODE>istr</CODE>
sufficient information into <CODE>right</CODE> to restore its stored
parameters from a previous insert. The stream must extract integer
values as decimals.</P>

<H2><CODE><A NAME="piecewise_constant_distribution"></A>piecewise_constant_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>piecewise_constant_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#piecewise_constant_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#piecewise_constant_distribution__param_type">param_type</A></B>;

    <B><A HREF="#piecewise_constant_distribution__piecewise_constant_distribution">piecewise_constant_distribution</A></B>();
    template&lt;class InIt1, class InIt2&gt;
        <B><A HREF="#piecewise_constant_distribution__piecewise_constant_distribution">piecewise_constant_distribution</A></B>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_constant_distribution__piecewise_constant_distribution">piecewise_constant_distribution</A></B>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_constant_distribution__piecewise_constant_distribution">piecewise_constant_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#piecewise_constant_distribution__piecewise_constant_distribution">piecewise_constant_distribution</A></B>(const param_type&amp; par0);

    vector&lt;result_type&gt; <B><A HREF="#piecewise_constant_distribution__densities">densities</A></B>() const;
    vector&lt;RealType&gt; <B><A HREF="#piecewise_constant_distribution__intervals">intervals</A></B>() const;
    param_type <B><A HREF="#piecewise_constant_distribution__param">param</A></B>() const;
    void <B><A HREF="#piecewise_constant_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#piecewise_constant_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#piecewise_constant_distribution__max">max</A></B>() const;
    void <B><A HREF="#piecewise_constant_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_constant_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_constant_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    vector&lt;result_type&gt; <B>stored_p</B>;    <I>// exposition only</I>
    vector&lt;RealType&gt; <B>stored_x</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed according to a varying-width histogram of probabilities.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE><A HREF="#discrete_distribution">discrete_distribution</A></CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE>piecewise_constant_distribution</CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_linear_distribution">piecewise_linear_distribution</A></CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="piecewise_constant_distribution__densities"></A>piecewise_constant_distribution::densities</CODE></H3>

<PRE>vector&lt;result_type&gt; <B>densities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>,
with each element <CODE>stored_p[I]</CODE> divided by <CODE>stored_x[I + 1]
- stored_x[I]</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__intervals"></A>piecewise_constant_distribution::intervals</CODE></H3>

<PRE>vector&lt;RealType&gt; <B>intervals</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_x</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__max"></A>piecewise_constant_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__min"></A>piecewise_constant_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__operator()"></A>piecewise_constant_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> in the range <CODE>[stored_x.front(),
stored_x.back())</CODE> occurring with probability determined by the smallest element
<CODE>I</CODE> for which <CODE>x &lt; stored_x[I + 1}</CODE>, and other values of <CODE>x</CODE>
occurring with probability zero. Values <CODE>x</CODE> are uniformly distributed over the
range <CODE>[stored_x[I], stored_x[I + 1])</CODE> with total probability <CODE>stored_p[I]</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__param"></A>piecewise_constant_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__param_type"></A>piecewise_constant_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef piecewise_constant_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    vector&lt;result_type&gt; densities() const;
    vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__piecewise_constant_distribution"></A>piecewise_constant_distribution::piecewise_constant_distribution</CODE></H3>

<PRE><B>piecewise_constant_distribution</B>();
template&lt;class InIt1, class InIt2&gt;
    <B>piecewise_constant_distribution</B>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <B>piecewise_constant_distribution</B>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <B>piecewise_constant_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>piecewise_constant_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements to be stored in
<CODE>stored_p</CODE> are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_x</CODE>
holds the values <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>,
and whose stored value <CODE>stored_p</CODE> holds the value <CODE>1.0</CODE>.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[first1, last1)</CODE>.
If the sequence has fewer than two elements, <CODE>stored_x</CODE> has two
elements <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>, and
<CODE>stored_p</CODE> has one element with value 1.
Otherwise, <CODE>stored_p</CODE> is initialized with <CODE>stored_x.size() - 1</CODE>
elements beginning at <CODE>first2</CODE>, then normalized so that the sum of
all elements is 1.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>.
Its stored value <CODE>stored_p</CODE> is initialized with <CODE>init.size() - 1</CODE> elements,
where element <CODE>I</CODE> stores the value <CODE>func(x)</CODE> for <CODE>x</CODE>
in the middle of subrange <CODE>[stored_x[I], stored_x[I + 1]]</CODE>.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fourth constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
It stores in <CODE>stored_x</CODE> the <CODE>count + 1</CODE> endpoints of these
subranges.
If <CODE>count &lt; 1</CODE>, <CODE>stored_p</CODE> has one element with
value 1.</P>

<P>The fifth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__result_type"></A>piecewise_constant_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="piecewise_constant_distribution__reset"></A>piecewise_constant_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H2><CODE><A NAME="piecewise_linear_distribution"></A>piecewise_linear_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>piecewise_linear_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#piecewise_linear_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#piecewise_linear_distribution__param_type">param_type</A></B>;

    <B><A HREF="#piecewise_linear_distribution__piecewise_linear_distribution">piecewise_linear_distribution</A></B>();
    template&lt;class InIt1, class InIt2&gt;
        <B><A HREF="#piecewise_linear_distribution__piecewise_linear_distribution">piecewise_linear_distribution</A></B>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_linear_distribution__piecewise_linear_distribution">piecewise_linear_distribution</A></B>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <B><A HREF="#piecewise_linear_distribution__piecewise_linear_distribution">piecewise_linear_distribution</A></B>(size_t count,
            double low, double high, Fn func);
    explicit <B><A HREF="#piecewise_linear_distribution__piecewise_linear_distribution">piecewise_linear_distribution</A></B>(const param_type&amp; par0);

    vector&lt;result_type&gt; <B><A HREF="#piecewise_linear_distribution__densities">densities</A></B>() const;
    vector&lt;RealType&gt; <B><A HREF="#piecewise_linear_distribution__intervals">intervals</A></B>() const;
    param_type <B><A HREF="#piecewise_linear_distribution__param">param</A></B>() const;
    void <B><A HREF="#piecewise_linear_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#piecewise_linear_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#piecewise_linear_distribution__max">max</A></B>() const;
    void <B><A HREF="#piecewise_linear_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_linear_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#piecewise_linear_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    vector&lt;result_type&gt; <B>stored_p</B>;    <I>// exposition only</I>
    vector&lt;RealType&gt; <B>stored_x</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed according to a varying-width histogram of probabilities,
with probability varying linearly over each interval.</P>

<P>Three distributions are very similar:</P>

<UL>
<LI>A <CODE><A HREF="#discrete_distribution">discrete_distribution</A></CODE>
has uniform-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE><A HREF="#piecewise_constant_distribution">piecewise_constant_distribution</A></CODE>
has varying-width intervals with uniform probability in each interval.</LI>

<LI>A <CODE>piecewise_linear_distribution</CODE>
has varying-width intervals with linearly varying probability over each interval.</LI>
</UL>

<H3><CODE><A NAME="piecewise_linear_distribution__densities"></A>piecewise_linear_distribution::densities</CODE></H3>

<PRE>vector&lt;result_type&gt; <B>densities</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_p</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__intervals"></A>piecewise_linear_distribution::intervals</CODE></H3>

<PRE>vector&lt;RealType&gt; <B>intervals</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_x</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__max"></A>piecewise_linear_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__min"></A>piecewise_linear_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__operator()"></A>piecewise_linear_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> in the range <CODE>[stored_x.front(),
stored_x.back())</CODE> occurring with probability determined by the smallest element
<CODE>I</CODE> for which <CODE>x &lt; stored_x[I + 1}</CODE>, and other values of <CODE>x</CODE>
occurring with probability zero. Values <CODE>x</CODE> are uniformly distributed over the
range <CODE>[stored_x[I], stored_x[I + 1])</CODE> with probability varying from
<CODE>stored_p[I]</CODE> to <CODE>stored_p[I + 1]</CODE>.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__param"></A>piecewise_linear_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__param_type"></A>piecewise_linear_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef piecewise_linear_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    vector&lt;result_type&gt; densities() const;
    vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__piecewise_linear_distribution"></A>piecewise_linear_distribution::piecewise_linear_distribution</CODE></H3>

<PRE><B>piecewise_linear_distribution</B>();
template&lt;class InIt1, class InIt2&gt;
    <B>piecewise_linear_distribution</B>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <B>piecewise_linear_distribution</B>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <B>piecewise_linear_distribution</B>(size_t count,
        double low, double high, Fn func);
explicit <B>piecewise_linear_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> All elements to be stored in
<CODE>stored_p</CODE> are nonnegative and at least one is nonzero.</P>

<P>The first constructor constructs an object whose stored value <CODE>stored_x</CODE>
holds the values <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>,
and whose stored value <CODE>stored_p</CODE> holds the values <CODE>1.0</CODE>
and <CODE>1.0</CODE>.</P>

<P>The second constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[first1, last1)</CODE>.
<CODE>stored_p</CODE> is initialized with <CODE>stored_x.size()</CODE>
elements beginning at <CODE>first2</CODE>.</P>

<P>The third constructor constructs an object whose stored value <CODE>stored_x</CODE>
is initialized with the sequence <CODE>[init.begin(), init.end())</CODE>.
Its stored value <CODE>stored_p</CODE> is initialized with <CODE>init.size()</CODE> elements,
where element <CODE>I</CODE> stores the value <CODE>func(stored_x[I])</CODE>.</P>

<P>The fourth constructor constructs an object whose stored value <CODE>stored_p</CODE>
is initialized with <CODE>count</CODE> elements. It divides the range <CODE>high - low</CODE>
into <CODE>count</CODE> subranges, then stores in element <CODE>I</CODE>
the value <CODE>func(x)</CODE> for <CODE>x</CODE> in the middle of subrange <CODE>I</CODE>.
It stores in <CODE>stored_x</CODE> the <CODE>count + 1</CODE> endpoints of these
subranges.</P>

<P>The fifth constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<P>In all cases,
if the sequence has fewer than two elements, <CODE>stored_x</CODE> has two
elements <CODE>RealType(0.0)</CODE> and <CODE>RealType(1.0)</CODE>, and
<CODE>stored_p</CODE> has two elements with value 1.
Also, <CODE>stored_p</CODE> is normalized so that the sum of
all probability intervals is 1.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__result_type"></A>piecewise_linear_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="piecewise_linear_distribution__reset"></A>piecewise_linear_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H2><CODE><A NAME="poisson_distribution"></A>poisson_distribution</CODE></H2>

<PRE>template&lt;class IntType = int,
    class RealType = double&gt; <B>[always double with C++11]</B>
    class <B>poisson_distribution</B> {
public:
    typedef T1 <B><A HREF="#poisson_distribution__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef IntType <B><A HREF="#poisson_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#poisson_distribution__param_type">param_type</A></B>; <B>[added with C++11]</B>

    explicit <B><A HREF="#poisson_distribution__poisson_distribution">poisson_distribution</A></B>(RealType mean0 = RealType(1.0));
    explicit <B><A HREF="#poisson_distribution__poisson_distribution">poisson_distribution</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    RealType <B><A HREF="#poisson_distribution__mean">mean</A></B>() const;
    param_type <B><A HREF="#poisson_distribution__param">param</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#poisson_distribution__param">param</A></B>(const param_type&amp; par0); <B>[added with C++11]</B>

    result_type <B><A HREF="#poisson_distribution__min">min</A></B>() const; <B>[added with C++11]</B>
    result_type <B><A HREF="#poisson_distribution__max">max</A></B>() const; <B>[added with C++11]</B>
    void <B><A HREF="#poisson_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#poisson_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#poisson_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0); <B>[added with C++11]</B>

private:
    RealType <B>stored_mean</B>;     <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a Poisson distribution.</P>

<H3><CODE><A NAME="poisson_distribution__input_type"></A>poisson_distribution::input_type</CODE></H3>

<PRE>typedef T1 <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__max"></A>poisson_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__mean"></A>poisson_distribution::mean</CODE></H3>

<PRE>RealType <B>mean</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_mean</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__min"></A>poisson_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const; <B>[added with C++11]</B></PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__operator()"></A>poisson_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> occurring with probability:</P>

<P><IMG SRC="poisson_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__param"></A>poisson_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const; <B>[added with C++11]</B>
void <B>param</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__param_type"></A>poisson_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> { <B>[added with C++11]</B>
    typedef poisson_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType mean = RealType(1.0));
    RealType mean() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="poisson_distribution__poisson_distribution"></A>poisson_distribution::poisson_distribution</CODE></H3>

<PRE><B>poisson_distribution</B>(RealType mean0 = RealType(1.0));
explicit <B>binomial_distribution</B>(const param_type&amp; par0); <B>[added with C++11]</B></PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; mean0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_mean</CODE>
holds the value <CODE>mean0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="poisson_distribution__reset"></A>poisson_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="poisson_distribution__result_type"></A>poisson_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H2><CODE><A NAME="random_device"></A>random_device</CODE></H2>

<PRE>class random_device {
public:
    typedef unsigned int <B><A HREF="#random_device__result_type">result_type</A></B>;

    explicit <B><A HREF="#random_device__random_device">random_device</A></B>(const string&amp; token = /* <I>implementation defined</I> */);

    result_type <B><A HREF="#random_device__min">min</A></B>() const;
    result_type <B><A HREF="#random_device__max">max</A></B>() const;
    double <B><A HREF="#random_device__entropy">entropy</A></B>() const noexcept;
    result_type <B><A HREF="#random_device__operator()">operator()</A></B>();

private:
    <B>random_device</B>(const random_device&amp;) = delete; <B>[added with C++11]</B>
    void <B>operator=</B>(const random_device&amp;) = delete; <B>[added with C++11]</B>
    };</PRE>

<P>The class describes a source of random numbers, preferably from a
non-deterministic external device. In this implementation
the values produced by default are not non-deterministic.
They are uniformly distributed in the closed range <CODE>[0, 65535]</CODE>.</P>

<H3><CODE><A NAME="random_device__entropy"></A>random_device::entropy</CODE></H3>

<PRE>double <B>entropy</B>() const noexcept;</PRE>

<P>The member function returns an estimate of the randomness of the
source, as measured in bits. (In the extreme, a non-random source has
an entropy of zero.)</P>

<H3><CODE><A NAME="random_device__max"></A>random_device::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returned by the
source.</P>

<H3><CODE><A NAME="random_device__min"></A>random_device::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returned by the
source.</P>

<H3><CODE><A NAME="random_device__operator()"></A>random_device::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns values uniformly distributed in the closed interval <CODE>[min(), max()]</CODE>.</P>

<H3><CODE><A NAME="random_device__random_device"></A>random_device::random_device</CODE></H3>

<PRE><B>random_device</B>(const string&amp; str = /* <I>implementation defined</I> */);</PRE>

<P>The constructor initializes the device (as needed) with <CODE>str</CODE>.</P>

<H3><CODE><A NAME="random_device__result_type"></A>random_device::result_type</CODE></H3>

<PRE>typedef unsigned int <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>unsigned int</CODE>.</P>

<H2><CODE><A NAME="ranlux_base_01"></A>ranlux_base_01</CODE></H2>

<PRE>typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <B>ranlux_base_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux24"></A>ranlux24</CODE></H2>

<PRE>typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <B>ranlux24</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block_engine</CODE>
with a specialization of the template <CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux24_base"></A>ranlux24_base</CODE></H2>

<PRE>typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 24, 10, 24&gt;
    <B>ranlux24_base</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template
<CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux3"></A>ranlux3</CODE></H2>

<PRE>typedef discard_block&lt;subtract_with_carry&lt; <I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;
    223, 24&gt; <B>ranlux3</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry</CODE>.</P>

<H2><CODE><A NAME="ranlux3_01"></A>ranlux3_01</CODE></H2>

<PRE>typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <B>ranlux3_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux4"></A>ranlux4</CODE></H2>

<PRE>typedef discard_block&lt;subtract_with_carry&lt; <I>ui-type</I>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <B>ranlux4</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry</CODE>.</P>

<H2><CODE><A NAME="ranlux4_01"></A>ranlux4_01</CODE></H2>

<PRE>typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <B>ranlux4_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block</CODE>
with a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="ranlux48"></A>ranlux48</CODE></H2>

<PRE>typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <B>ranlux48</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template <CODE>discard_block_engine</CODE>
with a specialization of the template <CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux48_base"></A>ranlux48_base</CODE></H2>

<PRE>typedef subtract_with_carry_engine&lt;<I>ui-type</I>, 48, 5, 12&gt;
    <B>ranlux48_base</B>; <B>[added with C++11]</B></PRE>

<P>The type is a synonym for a specialization of the template
<CODE>subtract_with_carry_engine</CODE>.</P>

<H2><CODE><A NAME="ranlux64_base_01"></A>ranlux64_base_01</CODE></H2>

<PRE>typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <B>ranlux64_base_01</B>;</PRE>

<P>The type is a synonym for a specialization of the template <CODE>subtract_with_carry_01</CODE>.</P>

<H2><CODE><A NAME="seed_seq"></A>seed_seq</CODE></H2>

<PRE>class <B>seed_seq</B> { <B>[added with C++11]</B>
public:
    typedef uint_least32_t <B><A HREF="#seed_seq__result_type">result_type</A></B>;

    <B><A HREF="#seed_seq__seed_seq">seed_seq</A></B>();
    template&lt;class Ty&gt;
        <B><A HREF="#seed_seq__seed_seq">seed_seq</A></B>(initializer_list&lt;Ty&gt; init);
    template&lt;class InIt&gt;
        <B><A HREF="#seed_seq__seed_seq">seed_seq</A></B>(InIt first, InIt last);

    template&lt;class RanIt&gt;
        void <B><A HREF="#seed_seq__generate">generate</A></B>(RanIt first, RanIt last,
            size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
                InIt&gt;::value_type&gt;::digits) const;
    size_t <B>size</B>() const;
    template&lt;class OutIt&gt;
        void <B><A HREF="#seed_seq__param">param</A></B>(OutIt dest) const;

    <B>seed_seq</B>(const seed_seq&amp;) = delete;
    void <B>operator=</B>(const seed_seq&amp;) = delete;

private:
    vector&lt;result_type&gt; <B>vec</B>;    <I>// exposition only</I>
    };</PRE>

<P>The class stores a vector of unsigned integer values that can supply a
randomized seed for a random-number engine.</P>

<H3><CODE><A NAME="seed_seq__generate"></A>seed_seq::generate</CODE></H3>

<PRE>template&lt;class RanIt&gt;
    void <B>generate</B>(RanIt first, RanIt last) const;</PRE>

<P>The template function initializes the elements of the sequence
<CODE>[first, last)</CODE> (if the sequence is non-empty) as follows:</P>

<PRE>const size_t s = vec.size();
const size_t n = last - first;
const size_t t = 623 &lt;= n ? 11 : 68 &lt;= n ? 7
    : 39 &lt;= n ? 5 : 7 &lt;= n ? 3 : (n - 1) / 2;
const size_t p = (n - t) / 2;
const size_t q = p + t;
const size_t m = n &lt;= s ? s + 1 : n;
size_t k;

for (k = 0; k &lt; n; ++k)
    first[k] = 0x8b8b8b8b;

for (k = 0; k &lt; m; ++k)
    {    // scramble and add any vector contribution
    result_type r1 = 1664525
        * xor27(first[k % n] ^ first[(k + p) % n] ^ first[(k - 1) % n]);
    result_type r2 = r1
        + (k == 0 ? s : k &lt;= s ? k % n + vec[k - 1] : k % n);

    first[(k + p) % n] += r1;
    first[(k + q) % n] += r2;
    first[k] = r2;
    }

for (; k &lt; m + n; ++k)
    {    // rescramble
    result_type r3 = 1566083941
        * xor27(first[k % n] + first[(k + p) % n] + first[(k - 1) % n]);
    result_type r4 = r3 - k % n;

    first[(k + p) % n] ^= r3;
    first[(k + q) % n] ^= r4;
    first[k] = r4;
    }</PRE>

<P>The function <CODE>xor27</CODE> is defined as:</P>

<PRE>result_type xor27(result_type val) const
    {    // shift and merge
    return (val ^ (val &gt;&gt; 27));
    }</PRE>

<H3><CODE><A NAME="seed_seq__param"></A>seed_seq::param</CODE></H3>

<PRE>template&lt;class OutIt&gt;
    void <B>param</B>(OutIt dest) const;</PRE>

<P>The template function executes <CODE>copy(vec.begin(), vec.end(), dest)</CODE>.</P>

<H3><CODE><A NAME="seed_seq__result_type"></A>seed_seq::result_type</CODE></H3>

<PRE>typedef uint_least32_t <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>uint_least32_t</CODE>.</P>

<H3><CODE><A NAME="seed_seq__seed_seq"></A>seed_seq::seed_seq</CODE></H3>

<PRE><B>seed_seq</B>();
template&lt;class Ty&gt;
    <B>seed_seq</B>(initializer_list&lt;Ty&gt; init);
template&lt;class InIt&gt;
    <B>seed_seq</B>(InIt first, InIt last,
        size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
            InIt&gt;::value_type&gt;::digits);</PRE>

<P>The first constructor initializes <CODE>vec</CODE> to an empty vector.
The second constructor initializes <CODE>vec</CODE> with a sequence of
elements in <CODE>[init.begin(), init.end())</CODE>, each reduced modulo 2^32.
The third constructor initializes <CODE>vec</CODE> with a sequence of
elements in <CODE>[first, last)</CODE>, each reduced modulo 2^32.</P>

<H2><CODE><A NAME="shuffle_order_engine"></A>shuffle_order_engine</CODE></H2>

<PRE>template&lt;class Engine,
    size_t K&gt;
    class <B>shuffle_order_engine</B> { <B>[added with C++11]</B>
public:
    typedef Engine <B><A HREF="#shuffle_order_engine__base_type">base_type</A></B>;
    typedef typename base_type::result_type <B><A HREF="#shuffle_order_engine__result_type">result_type</A></B>;

    static constexpr size_t <B><A HREF="#shuffle_order_engine__table_size">table_size</A></B> = K;

    <B><A HREF="#shuffle_order_engine__shuffle_order_engine">shuffle_order_engine</A></B>();
    explicit <B><A HREF="#shuffle_order_engine__shuffle_order_engine">shuffle_order_engine</A></B>(const base_type&amp; eng);
    explicit <B><A HREF="#shuffle_order_engine__shuffle_order_engine">shuffle_order_engine</A></B>(base_type&amp;&amp; eng);
    explicit <B><A HREF="#shuffle_order_engine__shuffle_order_engine">shuffle_order_engine</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#shuffle_order_engine__shuffle_order_engine">shuffle_order_engine</A></B>(Seed_seq&amp; seq);

    void <B><A HREF="#shuffle_order_engine__seed">seed</A></B>();
    void <B><A HREF="#shuffle_order_engine__seed">seed</A></B>(result_type x0);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#shuffle_order_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    const base_type&amp; <B><A HREF="#shuffle_order_engine__base">base</A></B>() const noexcept;
    static constexpr result_type <B><A HREF="#shuffle_order_engine__min">min</A></B>();
    static constexpr result_type <B><A HREF="#shuffle_order_engine__max">max</A></B>();
    result_type <B><A HREF="#shuffle_order_engine__operator()">operator()</A></B>();
    void <B><A HREF="#shuffle_order_engine__discard">discard</A></B>(unsigned long long count);

private:
    Engine <B>stored_eng</B>;         <I>// exposition only</I>
    result_type <B>stored_arr</B>[K]; <I>// exposition only</I>
    result_type <B>stored_y</B>;      <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#compound_engine">compound engine</A>
that produces values by reordering the values
returned by its base engine. Each constructor fills the array <CODE>stored_arr</CODE>
with <CODE>K</CODE> values returned by the base engine. It then stores in
<CODE>stored_y</CODE> an additional value returned by the base engine.
Each element of the generated sequence is then obtained from <CODE>stored_y</CODE>,
after which:</P>

<UL>
<LI>The array index <CODE>J</CODE> is computed as <CODE>K * (stored_y - min())
/ (max() - min() + 1)</CODE>.</LI>

<LI><CODE>stored_y</CODE> is replaced by <CODE>stored_arr[J]</CODE>.</LI>

<LI><CODE>stored_arr[J]</CODE> is replaced by <CODE>stored_eng()</CODE>.</LI>
</UL>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng</CODE>,
followed by the <CODE>K</CODE> elements of <CODE>stored_arr</CODE>, followed by
<CODE>stored_y</CODE>.</P>

<P>The value of the template argument <CODE>K</CODE> must be greater than zero.</P>

<H3><CODE><A NAME="shuffle_order_engine__base"></A>shuffle_order_engine::base</CODE></H3>

<PRE>const base_type&amp; <B>base</B>() const noexcept;</PRE>

<P>The member function returns a reference to the underlying engine object.</P>

<H3><CODE><A NAME="shuffle_order_engine__base_type"></A>shuffle_order_engine::base_type</CODE></H3>

<PRE>typedef Engine <B>base_type</B>;</PRE>

<P>The type is a synonym for the type of the underlying engine object.</P>

<H3><CODE><A NAME="shuffle_order_engine__discard"></A>shuffle_order_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="shuffle_order_engine__max"></A>shuffle_order_engine::max</CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The static member function returns <CODE>Engine::max()</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine__min"></A>shuffle_order_engine::min</CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The static member function returns <CODE>Engine::min()</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine__operator()"></A>shuffle_order_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function returns the next value in the sequence.</P>

<H3><CODE><A NAME="shuffle_order_engine__result_type"></A>shuffle_order_engine::result_type</CODE></H3>

<PRE>typedef typename base_type::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>base_type::result_type</CODE>.</P>

<H3><CODE><A NAME="shuffle_order_engine__seed"></A>shuffle_order_engine::seed</CODE></H3>

<PRE>void <B>seed</B>();
void <B>seed</B>(result_type x0);
void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
calls <CODE>stored_eng.seed()</CODE>.
The second seed function calls <CODE>stored_eng.seed(x0)</CODE>.
The third seed function calls <CODE>stored_eng.seed(seq)</CODE>.</P>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the third function does not participate in overload resolution.</P>

<H3><CODE><A NAME="shuffle_order_engine__shuffle_order_engine"></A>shuffle_order_engine::shuffle_order_engine</CODE></H3>

<PRE><B>shuffle_order_engine</B>();
explicit <B>shuffle_order_engine</B>(const base_type&amp; eng);
explicit <B>shuffle_order_engine</B>(base_type&amp;&amp; eng);
explicit <B>shuffle_order_engine</B>(result_type x0);
template&lt;class Seed_seq&gt;
    explicit <B>shuffle_order_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs a <CODE>shuffle_order_engine</CODE>
object with a default-initialized engine.
The second constructor constructs a <CODE>shuffle_order_engine</CODE>
object with a copy of an engine object.
The third constructor constructs a <CODE>shuffle_order_engine</CODE>
object by moving the engine object.
The fourth constructor constructs a <CODE>shuffle_order_engine</CODE>
object with its engine initialized by <CODE>stored_engine(x0)</CODE>.</P>

<P>The fifth constructor constructs a <CODE>shuffle_order_engine</CODE>
object with its engine initialized by <CODE>stored_engine(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the fifth constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="shuffle_order_engine__table_size"></A>shuffle_order_engine::table_size</CODE></H3>

<PRE>static constexpr size_t <B>table_size</B> = K;</PRE>

<P>The static const variable has the same value as the template parmaeter <CODE>K</CODE>.</P>

<H2><CODE><A NAME="student_t_distribution"></A>student_t_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>student_t_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#student_t_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#student_t_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#student_t_distribution__student_t_distribution">student_t_distribution</A></B>(RealType n0 = 1);
    explicit <B><A HREF="#student_t_distribution__student_t_distribution">student_t_distribution</A></B>(const param_type&amp; par0);

    RealType <B><A HREF="#student_t_distribution__n">n</A></B>() const;
    param_type <B><A HREF="#student_t_distribution__param">param</A></B>() const;
    void <B><A HREF="#student_t_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#student_t_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#student_t_distribution__max">max</A></B>() const;
    void <B><A HREF="#student_t_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#student_t_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#student_t_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <B>stored_n</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Student T distribution.</P>

<H3><CODE><A NAME="student_t_distribution__max"></A>student_t_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__min"></A>student_t_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__n"></A>student_t_distribution::n</CODE></H3>

<PRE>RealType <B>n</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_n</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__operator()"></A>student_t_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="student_t_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__param"></A>student_t_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__param_type"></A>student_t_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef student_t_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="student_t_distribution__reset"></A>student_t_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="student_t_distribution__result_type"></A>student_t_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="student_t_distribution__student_t_distribution"></A>student_t_distribution::student_t_distribution</CODE></H3>

<PRE><B>student_t_distribution</B>(RealType n0 = 1);
explicit <B>student_t_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; n0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_n</CODE>
holds the value <CODE>n0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry"></A>subtract_with_carry</CODE></H2>

<PRE>template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <B>subtract_with_carry</B> {
public:
    typedef IntType <B><A HREF="#subtract_with_carry__result_type">result_type</A></B>;
    static constexpr IntType <B><A HREF="#subtract_with_carry__modulus">modulus</A></B> = M;
    static constexpr int <B><A HREF="#subtract_with_carry__short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry__long_lag">long_lag</A></B> = R;

    <B><A HREF="#subtract_with_carry__subtract_with_carry">subtract_with_carry</A></B>();
    explicit <B><A HREF="#subtract_with_carry__subtract_with_carry">subtract_with_carry</A></B>(IntType x0);
    template&lt;class Gen&gt;
        <B><A HREF="#subtract_with_carry__subtract_with_carry">subtract_with_carry</A></B>(Gen&amp; gen);
    void <B><A HREF="#subtract_with_carry__seed">seed</A></B>(IntType x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <B><A HREF="#subtract_with_carry__seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#subtract_with_carry__min">min</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry__max">max</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry__operator()">operator()</A></B>();
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>
that produces values of a user-specified integral type using the
<B><A NAME="subtract_with_carry__recurrence_relation"></A>recurrence relation</B>&nbsp;
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>1</CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>.</P>

<P>The engine's <A HREF="lib_rand.html#state">state</A> is a carry indicator plus
<CODE>R</CODE> values. These values consist of the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>N</CODE> values that have been returned and
the last <CODE>R - N</CODE> values of the
<A HREF="lib_rand.html#seed_function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#IntType">IntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__long_lag"></A>subtract_with_carry::long_lag</CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__max"></A>subtract_with_carry::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__min"></A>subtract_with_carry::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry__modulus"></A>subtract_with_carry::modulus</CODE></H3>

<PRE>static constexpr IntType <B>modulus</B> = M;</PRE>

<P>The static const variable holds the value of the template argument <CODE>M</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__operator()"></A>subtract_with_carry::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry__recurrence_relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry__result_type"></A>subtract_with_carry::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__seed"></A>subtract_with_carry::seed</CODE></H3>

<PRE>void <B>seed</B>(unsigned long x0 = 19780503UL);
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
generates <CODE>long_lag</CODE> historical values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE>. Each historical value is <CODE>gen() % modulus</CODE>.</P>

<P>The second seed function effectively executes the following code:</P>

<PRE>    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);</PRE>

<H3><CODE><A NAME="subtract_with_carry__short_lag"></A>subtract_with_carry::short_lag</CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry__subtract_with_carry"></A>subtract_with_carry::subtract_with_carry</CODE></H3>

<PRE><B>subtract_with_carry</B>();
explicit <B>subtract_with_carry</B>(unsigned long x0);
template&lt;class Gen&gt;
    <B>subtract_with_carry</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry_engine"></A>subtract_with_carry_engine</CODE></H2>

<PRE>template&lt;class UIntType,
    int W, int S, int R&gt;
    class <B>subtract_with_carry_engine</B> { <B>[added with C++11]</B>
public:
    typedef UIntType <B><A HREF="#subtract_with_carry_engine__result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#subtract_with_carry_engine__word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#subtract_with_carry_engine__short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry_engine__long_lag">long_lag</A></B> = R;
    static constexpr UIntType <B><A HREF="#subtract_with_carry_engine__default_seed">default_seed</A></B> = 19780503U;

    explicit <B><A HREF="#subtract_with_carry_engine__subtract_with_carry_engine">subtract_with_carry_engine</A></B>(UIntType x0 = default_seed);
    template&lt;class Seed_seq&gt;
        explicit <B><A HREF="#subtract_with_carry_engine__subtract_with_carry_engine">subtract_with_carry_engine</A></B>(Seed_seq&amp; seq);
    void <B><A HREF="#subtract_with_carry_engine__seed">seed</A></B>(UIntType x0 = default_seed);
    template&lt;class Seed_seq&gt;
        void <B><A HREF="#subtract_with_carry_engine__seed">seed</A></B>(Seed_seq&amp; seq);

    static constexpr result_type <B><A HREF="#subtract_with_carry_engine__min">min</A></B>();
    static constexpr result_type <B><A HREF="#subtract_with_carry_engine__max">max</A></B>();
    result_type <B><A HREF="#subtract_with_carry_engine__operator()">operator()</A></B>();
    void <B><A HREF="#subtract_with_carry_engine__discard">discard</A></B>(unsigned long long count)();
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>
that produces values of a user-specified unsigned integral type using the
<B><A NAME="subtract_with_carry_engine__recurrence_relation"></A>recurrence relation</B>&nbsp;
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>1</CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>, and <CODE>M</CODE> has the value <CODE>2<SUP>W</SUP></CODE>.
(Note that the template parameter <CODE>W</CODE> here replaces the template
parameter <CODE>M</CODE> for
<CODE><A HREF="#subtract_with_carry">subtract_with_carry</A></CODE>.)
The engine's <A HREF="lib_rand.html#state">state</A> is a carry indicator plus
<CODE>R</CODE> values. These values consist of the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>N</CODE> values that have been returned and
the last <CODE>R - N</CODE> values of the
<A HREF="lib_rand.html#seed_function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#UIntType">UIntType</A> must be
large enough to hold values up to <CODE>M - 1</CODE>. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__default_seed"></A>subtract_with_carry_engine::default_seed</CODE></H3>

<PRE>static constexpr UIntType <B>default_seed</B> = 19780503U;</PRE>

<P>The static const variable holds the default seed value <CODE>19780503U</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__discard"></A>subtract_with_carry_engine::discard</CODE></H3>

<PRE>void <B>discard</B>(unsigned long long count);</PRE>

<P>The member function effectively calls <CODE>(*this)()</CODE> <CODE>count</CODE> times.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__long_lag"></A>subtract_with_carry_engine::long_lag</CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__max"></A>subtract_with_carry_engine::max</CODE></H3>

<PRE>static constexpr result_type <B>max</B>();</PRE>

<P>The member function returns <CODE>M - 1</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__min"></A>subtract_with_carry_engine::min</CODE></H3>

<PRE>static constexpr result_type <B>min</B>();</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__operator()"></A>subtract_with_carry_engine::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry_engine__recurrence_relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__result_type"></A>subtract_with_carry_engine::result_type</CODE></H3>

<PRE>typedef UIntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>UIntType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__seed"></A>subtract_with_carry_engine::seed</CODE></H3>

<PRE>void <B>seed</B>(UIntType x0 = default_seed);
template&lt;class Seed_seq&gt;
    void <B>seed</B>(Seed_seq&amp; seq);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
effectively constructs the engine <CODE>gen</CODE>:</P>

<PRE>linear_congruential_engine&lt;UIntType, 40014, 0, 2147483563&gt;
    gen(x0 == 0 ? default_seed: x0);</PRE>

<P>It then sets the <CODE>R</CODE> historical values beginning with <CODE>h[0]</CODE> to
the values produced by calling <CODE>gen()</CODE>.</P>

<P>The second seed function sets these historical values as follows:</P>

<UL>
<LI><CODE>k</CODE> is the number of <I>unsigned long</I> integers needed to supply
all the bits in a <CODE>UIntType</CODE> integer (at least 1).</LI>

<LI><CODE>a</CODE> is an array of <CODE>R * k</CODE> elements of type <CODE>UIntType</CODE>.</LI>

<LI><CODE>a</CODE> is initialized by calling
<CODE>seq.generate(&amp;a[0], &amp;a[R * k])</CODE>.</LI>

<LI>Each <CODE>h[i]</CODE> is composed by packing the <CODE>k</CODE>
elements beginning at <CODE>a[i * k]</CODE>, which supplies the lowest-order bits.</LI>

<LI>Each <CODE>h[i]</CODE> is reduced modulo <CODE>M</CODE>.</LI>
</UL>

<P>Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second function does not participate in overload resolution.</P>

<P>In either case, the stored carry is <CODE>h[R - 1] == 0</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__short_lag"></A>subtract_with_carry_engine::short_lag</CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__subtract_with_carry_engine"></A>subtract_with_carry_engine::subtract_with_carry_engine</CODE></H3>

<PRE>explicit <B>subtract_with_carry_engine</B>(UIntType x0 = default_seed);
template&lt;class Seed_seq&gt;
    <B>subtract_with_carry_engine</B>(Seed_seq&amp; seq);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The second constructor constructs an object and initializes it by
calling <CODE>seed(seq)</CODE>.
Unless <CODE>Seed_seq</CODE> is not convertible to <CODE>result_type</CODE>,
the second constructor does not participate in overload resolution.</P>

<H3><CODE><A NAME="subtract_with_carry_engine__word_size"></A>subtract_with_carry_engine::word_size</CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="subtract_with_carry_01"></A>subtract_with_carry_01</CODE></H2>

<PRE>template&lt;class RealType,
    int W, int S, int R&gt;
    class <B>subtract_with_carry_01</B> {
public:
    typedef RealType <B><A HREF="#subtract_with_carry_01__result_type">result_type</A></B>;
    static constexpr int <B><A HREF="#subtract_with_carry_01__word_size">word_size</A></B> = W;
    static constexpr int <B><A HREF="#subtract_with_carry_01__short_lag">short_lag</A></B> = S;
    static constexpr int <B><A HREF="#subtract_with_carry_01__long_lag">long_lag</A></B> = R;

    <B><A HREF="#subtract_with_carry_01__subtract_with_carry_01">subtract_with_carry_01</A></B>();
    explicit <B><A HREF="#subtract_with_carry_01__subtract_with_carry_01">subtract_with_carry_01</A></B>(unsigned long x0);
    template&lt;class Gen&gt;
        <B><A HREF="#subtract_with_carry_01__subtract_with_carry_01">subtract_with_carry_01</A></B>(Gen&amp; gen);
    void <B><A HREF="#subtract_with_carry_01__seed">seed</A></B>(unsigned long x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <B><A HREF="#subtract_with_carry_01__seed">seed</A></B>(Gen&amp; gen);

    result_type <B><A HREF="#subtract_with_carry_01__min">min</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry_01__max">max</A></B>() const;
    result_type <B><A HREF="#subtract_with_carry_01__operator()">operator()</A></B>();
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#simple_engine">simple engine</A>
that produces values of a user-specified floating-point type using the
<B><A NAME="subtract_with_carry_01__recurrence_relation"></A>recurrence relation</B>&nbsp;
<CODE>x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod 1</CODE>, where
<CODE>cy(i)</CODE> has the value <CODE>2<SUP>-W</SUP></CODE> if
<CODE>x(i - S) - x(i - R) - cy(i - 1) &lt; 0</CODE>,
otherwise <CODE>0</CODE>. The engine's <A HREF="lib_rand.html#state">state</A> is the
last <CODE>R</CODE> values returned if <CODE>operator()</CODE> has been called at least
<CODE>R</CODE> times, otherwise the <CODE>M</CODE> values that have been returned and
the last <CODE>R - M</CODE> values of the
<A HREF="lib_rand.html#seed_function">seed</A>.</P>

<P>The template argument <A HREF="lib_rand.html#RealType">RealType</A> must be
large enough to hold values with <CODE>W</CODE> fraction bits. The values of the template arguments
<CODE>S</CODE> and <CODE>R</CODE> must be greater than 0 and <CODE>S</CODE> must be
less than <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01__long_lag"></A>subtract_with_carry_01::long_lag</CODE></H3>

<PRE>static constexpr int <B>long_lag</B> = R;</PRE>

<P>The static const variable holds the value of the template argument <CODE>R</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01__max"></A>subtract_with_carry_01::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="subtract_with_carry_01__min"></A>subtract_with_carry_01::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns zero.</P>

<H3><CODE><A NAME="subtract_with_carry_01__operator()"></A>subtract_with_carry_01::operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member function generates the next value in the pseudo-random sequence
by applying the <A HREF="#subtract_with_carry__recurrence_relation">recurrence relation</A>
to the stored historical values, stores the generated value, and returns it.</P>

<H3><CODE><A NAME="subtract_with_carry_01__result_type"></A>subtract_with_carry01::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01__seed"></A>subtract_with_carry_01::seed</CODE></H3>

<PRE>template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);
void <B>seed</B>(unsigned long x0 = 19780503UL);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0 &lt; x0</CODE></P>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
generates <CODE>long_lag</CODE> historical values
from the values of type <CODE>unsigned long</CODE> returned by successive invocations of
<CODE>gen</CODE>. Each historical value is generated
by concatenating the low 32 bits from each of <CODE>long_lag * (word_size + 31) / 32</CODE>
values from the initialization sequence; the resulting value is then divided by
<CODE>2.0<SUP>word_size</SUP></CODE> and the integral part discarded. Thus, each historical value
is a floating-point value greater than or equal to 0.0 and less than 1.0, with
<CODE>word_size</CODE> significant bits.</P>

<P>The second seed function effectively executes the following code:</P>

<PRE>    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);</PRE>

<H3><CODE><A NAME="subtract_with_carry_01__short_lag"></A>subtract_with_carry_01::short_lag</CODE></H3>

<PRE>static constexpr int <B>short_lag</B> = S;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01__subtract_with_carry_01"></A>subtract_with_carry_01::subtract_with_carry_01</CODE></H3>

<PRE><B>subtract_with_carry_01</B>();
explicit <B>subtract_with_carry_01</B>(IntType x0);
template&lt;class In&gt;
    <B>subtract_with_carry_01</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object and initializes it by calling <CODE>seed()</CODE>.
The second constructor constructs an object and initializes it by calling <CODE>seed(x0)</CODE>.
The third constructor constructs an object and initializes it by
calling <CODE>seed(gen)</CODE>.</P>

<H3><CODE><A NAME="subtract_with_carry_01__word_size"></A>subtract_with_carry_01::word_size</CODE></H3>

<PRE>static constexpr int <B>word_size</B> = W;</PRE>

<P>The static const variable holds the value of the template argument <CODE>W</CODE>.</P>

<H2><CODE><A NAME="uniform_int"></A>uniform_int</CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>uniform_int</B> {
public:
    typedef IntType <B><A HREF="#uniform_int__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef IntType <B><A HREF="#uniform_int__result_type">result_type</A></B>;

    explicit <B><A HREF="#uniform_int__uniform_int">uniform_int</A></B>(result_type min0 = 0,
        result_type max0 = 9);

    result_type <B><A HREF="#uniform_int__min">min</A></B>() const;
    result_type <B><A HREF="#uniform_int__max">max</A></B>() const;
    void <B><A HREF="#uniform_int__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int__operator()">operator()</A></B>(Engine&amp; eng, result_type n);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_int__input_type"></A>uniform_int::input_type</CODE></H3>

<PRE>typedef IntType <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int__max"></A>uniform_int::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int__min"></A>uniform_int::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int__operator()"></A>uniform_int::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng, result_type n);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the closed range <CODE>[min(), max()]</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<P>The second member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the half-open range <CODE>[0, n)</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<H3><CODE><A NAME="uniform_int__reset"></A>uniform_int::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_int__result_type"></A>uniform_int::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int__uniform_int"></A>uniform_int::uniform_int</CODE></H3>

<PRE>explicit <B>uniform_int</B>(result_type min0 = 0, result_type max0 = 9);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt;= max0</CODE></P>

<P>The constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<H2><CODE><A NAME="uniform_int_distribution"></A>uniform_int_distribution</CODE></H2>

<PRE>template&lt;class IntType = int&gt;
    class <B>uniform_int_distribution</B> { <B>[added with C++11]</B>
public:
    typedef IntType <B><A HREF="#uniform_int_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#uniform_int_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#uniform_int_distribution__uniform_int_distribution">uniform_int_distribution</A></B>(result_type min0 = 0,
        result_type max0 = numeric_limits&lt;IntType&gt;::max());
    explicit <B><A HREF="#uniform_int_distribution__uniform_int_distribution">uniform_int_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_int_distribution__a">a</A></B>() const;
    result_type <B><A HREF="#uniform_int_distribution__b">b</A></B>() const;
    param_type <B><A HREF="#uniform_int_distribution__param">param</A></B>() const;
    void <B><A HREF="#uniform_int_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_int_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#uniform_int_distribution__max">max</A></B>() const;
    void <B><A HREF="#uniform_int_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_int_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified integral type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_int_distribution__a"></A>uniform_int_distribution::a</CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__b"></A>uniform_int_distribution::b</CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__max"></A>uniform_int_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__min"></A>uniform_int_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__operator()"></A>uniform_int_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed integral values and returns integral values with
each value <CODE>i</CODE> in the closed range <CODE>[min(), max()]</CODE> occurring
with equal probability and values outside that range occurring with probability 0.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__param"></A>uniform_int_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__param_type"></A>uniform_int_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef uniform_int_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type a0 = 0,
        result_type b0 = numeric_limits&lt;IntType&gt;::max());
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="uniform_int_distribution__reset"></A>uniform_int_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_int_distribution__result_type"></A>uniform_int_distribution::result_type</CODE></H3>

<PRE>typedef IntType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>IntType</CODE>.</P>

<H3><CODE><A NAME="uniform_int_distribution__uniform_int_distribution"></A>uniform_int_distribution::uniform_int_distribution</CODE></H3>

<PRE>explicit <B>uniform_int_distribution</B>(result_type min0 = 0,
    result_type max0 = numeric_limits&lt;IntType&gt;::max());
explicit <B>uniform_int_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt;= max0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="uniform_real"></A>uniform_real</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>uniform_real</B> {
public:
    typedef RealType <B><A HREF="#uniform_real__input_type">input_type</A></B>; <B>[removed in final C++11]</B>
    typedef RealType <B><A HREF="#uniform_real__result_type">result_type</A></B>;

    explicit <B><A HREF="#uniform_real__uniform_real">uniform_real</A></B>(result_type min0 = result_type(0),
        result_type max0 = result_type(1));

    result_type <B><A HREF="#uniform_real__min">min</A></B>() const;
    result_type <B><A HREF="#uniform_real__max">max</A></B>() const;
    void <B><A HREF="#uniform_real__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real__operator()">operator()</A></B>(Engine&amp; eng);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_real__input_type"></A>uniform_real::input_type</CODE></H3>

<PRE>typedef RealType <B>input_type</B>; <B>[removed in final C++11]</B></PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real__max"></A>uniform_real::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real__min"></A>uniform_real::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real__operator()"></A>uniform_real::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);</PRE>

<P>The member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed floating-point values and returns floating-point values with
each value <CODE>x</CODE> in the half-open range <CODE>[min(), max())</CODE> occurring
with equal probability, and values outside that range occurring with probability 0.</P>

<H3><CODE><A NAME="uniform_real__reset"></A>uniform_real::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_real__result_type"></A>uniform_real::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real__uniform_real"></A>uniform_real::uniform_real</CODE></H3>

<PRE>explicit <B>uniform_real</B>(result_type min0 = result_type(0),
    result_type max0 = result_type(1));</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt;= max0 &amp;&amp; max0 - min0 &lt;= numeric_limits&lt;RealType&gt;::max()</CODE></P>

<P>The constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<H2><CODE><A NAME="uniform_real_distribution"></A>uniform_real_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>uniform_real_distribution</B> {
public:
    typedef RealType <B><A HREF="#uniform_real_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#uniform_real_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#uniform_real_distribution__uniform_real_distribution">uniform_real_distribution</A></B>(result_type min0 = result_type(0.0),
        result_type max0 = result_type(1.0));
    explicit <B><A HREF="#uniform_real_distribution__uniform_real_distribution">uniform_real_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_real_distribution__a">a</A></B>() const;
    result_type <B><A HREF="#uniform_real_distribution__b">b</A></B>() const;
    param_type <B><A HREF="#uniform_real_distribution__param">param</A></B>() const;
    void <B><A HREF="#uniform_real_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#uniform_real_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#uniform_real_distribution__max">max</A></B>() const;
    void <B><A HREF="#uniform_real_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#uniform_real_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <I>// exposition only</I>
    result_type stored_max;    <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type with a uniform distribution.</P>

<H3><CODE><A NAME="uniform_real_distribution__a"></A>uniform_real_distribution::a</CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__b"></A>uniform_real_distribution::b</CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the parameter <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__max"></A>uniform_real_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>stored_max</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__min"></A>uniform_real_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>stored_min</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__operator()"></A>uniform_real_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The member function uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed floating-point values and returns floating-point values with
each value <CODE>x</CODE> in the half-open range <CODE>[min(), max())</CODE> occurring
with equal probability, and values outside that range occurring with probability 0.</P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__param"></A>uniform_real_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__param_type"></A>uniform_real_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef uniform_real_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="uniform_real_distribution__reset"></A>uniform_real_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="uniform_real_distribution__result_type"></A>uniform_real_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="uniform_real_distribution__uniform_real_distribution"></A>uniform_real_distribution::uniform_real_distribution</CODE></H3>

<PRE>explicit <B>uniform_real_distribution</B>(result_type min0 = result_type(0.0),
    result_type max0 = result_type(1.0));
explicit <B>uniform_real_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>min0 &lt;= max0 &amp;&amp; max0 - min0 &lt;= numeric_limits&lt;RealType&gt;::max()</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_min</CODE>
holds the value <CODE>min0</CODE> and whose stored value <CODE>stored_max</CODE>
holds the value <CODE>max0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="variate_generator"></A>variate_generator</CODE></H2>

<PRE>template&lt;class Engine, class Dist&gt;
    class <B>variate_generator</B> { <B>[removed in final C++11]</B>
public:
    typedef Engine <B><A HREF="#variate_generator__engine_type">engine_type</A></B>;
    typedef <I>engine-return-type</I> <B><A HREF="#variate_generator__engine_value_type">engine_value_type</A></B>;
    typedef Dist <B><A HREF="#variate_generator__distribution_type">distribution_type</A></B>;
    typedef typename Dist::result_type <B><A HREF="#variate_generator__result_type">result_type</A></B>;

    <B><A HREF="#variate_generator__variate_generator">variate_generator</A></B>(engine_type eng0, distribution_type dist0);

    result_type <B><A HREF="#variate_generator__operator()">operator()</A></B>();
    template&lt;class T&gt;
        result_type <B><A HREF="#variate_generator__operator()">operator()</A></B>(T value);
    engine_value_type&amp; <B><A HREF="#variate_generator__engine">engine</A></B>();
    const engine_value_type&amp; <B><A HREF="#variate_generator__engine">engine</A></B>() const;
    distribution_type&amp; <B><A HREF="#variate_generator__distribution">distribution</A></B>();
    const distribution_type&amp; <B><A HREF="#variate_generator__distribution">distribution</A></B>() const;
    result_type <B><A HREF="#variate_generator__min">min</A></B>() const;
    result_type <B><A HREF="#variate_generator__max">max</A></B>() const;

private:
    Engine eng;             <I>// exposition only</I>
    Dist dist;              <I>// exposition only</I>
    };</PRE>

<P>The template class describes an object that holds an
<A HREF="lib_rand.html#engine">engine</A> and a
<A HREF="lib_rand.html#distribution">distribution</A> and produces values by
passing the <A HREF="#wrapped_engine">wrapped engine</A> object to the
<CODE>distribution</CODE> object's <CODE>operator()</CODE>.</P>

<P>The template argument <CODE>Engine</CODE> can be a type <CODE>Eng</CODE>,
<CODE>Eng*</CODE>, or <CODE>Eng&amp;</CODE>, where <CODE>Eng</CODE> is an
<A HREF="lib_rand.html#engine">engine</A>. The type <CODE>Eng</CODE> is
the <B><A NAME="underlying_engine_type"></A>underlying engine type</B>.
The corresponding object of type <CODE>Eng</CODE> is the
<B><A NAME="underlying_engine_object"></A>underlying engine object</B>.</P>

<P>The template uses a <B><A NAME="wrapped_engine"></A>wrapped engine</B> to match
the type of the values produced by the <CODE>engine</CODE> object to the type of
values required by the <CODE>distribution</CODE> object. The wrapped engine's
<CODE>operator()</CODE> returns values of type <CODE>Dist::input_type</CODE>,
generated as follows:</P>

<UL>
<LI>if <CODE>Engine::result_type</CODE> and <CODE>Dist::input_type</CODE> are both
integral types it returns <CODE>eng()</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> and <CODE>Dist::input_type</CODE> are both
floating-point types it returns <CODE>(eng() - eng.min()) / (eng.max() - eng.min())</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> is an integral type and <CODE>Dist::input_type</CODE>
is a floating-point type it returns <CODE>(eng() - eng.min()) / (eng.max() - eng.min() + 1)</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>

<LI>if <CODE>Engine::result_type</CODE> is a floating-point type and <CODE>Dist::input_type</CODE>
is an integral type it returns
<CODE>((eng() - eng.min()) / (eng.max() - eng.min()) * numeric_limits&lt;Dist::input_type&gt;::max()</CODE>,
converted to type <CODE>Dist::input_type</CODE>.</LI>
</UL>

<H3><CODE><A NAME="variate_generator__distribution"></A>variate_generator::distribution</CODE></H3>

<PRE>distribution_type&amp; <B>distribution</B>();
const distribution_type&amp; <B>distribution</B>() const;</PRE>

<P>The member functions return a reference to the stored distribution object <CODE>dist</CODE>.</P>

<H3><CODE><A NAME="variate_generator__distribution_type"></A>variate_generator::distribution_type</CODE></H3>

<PRE>typedef Dist <B>distribution_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Dist</CODE>.</P>

<H3><CODE><A NAME="variate_generator__engine"></A>variate_generator::engine</CODE></H3>

<PRE>engine_value_type <B>engine</B>();
const engine_value_type&amp; <B>engine</B>() const;</PRE>

<P>The member functions return a reference to the <A HREF="#underlying_engine_object">underlying engine object</A>.</P>

<H3><CODE><A NAME="variate_generator__engine_type"></A>variate_generator::engine_type</CODE></H3>

<PRE>typedef Engine <B>engine_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine</CODE>.</P>

<H3><CODE><A NAME="variate_generator__engine_value_type"></A>variate_generator::engine_value_type</CODE></H3>

<PRE>typedef <I>engine-value-type</I> <B>engine_value_type</B>;</PRE>

<P>The type is a synonym for the type of values returned by the
<A HREF="#underlying_engine_type">underlying engine type</A>.</P>

<H3><CODE><A NAME="variate_generator__max"></A>variate_generator::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns <CODE>dist.max()</CODE>.</P>

<H3><CODE><A NAME="variate_generator__min"></A>variate_generator::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns <CODE>dist.min()</CODE>.</P>

<H3><CODE><A NAME="variate_generator__operator()"></A>variate_generator::operator()</CODE></H3>

<PRE>result_type <B>operator</B>()();
template&lt;class T&gt;
    result_type <B>operator</B>()(T value);</PRE>

<P>The first member operator returns <CODE>dist(wr_eng)</CODE>, where <CODE>wr_eng</CODE>
is the object's <A HREF="#wrapped_engine">wrapped engine</A>.</P>

<P>The second member function returns <CODE>dist(wr_eng, value)</CODE>, where <CODE>wr_eng</CODE>
is the object's <A HREF="#wrapped_engine">wrapped engine</A>.</P>

<H3><CODE><A NAME="variate_generator__result_type"></A>variate_generator::result_type</CODE></H3>

<PRE>typedef typename Dist::result_type <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>Dist::result_type</CODE>.</P>

<H3><CODE><A NAME="variate_generator__variate_generator"></A>variate_generator::variate_generator</CODE></H3>

<PRE><B>variate_generator</B>(engine_type eng0, distribution_type dist0);</PRE>

<P>The constructor constructs an object whose stored value <CODE>eng</CODE>
holds <CODE>eng0</CODE> and whose stored value <CODE>dist</CODE> holds <CODE>dist0</CODE>.</P>

<H2><CODE><A NAME="weibull_distribution"></A>weibull_distribution</CODE></H2>

<PRE>template&lt;class RealType = double&gt;
    class <B>weibull_distribution</B> { <B>[added with C++11]</B>
public:
    typedef RealType <B><A HREF="#weibull_distribution__result_type">result_type</A></B>;
    struct <B><A HREF="#weibull_distribution__param_type">param_type</A></B>;

    explicit <B><A HREF="#weibull_distribution__weibull_distribution">weibull_distribution</A></B>(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    explicit <B><A HREF="#weibull_distribution__weibull_distribution">weibull_distribution</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#weibull_distribution__a">a</A></B>() const;
    result_type <B><A HREF="#weibull_distribution__b">b</A></B>() const;
    param_type <B><A HREF="#weibull_distribution__param">param</A></B>() const;
    void <B><A HREF="#weibull_distribution__param">param</A></B>(const param_type&amp; par0);

    result_type <B><A HREF="#weibull_distribution__min">min</A></B>() const;
    result_type <B><A HREF="#weibull_distribution__max">max</A></B>() const;
    void <B><A HREF="#weibull_distribution__reset">reset</A></B>();
    template&lt;class Engine&gt;
        result_type <B><A HREF="#weibull_distribution__operator()">operator()</A></B>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <B><A HREF="#weibull_distribution__operator()">operator()</A></B>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <B>stored_a</B>;  <I>// exposition only</I>
    result_type <B>stored_b</B>;  <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#distribution">distribution</A>
that produces values of a user-specified floating-point type
distributed with a Weibull distribution.</P>

<H3><CODE><A NAME="weibull_distribution__a"></A>weibull_distribution::a</CODE></H3>

<PRE>result_type <B>a</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_a</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__b"></A>weibull_distribution::b</CODE></H3>

<PRE>result_type <B>b</B>() const;</PRE>

<P>The member function returns the stored value <CODE>stored_b</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__max"></A>weibull_distribution::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__min"></A>weibull_distribution::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value returnable by
<CODE>operator()</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__operator()"></A>weibull_distribution::operator()</CODE></H3>

<PRE>template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <B>operator()</B>(Engine&amp; eng,
        const param_type&amp; par0);</PRE>

<P>The first member operator uses the <A HREF="lib_rand.html#engine">engine</A> <CODE>eng</CODE>
as a source of uniformly distributed random integral values and returns
floating-point values with each value <CODE>x</CODE> occurring with probability:</P>

<P><IMG SRC="weibull_distribution.gif"></P>

<P>The second member function behaves the same, except that it uses the parameters
stored in <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__param"></A>weibull_distribution::param</CODE></H3>

<PRE>param_type <B>param</B>() const;
void <B>param</B>(const param_type&amp; par0);</PRE>

<P>The first member function returns and object that stores
all the parameters of the distribution. The second member function
initializes all the parameters from <CODE>par0</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__param_type"></A>weibull_distribution::param_type</CODE></H3>

<PRE>struct <B>param_type</B> {
    typedef weibull_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };</PRE>

<P>The type is a class that can store all the parameters of the distribution.</P>

<H3><CODE><A NAME="weibull_distribution__reset"></A>weibull_distribution::reset</CODE></H3>

<PRE>void <B>reset</B>();</PRE>

<P>The member function discards any stored values in the generated sequence.</P>

<H3><CODE><A NAME="weibull_distribution__result_type"></A>weibull_distribution::result_type</CODE></H3>

<PRE>typedef RealType <B>result_type</B>;</PRE>

<P>The type is a synonym for <CODE>RealType</CODE>.</P>

<H3><CODE><A NAME="weibull_distribution__weibull_distribution"></A>weibull_distribution::weibull_distribution</CODE></H3>

<PRE><B>weibull_distribution</B>(result_type a0 = result_type(1.0),
    result_type b0 = result_type(1.0));
explicit <B>weibull_distribution</B>(const param_type&amp; par0);</PRE>

<P><A HREF="lib_rand.html#Precondition">Precondition:</A> <CODE>0.0 &lt; a0 &amp;&amp; 0.0 &lt; b0</CODE></P>

<P>The first constructor constructs an object whose stored value <CODE>stored_a</CODE>
holds the value <CODE>a0</CODE> and whose stored value <CODE>stored_b</CODE> holds
the value <CODE>b0</CODE>.</P>

<P>The second constructor constructs an object whose stored parameters
are initialized from <CODE>par0</CODE>.</P>

<H2><CODE><A NAME="xor_combine"></A>xor_combine</CODE></H2>

<PRE>template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <B>xor_combine</B> { <B>[removed in final C++11]</B>
public:
    typedef Engine1 <B><A HREF="#xor_combine__base1_type">base1_type</A></B>;
    typedef Engine2 <B><A HREF="#xor_combine__base2_type">base2_type</A></B>;
    typedef T1 <B><A HREF="#xor_combine__result_type">result_type</A></B>;

    static constexpr int <B><A HREF="#xor_combine__shift1">shift1</A></B> = S1;
    static constexpr int <B><A HREF="#xor_combine__shift2">shift2</A></B> = S2;

    <B><A HREF="#xor_combine__xor_combine">xor_combine</A></B>();
    <B><A HREF="#xor_combine__xor_combine">xor_combine</A></B>(result_type x0);
    <B><A HREF="#xor_combine__xor_combine">xor_combine</A></B>(const base1_type&amp; eng1, const base2_type&amp; eng2);
    template&lt;class Gen&gt;
        <B><A HREF="#xor_combine__xor_combine">xor_combine</A></B>(Gen&amp; gen);
    void <B><A HREF="#xor_combine__seed">seed</A></B>();
    template&lt;class Gen&gt;
        void <B><A HREF="#xor_combine__seed">seed</A></B>(Gen&amp; gen);

    const base1_type&amp; <B><A HREF="#xor_combine__base1">base1</A></B>() const;
    const base2_type&amp; <B><A HREF="#xor_combine__base2">base2</A></B>() const;
    result_type <B><A HREF="#xor_combine__min">min</A></B>() const;
    result_type <B><A HREF="#xor_combine__max">max</A></B>() const;
    result_type <B><A HREF="#xor_combine__operator()">operator()</A></B>();

private:
    base1_type stored_eng1;     <I>// exposition only</I>
    base2_type stored_eng2;     <I>// exposition only</I>
    };</PRE>

<P>The template class describes a <A HREF="lib_rand.html#compound_engine">compound engine</A>
that produces values by combining values produced by two engines. The engine's
<A HREF="lib_rand.html#state">state</A> is the state of <CODE>stored_eng1</CODE>
followed by the state of <CODE>stored_eng2</CODE>.</P>

<H3><CODE><A NAME="xor_combine__base1"></A>xor_combine::base1</CODE></H3>

<PRE>const base1_type&amp; <B>base1</B>() const;</PRE>

<P>The member function returns a reference to the stored value <CODE>stored_eng1</CODE>.</P>

<H3><CODE><A NAME="xor_combine__base1_type"></A>xor_combine::base1_type</CODE></H3>

<PRE>typedef Engine1 <B>base1_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine1</CODE>.</P>

<H3><CODE><A NAME="xor_combine__base2"></A>xor_combine::base2</CODE></H3>

<PRE>const base2_type&amp; <B>base2</B>() const;</PRE>

<P>The member function returns a reference to the stored value <CODE>stored_eng2</CODE>.</P>

<H3><CODE><A NAME="xor_combine__base2_type"></A>xor_combine::base2_type</CODE></H3>

<PRE>typedef Engine1 <B>base2_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Engine2</CODE>.</P>

<H3><CODE><A NAME="xor_combine__max"></A>xor_combine::max</CODE></H3>

<PRE>result_type <B>max</B>() const;</PRE>

<P>The member function returns the largest value in the generated sequence.</P>

<H3><CODE><A NAME="xor_combine__min"></A>xor_combine::min</CODE></H3>

<PRE>result_type <B>min</B>() const;</PRE>

<P>The member function returns the smallest value in the generated sequence.</P>

<H3><CODE><A NAME="xor_combine__operator()"></A>operator()</CODE></H3>

<PRE>result_type <B>operator()</B>();</PRE>

<P>The member operator returns <CODE>(stored_eng1() &lt;&lt; shift1) ^ (stored_eng2() &lt;&lt; shift2)</CODE>.</P>

<H3><CODE><A NAME="xor_combine__result_type"></A>xor_combine::result_type</CODE></H3>

<PRE>typedef T1 <B>result_type</B>;</PRE>

<P>The type is a synonym for the unnamed type <CODE>T1</CODE>,
which is either <CODE>Engine1::result_type</CODE>
or <CODE>Engine2::result_type</CODE>, whichever has the larger range of
values.</P>

<H3><CODE><A NAME="xor_combine__seed"></A>xor_combine::seed</CODE></H3>

<PRE>void <B>seed</B>();
template&lt;class Gen&gt;
    void <B>seed</B>(Gen&amp; gen);</PRE>

<P>The first <A HREF="lib_rand.html#seed_function">seed function</A>
calls <CODE>stored_eng1.seed()</CODE> and then calls
<CODE>stored_eng2.seed()</CODE>. The second seed function calls
<CODE>stored_eng1.seed(gen)</CODE> and then calls
<CODE>stored_eng2.seed(gen)</CODE>.</P>

<H3><CODE><A NAME="xor_combine__shift1"></A>xor_combine::shift1</CODE></H3>

<PRE>static constexpr int <B>shift1</B> = S1;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S1</CODE>.</P>

<H3><CODE><A NAME="xor_combine__shift2"></A>xor_combine::shift2</CODE></H3>

<PRE>static constexpr int <B>shift2</B> = S2;</PRE>

<P>The static const variable holds the value of the template argument <CODE>S2</CODE>.</P>

<H3><CODE><A NAME="xor_combine__xor_combine"></A>xor_combine::xor_combine</CODE></H3>

<PRE><B>xor_combine</B>();
<B>xor_combine</B>(result_type x0);
<B>xor_combine</B>(const base1_type&amp; eng1, const base2_type&amp; eng2);
template&lt;class Gen&gt;
    <B>xor_combine</B>(Gen&amp; gen);</PRE>

<P>The first constructor constructs an object with stored values <CODE>stored_eng1</CODE>
and <CODE>stored_eng2</CODE> constructed with their respective default constructors.
The second constructor constructs an object with stored values <CODE>stored_eng1</CODE>
and <CODE>stored_eng2</CODE> constructed with <CODE>x0</CODE> and <CODE>x0 + 1</CODE>,
respectively.
The third constructor constructs an object whose stored value <CODE>stored_eng1</CODE>
holds a copy of <CODE>eng1</CODE> and whose stored value <CODE>stored_eng2</CODE>
holds a copy of <CODE>eng2</CODE>.
The fourth constructor constructs an object and calls <CODE>seed(gen)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by Dinkumware, Ltd. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
