<HTML><HEAD>
<TITLE>&lt;wchar.h&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;wchar.h&gt;"></A><CODE>&lt;wchar.h&gt;</CODE></H1>

<P>[added with
Amendment 1]</P><HR>

<P><B><CODE><A HREF="#NULL">NULL</A>
&middot; <A HREF="#WCHAR_MAX">WCHAR_MAX</A>
&middot; <A HREF="#WCHAR_MIN">WCHAR_MIN</A>
&middot; <A HREF="#WEOF">WEOF</A>
</CODE></B></P>

<P><B><CODE><A HREF="#btowc">btowc</A>
&middot; <A HREF="#fgetwc">fgetwc</A>
&middot; <A HREF="#fgetws">fgetws</A>
&middot; <A HREF="#fputwc">fputwc</A>
&middot; <A HREF="#fputws">fputws</A>
&middot; <A HREF="#fwide">fwide</A>
&middot; <A HREF="#fwprintf">fwprintf</A>
&middot; <A HREF="#fwscanf">fwscanf</A>
&middot; <A HREF="#getwc">getwc</A>
&middot; <A HREF="#getwchar">getwchar</A>
&middot; <A HREF="#mbrlen">mbrlen</A>
&middot; <A HREF="#mbrtowc">mbrtowc</A>
&middot; <A HREF="#mbsinit">mbsinit</A>
&middot; <A HREF="#mbsrtowcs">mbsrtowcs</A>
&middot; <A HREF="#mbstate_t">mbstate_t</A>
&middot; <A HREF="#putwc">putwc</A>
&middot; <A HREF="#putwchar">putwchar</A>
&middot; <A HREF="#size_t">size_t</A>
&middot; <A HREF="#swprintf">swprintf</A>
&middot; <A HREF="#swscanf">swscanf</A>
&middot; <A HREF="#tm">tm</A>
&middot; <A HREF="#ungetwc">ungetwc</A>
&middot; <A HREF="#vfwprintf">vfwprintf</A>
&middot; <A HREF="#vfwscanf">vfwscanf</A>
&middot; <A HREF="#vswprintf">vswprintf</A>
&middot; <A HREF="#vswscanf">vswscanf</A>
&middot; <A HREF="#vwprintf">vwprintf</A>
&middot; <A HREF="#vwscanf">vwscanf</A>
&middot; <A HREF="#wchar_t">wchar_t</A>
&middot; <A HREF="#wcrtomb">wcrtomb</A>
&middot; <A HREF="#wcscat">wcscat</A>
&middot; <A HREF="#wcschr">wcschr</A>
&middot; <A HREF="#wcscmp">wcscmp</A>
&middot; <A HREF="#wcscoll">wcscoll</A>
&middot; <A HREF="#wcscpy">wcscpy</A>
&middot; <A HREF="#wcscspn">wcscspn</A>
&middot; <A HREF="#wcsftime">wcsftime</A>
&middot; <A HREF="#wcslen">wcslen</A>
&middot; <A HREF="#wcsncat">wcsncat</A>
&middot; <A HREF="#wcsncmp">wcsncmp</A>
&middot; <A HREF="#wcsncpy">wcsncpy</A>
&middot; <A HREF="#wcspbrk">wcspbrk</A>
&middot; <A HREF="#wcsrchr">wcsrchr</A>
&middot; <A HREF="#wcsrtombs">wcsrtombs</A>
&middot; <A HREF="#wcsspn">wcsspn</A>
&middot; <A HREF="#wcsstr">wcsstr</A>
&middot; <A HREF="#wcstod">wcstod</A>
&middot; <A HREF="#wcstof">wcstof</A>
&middot; <A HREF="#wcstok">wcstok</A>
&middot; <A HREF="#wcstold">wcstold</A>
&middot; <A HREF="#wcstol">wcstol</A>
&middot; <A HREF="#wcstoll">wcstoll</A>
&middot; <A HREF="#wcstoul">wcstoul</A>
&middot; <A HREF="#wcstoull">wcstoull</A>
&middot; <A HREF="#wcsxfrm">wcsxfrm</A>
&middot; <A HREF="#wctob">wctob</A>
&middot; <A HREF="#wint_t">wint_t</A>
&middot; <A HREF="#wmemchr">wmemchr</A>
&middot; <A HREF="#wmemcmp">wmemcmp</A>
&middot; <A HREF="#wmemcpy">wmemcpy</A>
&middot; <A HREF="#wmemmove">wmemmove</A>
&middot; <A HREF="#wmemset">wmemset</A>
&middot; <A HREF="#wprintf">wprintf</A>
&middot; <A HREF="#wscanf">wscanf</A>
</CODE></B></P>

<P><B><CODE><A HREF="#errno_t">errno_t</A>
&middot; <A HREF="#fwprintf_s">fwprintf_s</A>
&middot; <A HREF="#fwscanf_s">fwscanf_s</A>
&middot; <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>
&middot; <A HREF="#rsize_t">rsize_t</A>
&middot; <A HREF="#snwprintf_s">snwprintf_s</A>
&middot; <A HREF="#swprintf_s">swprintf_s</A>
&middot; <A HREF="#swscanf_s">swscanf_s</A>
&middot; <A HREF="#vfwprintf_s">vfwprintf_s</A>
&middot; <A HREF="#vfwscanf_s">vfwscanf_s</A>
&middot; <A HREF="#vsnwprintf_s">vsnwprintf_s</A>
&middot; <A HREF="#vswprintf_s">vswprintf_s</A>
&middot; <A HREF="#vswscanf_s">vswscanf_s</A>
&middot; <A HREF="#vwprintf_s">vwprintf_s</A>
&middot; <A HREF="#vwscanf_s">vwscanf_s</A>
&middot; <A HREF="#wcrtomb_s">wcrtomb_s</A>
&middot; <A HREF="#wcscat_s">wcscat_s</A>
&middot; <A HREF="#wcscpy_s">wcscpy_s</A>
&middot; <A HREF="#wcsncat_s">wcsncat_s</A>
&middot; <A HREF="#wcsncpy_s">wcsncpy_s</A>
&middot; <A HREF="#wcsnlen_s">wcsnlen_s</A>
&middot; <A HREF="#wcsrtombs_s">wcsrtombs_s</A>
&middot; <A HREF="#wcstok_s">wcstok_s</A>
&middot; <A HREF="#wmemcpy_s">wmemcpy_s</A>
&middot; <A HREF="#wmemmove_s">wmemmove_s</A>
&middot; <A HREF="#wprintf_s">wprintf_s</A>
&middot; <A HREF="#wscanf_s">wscanf_s</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;wchar.h&gt;</CODE></B>
so that you can perform input and output operations on
wide streams or manipulate wide strings.</P>

<PRE>    /* MACROS */
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#WCHAR_MAX"><B>WCHAR_MAX</B></A> <I>&lt;#if expression &gt;= 127&gt;</I>
#define <A HREF="#WCHAR_MIN"><B>WCHAR_MIN</B></A> <I>&lt;#if expression &lt;= 0&gt;</I>
#define <A HREF="#WEOF"><B>WEOF</B></A> <I>&lt;</I>wint_t <I>constant expression&gt;</I>

    /* TYPES */
typedef <I>o-type</I> <A HREF="#mbstate_t"><B>mbstate_t</B></A>;
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;
typedef <I>i-type</I> <A HREF="#wchar_t"><B>wchar_t</B></A>; <B>[keyword in C++]</B>
typedef <I>i_type</I> <A HREF="#wint_t"><B>wint_t</B></A>;
struct <A HREF="#tm"><B>tm</B></A>;

    /* FUNCTIONS */
wint_t <A HREF="#fgetwc"><B>fgetwc</B></A>(FILE *stream);
wchar_t *<A HREF="#fgetws"><B>fgetws</B></A>(wchar_t *restrict s, int n, FILE *restrict stream);
wint_t <A HREF="#fputwc"><B>fputwc</B></A>(wchar_t c, FILE *stream);
int <A HREF="#fputws"><B>fputws</B></A>(const wchar_t *restrict s, FILE *restrict stream);
int <A HREF="#fwide"><B>fwide</B></A>(FILE *stream, int mode);
wint_t <A HREF="#getwc"><B>getwc</B></A>(FILE *stream);
wint_t <A HREF="#getwchar"><B>getwchar</B></A>(void);
wint_t <A HREF="#putwc"><B>putwc</B></A>(wchar_t c, FILE *stream);
wint_t <A HREF="#putwchar"><B>putwchar</B></A>(wchar_t c);
wint_t <A HREF="#ungetwc"><B>ungetwc</B></A>(wint_t c, FILE *stream);

int <A HREF="#fwscanf"><B>fwscanf</B></A>(FILE *restrict stream, const wchar_t *restrict format, ...);
int <A HREF="#swscanf"><B>swscanf</B></A>(const wchar_t *restrict s,
    const wchar_t *restrict format, ...);
int <A HREF="#wscanf"><B>wscanf</B></A>(const wchar_t *restrict format, ...);
int <A HREF="#fwprintf"><B>fwprintf</B></A>(FILE *restrict stream, const wchar_t *restrict format, ...);
int <A HREF="#swprintf"><B>swprintf</B></A>(wchar_t *restrict s, size_t n,
    const wchar_t *restrict format, ...);
int <A HREF="#wprintf"><B>wprintf</B></A>(const wchar_t *restrict format, ...);
int <A HREF="#vfwscanf"><B>vfwscanf</B></A>(FILE *restrict stream, const wchar_t *restrict format,
    va_list arg); <B>[added with C99]</B>
int <A HREF="#vswscanf"><B>vswscanf</B></A>(const wchar_t *restrict s, const wchar_t *restrict format,
    va_list arg); <B>[added with C99]</B>
int <A HREF="#vwscanf"><B>vwscanf</B></A>(const wchar_t *restrict format,
    va_list arg); <B>[added with C99]</B>
int <A HREF="#vfwprintf"><B>vfwprintf</B></A>(FILE *restrict stream, const wchar_t *restrict format,
    va_list arg);
int <A HREF="#vswprintf"><B>vswprintf</B></A>(wchar_t *restrict s, size_t n, const wchar_t *restrict format,
    va_list arg);
int <A HREF="#vwprintf"><B>vwprintf</B></A>(const wchar_t *restrict format,
    va_list arg);

size_t <A HREF="#wcsftime"><B>wcsftime</B></A>(wchar_t *restrict s, size_t maxsize,
    const wchar_t *restrict format, const struct tm *restrict timeptr);

wint_t <A HREF="#btowc"><B>btowc</B></A>(int c);
size_t <A HREF="#mbrlen"><B>mbrlen</B></A>(const char *restrict s, size_t n,
    mbstate_t *restrict ps);
size_t <A HREF="#mbrtowc"><B>mbrtowc</B></A>(wchar_t *restrict pwc, const char *restrict s,
    size_t n, mbstate_t *restrict ps);
int <A HREF="#mbsinit"><B>mbsinit</B></A>(const mbstate_t *ps);
size_t <A HREF="#mbsrtowcs"><B>mbsrtowcs</B></A>(wchar_t *restrict dst, const char **restrict src,
    size_t len, mbstate_t *restrict ps);
size_t <A HREF="#wcrtomb"><B>wcrtomb</B></A>(char *restrict s, wchar_t wc,
    mbstate_t *restrict ps);
size_t <A HREF="#wcsrtombs"><B>wcsrtombs</B></A>(char *restrict dst, const wchar_t **restrict src,
    size_t len, mbstate_t *restrict ps);
double <A HREF="#wcstod"><B>wcstod</B></A>(const wchar_t *restrict nptr,
    wchar_t **restrict endptr);
float <A HREF="#wcstof"><B>wcstof</B></A>(const wchar_t *restrict nptr,
    wchar_t **restrict endptr); <B>[added with C99]</B>
long double <A HREF="#wcstold"><B>wcstold</B></A>(const wchar_t *restrict nptr,
    wchar_t **restrict endptr); <B>[added with C99]</B>
long long <A HREF="#wcstoll"><B>wcstoll</B></A>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base); <B>[added with C99]</B>
unsigned long long <A HREF="#wcstoull"><B>wcstoull</B></A>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base); <B>[added with C99]</B>
long <A HREF="#wcstol"><B>wcstol</B></A>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base);
unsigned long <A HREF="#wcstoul"><B>wcstoul</B></A>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base);
int <A HREF="#wctob"><B>wctob</B></A>(wint_t c);

wchar_t *<A HREF="#wcscat"><B>wcscat</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2);
int <A HREF="#wcscmp"><B>wcscmp</B></A>(const wchar_t *s1, const wchar_t *s2);
int <A HREF="#wcscoll"><B>wcscoll</B></A>(const wchar_t *s1, const wchar_t *s2);
wchar_t *<A HREF="#wcscpy"><B>wcscpy</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2);
size_t <A HREF="#wcscspn"><B>wcscspn</B></A>(const wchar_t *s1, const wchar_t *s2);
size_t <A HREF="#wcslen"><B>wcslen</B></A>(const wchar_t *s);
wchar_t *<A HREF="#wcsncat"><B>wcsncat</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);
int <A HREF="#wcsncmp"><B>wcsncmp</B></A>(const wchar_t *s1, const wchar_t *s2,
    size_t n);
wchar_t *<A HREF="#wcsncpy"><B>wcsncpy</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);
size_t <A HREF="#wcsspn"><B>wcsspn</B></A>(const wchar_t *s1, const wchar_t *s2);
wchar_t *<A HREF="#wcsstr"><B>wcsstr</B></A>(const wchar_t *s1, const wchar_t *s2);
wchar_t *<A HREF="#wcstok"><B>wcstok</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2,
    wchar_t **restrict ptr);
size_t <A HREF="#wcsxfrm"><B>wcsxfrm</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2, size_t n);
int <A HREF="#wmemcmp"><B>wmemcmp</B></A>(const wchar_t *s1, const wchar_t *s2,
    size_t n);
wchar_t *<A HREF="#wmemcpy"><B>wmemcpy</B></A>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);
wchar_t *<A HREF="#wmemmove"><B>wmemmove</B></A>(wchar_t *s1, const wchar_t *s2,
    size_t n);
wchar_t *<A HREF="#wmemset"><B>wmemset</B></A>(wchar_t *s, wchar_t c, size_t n);

wchar_t *<A HREF="#wcschr"><B>wcschr</B></A>(const wchar_t *s, wchar_t c); <B>[not in C++]</B>
const wchar_t *<A HREF="#wcschr"><B>wcschr</B></A>(const wchar_t *s, wchar_t c); <B>[C++ only]</B>
wchar_t *<A HREF="#wcschr"><B>wcschr</B></A>(wchar_t *s, wchar_t c); <B>[C++ only]</B>

wchar_t *<A HREF="#wcspbrk"><B>wcspbrk</B></A>(const wchar_t *s1, const wchar_t *s2); <B>[not in C++]</B>
const wchar_t *<A HREF="#wcspbrk"><B>wcspbrk</B></A>(const wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>
wchar_t *<A HREF="#wcspbrk"><B>wcspbrk</B></A>(wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>

wchar_t *<A HREF="#wcsrchr"><B>wcsrchr</B></A>(const wchar_t *s, wchar_t c); <B>[not in C++]</B>
const wchar_t *<A HREF="#wcsrchr"><B>wcsrchr</B></A>(const wchar_t *s, wchar_t c); <B>[C++ only]</B>
wchar_t *<A HREF="#wcsrchr"><B>wcsrchr</B></A>(wchar_t *s, wchar_t c); <B>[C++ only]</B>

wchar_t *<A HREF="#wcsstr"><B>wcsstr</B></A>(const wchar_t *s1, const wchar_t *s2); <B>[not in C++]</B>
const wchar_t *<A HREF="#wcsstr"><B>wcsstr</B></A>(const wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>
wchar_t *<A HREF="#wcsstr"><B>wcsstr</B></A>(wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>

wchar_t *<A HREF="#wmemchr"><B>wmemchr</B></A>(const wchar_t *s, wchar_t c,
    size_t n); <B>[not in C++]</B>
const wchar_t *<A HREF="#wmemchr"><B>wmemchr</B></A>(const wchar_t *s, wchar_t c,
    size_t n); <B>[C++ only]</B>
wchar_t *<A HREF="#wmemchr"><B>wmemchr</B></A>(wchar_t *s, wchar_t c,
    size_t n); <B>[C++ only]</B>

#if __STDC_WANT_LIB_EXT1__ <B>[added with <A HREF="index_ext1.html#TR24731">TR24731</A>]</B>
typedef int <A HREF="#errno_t"><B>errno_t</B></A>;
typedef size_t <A HREF="#rsize_t"><B>rsize_t</B></A>;

int <A HREF="#fwprintf_s"><B>fwprintf_s</B></A>(_Filet *restrict stream,
    const wchar_t *restrict format, ...);
int <A HREF="#fwscanf_s"><B>fwscanf_s</B></A>(_Filet *restrict stream,
    const wchar_t *restrict format, ...);
int <A HREF="#snwprintf_s"><B>snwprintf_s</B></A>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format, ...);
int <A HREF="#swprintf_s"><B>swprintf_s</B></A>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format, ...);
int <A HREF="#swscanf_s"><B>swscanf_s</B></A>(const wchar_t *restrict s,
    const wchar_t *restrict format, ...);
int <A HREF="#vfwprintf_s"><B>vfwprintf_s</B></A>(_Filet *restrict stream,
    const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vfwscanf_s"><B>vfwscanf_s</B></A>(_Filet *restrict stream,
    const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vsnwprintf_s"><B>vsnwprintf_s</B></A>(wchar_t *restrict s, rsize_t m,
    const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vswprintf_s"><B>vswprintf_s</B></A>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vswscanf_s"><B>vswscanf_s</B></A>(const wchar_t *restrict s,
    const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vwprintf_s"><B>vwprintf_s</B></A>(const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#vwscanf_s"><B>vwscanf_s</B></A>(const wchar_t *restrict format,
    _Va_list arg);
int <A HREF="#wprintf_s"><B>wprintf_s</B></A>(const wchar_t *restrict format, ...);
int <A HREF="#wscanf_s"><B>wscanf_s</B></A>(const wchar_t *restrict format, ...);

errno_t <A HREF="#wcscpy_s"><B>wcscpy_s</B></A>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2);
errno_t <A HREF="#wcsncpy_s"><B>wcsncpy_s</B></A>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2, rsize_t n);
errno_t <A HREF="#wmemcpy_s"><B>wmemcpy_s</B></A>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2, rsize_t n);
errno_t <A HREF="#wmemmove_s"><B>wmemmove_s</B></A>(wchar_t * s1, rsize_t maxsize,
    const wchar_t *s2, rsize_t n);
errno_t <A HREF="#wcscat_s"><B>wcscat_s</B></A>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2);
errno_t <A HREF="#wcsncat_s"><B>wcsncat_s</B></A>(wchar_t *restrict, rsize_t,
    const wchar_t *restrict, rsize_t);
wchar_t *<A HREF="#wcstok_s"><B>wcstok_s</B></A>(wchar_t *restrict s1, rsize_t *restrict psize1,
    const wchar_t *restrict s2, wchar_t **restrict pbuf1);

size_t <A HREF="#wcsnlen_s"><B>wcsnlen_s</B></A>(const wchar_t *s, size_t maxsize);

errno_t <A HREF="#wcrtomb_s"><B>wcrtomb_s</B></A>(size_t *restrict psize,
    char *restrict s, rsize_t maxsize,
    wchar_t wc,
    mbstate_t *restrict ps);
errno_t <A HREF="#mbsrtowcs_s"><B>mbsrtowcs_s</B></A>(size_t *restrict psize,
    wchar_t *restrict dst, rsize_t maxsize,
    const char **restrict src, rsize_t len,
    mbstate_t *restrict ps);
errno_t <A HREF="#wcsrtombs_s"><B>wcsrtombs_s</B></A>(size_t *restrict psize,
    char *restrict dst, rsize_t maxsize,
    const wchar_t **restrict src, rsize_t len,
    mbstate_t *restrict ps);
#endif /* __STDC_WANT_LIB_EXT1__ */</PRE>


<H2><A NAME="btowc"></A><CODE>btowc</CODE></H2>

<PRE>wint_t <B>btowc</B>(int c);</PRE>

<P>The function returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A> if <CODE>c</CODE> equals
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A>.
Otherwise, it converts <CODE>(unsigned char)c</CODE>
as a one-byte multibyte character beginning in the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>,
as if by calling
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>.
If the conversion succeeds, the function returns the wide-character
conversion. Otherwise, it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>.</P>

<H2><A NAME="errno_t"></A><CODE>errno_t</CODE></H2>

<PRE>typedef int <B>errno_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <I>int,</I> used to represent
a value that can be stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="fgetwc"></A><CODE>fgetwc</CODE></H2>

<PRE>wint_t <B>fgetwc</B>(FILE *stream);</PRE>

<P>The function reads the next wide character <CODE>c</CODE> (if present)
from the input stream <CODE>stream</CODE>,
advances the file-position indicator (if defined), and returns
<CODE>(<A HREF="#wint_t">wint_t</A>)c</CODE>.
If the function sets either the end-of-file indicator
or the error indicator, it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>.</P>

<H2><A NAME="fgetws"></A><CODE>fgetws</CODE></H2>

<PRE>wchar_t *<B>fgetws</B>(wchar_t *restrict s, int n, FILE *restrict stream);</PRE>

<P>The function reads wide characters
from the input stream <CODE>stream</CODE>
and stores them in successive elements of the array
beginning at <CODE>s</CODE> and continuing until it stores
<CODE>n - 1</CODE> wide characters, stores an <CODE><I>NL</I></CODE>
wide character, or sets the end-of-file or error indicators. If
<CODE>fgetws</CODE> stores any wide characters, it concludes by storing
a null wide character in the next element of the array. It returns
<CODE>s</CODE> if it stores any wide characters and it has not set the error
indicator for the stream; otherwise, it returns a null pointer. If
it sets the error indicator, the array contents are indeterminate.</P>

<H2><A NAME="fputwc"></A><CODE>fputwc</CODE></H2>

<PRE>wint_t <B>fputwc</B>(wchar_t c, FILE *stream);</PRE>

<P>The function writes the wide character <CODE>c</CODE> to the output
stream <CODE>stream</CODE>, advances the file-position indicator
(if defined), and returns
<CODE>(<A HREF="#wint_t">wint_t</A>)c</CODE>.
If the function sets the error indicator for the stream, it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>.</P>

<H2><A NAME="fputws"></A><CODE>fputws</CODE></H2>

<PRE>int <B>fputws</B>(const wchar_t *restrict s, FILE *restrict stream);</PRE>

<P>The function accesses wide characters from the wide string <CODE>s</CODE>
and writes them to the output stream <CODE>stream</CODE>. The function does
not write the terminating null wide character. It returns a nonnegative
value if it has not set the error indicator; otherwise, it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>.</P>

<H2><A NAME="fwide"></A><CODE>fwide</CODE></H2>

<PRE>int <B>fwide</B>(FILE *stream, int mode);</PRE>

<P>The function determines the orientation of the stream <CODE>stream</CODE>.
If <CODE>mode</CODE> is greater than zero,
it first attempts to make the stream
<A HREF="lib_file.html#wide_oriented">wide oriented</A>.
If <CODE>mode</CODE> is less than zero,
it first attempts to make the stream
<A HREF="lib_file.html#byte_oriented">byte oriented</A>.
In any event, the function returns:</P>

<UL>
<LI>a value greater than zero if the stream is left
<A HREF="lib_file.html#wide_oriented">wide oriented</A></LI>

<LI>zero if the stream is left
<A HREF="lib_file.html#unbound_stream">unbound</A></LI>

<LI>a value less than zero if the stream is left
<A HREF="lib_file.html#byte_oriented">byte oriented</A></LI>
</UL>

<P>In no event will the function alter the orientation of a stream
once it has been oriented.</P>

<H2><A NAME="fwprintf"></A><CODE>fwprintf</CODE></H2>

<PRE>int <B>fwprintf</B>(FILE *restrict stream, const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream <CODE>stream</CODE>. It returns
the number of wide characters generated, or it returns a negative
value if the function sets the error indicator for the stream.</P>

<H2><A NAME="fwprintf_s"></A><CODE>fwprintf_s</CODE></H2>

<PRE>int <B>fwprintf_s</B>(FILE *restrict stream,
    const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream <CODE>stream</CODE>.
It returns the
number of wide characters generated, or it returns a negative value if
the function sets the error indicator for the stream.</P>

<H2><A NAME="fwscanf"></A><CODE>fwscanf</CODE></H2>

<PRE>int <B>fwscanf</B>(FILE *restrict stream, const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream <CODE>stream</CODE>.
It returns the number
of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<H2><A NAME="fwscanf_s"></A><CODE>fwscanf_s</CODE></H2>

<PRE>int <B>fwscanf_s</B>(FILE *restrict stream,
    const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream <CODE>stream</CODE>.
It returns the number
of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P><B><A NAME="additional_scan_checking"></A>Additional checking</B>
occurs for the scan conversion specifiers <CODE>c</CODE>, <CODE>s</CODE>,
and <CODE>[</CODE>. Each of these conversion specifiers consumes an
additional argument, of type
<CODE><A HREF="#rsize_t">rsize_t</A></CODE>, that specifies the maximum
number of elements <CODE>N</CODE> that can be stored in the array object.
It is a runtime constraint violation if <CODE>N</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>, or if
the number of elements to be stored is greater than <CODE>N</CODE>.</P>

<H2><A NAME="getwc"></A><CODE>getwc</CODE></H2>

<PRE>wint_t <B>getwc</B>(FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetwc">fgetwc</A>(stream)</CODE> except
that a macro version of <CODE>getwc</CODE> can evaluate
<CODE>stream</CODE> more than once.</P>

<H2><A NAME="getwchar"></A><CODE>getwchar</CODE></H2>

<PRE>wint_t <B>getwchar</B>(void);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetwc">fgetwc</A>(stdin)</CODE>.</P>

<H2><A NAME="mbrlen"></A><CODE>mbrlen</CODE></H2>

<PRE>size_t <B>mbrlen</B>(const char *restrict s, size_t n, mbstate_t *restrict ps);</PRE>

<P>The function is equivalent to the call:</P>

<PRE><A HREF="#mbrtowc">mbrtowc</A>(0, s, n, ps != 0 ? ps : &amp;internal)</PRE>

<P>where <CODE>internal</CODE> is an object of type
<A HREF="#mbstate_t"><CODE>mbstate_t</CODE></A>
internal to the <CODE>mbrlen</CODE> function. At
<A HREF="lib_over.html#program_startup">program startup</A>,
<CODE>internal</CODE> is initialized to the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
No other library function
alters the value stored in <CODE>internal</CODE>.</P>

<P>The function returns:</P>

<UL>
<LI><CODE>(<A HREF="#size_t">size_t</A>)-3</CODE> if
no additional bytes are needed to complete the next multibyte character,
in which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that no additional bytes have been converted and the next
multibyte character has been produced</LI>

<LI><CODE>(<A HREF="#size_t">size_t</A>)-2</CODE> if,
after converting all <CODE>n</CODE> characters, the resulting
<A HREF="charset.html#conversion_state">conversion state</A>
indicates an incomplete multibyte character</LI>

<LI><CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>
if the function detects an encoding error
before completing the next multibyte character, in which case the
function stores the value
<A HREF="errno.html#EILSEQ"><CODE>EILSEQ</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and leaves the resulting
<A HREF="charset.html#conversion_state">conversion state</A> undefined</LI>

<LI>zero, if the next completed character is a null character, in
which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> is the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A></LI>

<LI><CODE>x</CODE>, the number of bytes needed to complete the next multibyte
character, in which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that <CODE>x</CODE> bytes have been converted and the next
multibyte character has been produced</LI>
</UL>

<P>Thus, <CODE>mbrlen</CODE> effectively returns the number of bytes
that would be consumed in successfully converting a multibyte character
to a wide character (without storing the converted wide character),
or an error code if the conversion cannot succeed.</P>

<P>The function is not necessarily thread safe if
<CODE>ps</CODE> is a null pointer.</P>

<H2><A NAME="mbrtowc"></A><CODE>mbrtowc</CODE></H2>

<PRE>size_t <B>mbrtowc</B>(wchar_t *restrict pwc, const char *restrict s,
    size_t n, mbstate_t *restrict ps);</PRE>

<P>The function determines the number of bytes in a multibyte string
that completes the next multibyte character, if possible.</P>

<P>If <CODE>ps</CODE> is not a null pointer, the
<A HREF="charset.html#conversion_state">conversion state</A> for
the multibyte string is assumed to be <CODE>*ps</CODE>. Otherwise, it is
assumed to be <CODE>&amp;internal</CODE>,
where <CODE>internal</CODE> is an object of type
<A HREF="#mbstate_t"><CODE>mbstate_t</CODE></A>
internal to the <CODE>mbrtowc</CODE> function. At
<A HREF="lib_over.html#program_startup">program startup</A>,
<CODE>internal</CODE> is initialized to the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
No other library function alters the value stored
in <CODE>internal</CODE>.</P>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>x</CODE>,
the number of bytes in the multibyte string <CODE>s</CODE> that complete
or contribute to the next multibyte character. (<CODE>x</CODE> cannot be
greater than <CODE>n</CODE>.) Otherwise, the function effectively returns
<CODE>mbrtowc(0, "", 1, ps)</CODE>,
ignoring <CODE>pwc</CODE> and <CODE>n</CODE>.
(The function thus returns zero only if the
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that no incomplete multibyte character is pending from a previous call to
<A HREF="#mbrlen"><CODE>mbrlen</CODE></A>,
<CODE>mbrtowc</CODE>, or
<A HREF="#mbsrtowcs"><CODE>mbsrtowcs</CODE></A> for the
same string and
<A HREF="charset.html#conversion_state">conversion state</A>.)</P>

<P>If <CODE>pwc</CODE> is not a null pointer, the function converts a
completed multibyte character to its corresponding wide-character
value and stores that value in <CODE>*pwc</CODE>.</P>

<P>The function returns:</P>

<UL>
<LI><CODE>(<A HREF="#size_t">size_t</A>)-3</CODE> if
no additional bytes are needed to complete the next multibyte character,
in which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that no additional bytes have been converted and the next
multibyte character has been produced</LI>

<LI><CODE>(<A HREF="#size_t">size_t</A>)-2</CODE> if,
after converting all <CODE>n</CODE> characters, the resulting
<A HREF="charset.html#conversion_state">conversion state</A>
indicates an incomplete multibyte character</LI>

<LI><CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>
if the function detects an encoding error
before completing the next multibyte character, in which case the
function stores the value
<A HREF="errno.html#EILSEQ"><CODE>EILSEQ</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and leaves the resulting
<A HREF="charset.html#conversion_state">conversion state</A> undefined</LI>

<LI>zero, if the next completed character is a null character, in
which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> is the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A></LI>

<LI><CODE>x</CODE>, the number of bytes needed to complete the next multibyte
character, in which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that <CODE>x</CODE> bytes have been converted and the next
multibyte character has been produced</LI>
</UL>

<P>The function is not necessarily thread safe if
<CODE>ps</CODE> is a null pointer.</P>

<H2><A NAME="mbsinit"></A><CODE>mbsinit</CODE></H2>

<PRE>int <B>mbsinit</B>(const mbstate_t *ps);</PRE>

<P>The function returns a nonzero value if <CODE>ps</CODE> is a null
pointer or if <CODE>*ps</CODE> designates an
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
Otherwise, it returns zero.</P>

<H2><A NAME="mbsrtowcs"></A><CODE>mbsrtowcs</CODE></H2>

<PRE>size_t <B>mbsrtowcs</B>(wchar_t *restrict dst, const char **restrict src,
    size_t len, mbstate_t *restrict ps);</PRE>

<P>The function converts the multibyte string beginning at <CODE>*src</CODE>
to a sequence of wide characters as if by repeated calls of the form:</P>

<PRE>x = mbrtowc(dst, *src, n, ps != 0 ? ps : &amp;internal)</PRE>

<P>where <CODE>n</CODE> is some value &gt; 0 and <CODE>internal</CODE>
is an object of type
<A HREF="#mbstate_t"><CODE>mbstate_t</CODE></A>
internal to the <CODE>mbsrtowcs</CODE> function. At
<A HREF="lib_over.html#program_startup">program startup</A>,
<CODE>internal</CODE> is initialized to the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
No other library function alters the value
stored in <CODE>internal</CODE>.</P>

<P>If <CODE>dst</CODE> is not a null pointer,
the <CODE>mbsrtowcs</CODE> function stores at most <CODE>len</CODE>
wide characters by calls to
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>.
The function effectively increments <CODE>dst</CODE> by one
and <CODE>*src</CODE> by <CODE>x</CODE> after each call to
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>
that stores a converted wide character.
After a call that returns zero,
<CODE>mbsrtowcs</CODE> stores a null wide character
at <CODE>dst</CODE> and stores
a null pointer at <CODE>*src</CODE>.</P>

<P>If <CODE>dst</CODE> is a null pointer,
<CODE>len</CODE> is effectively assigned a large value.</P>

<P>The function returns:</P>

<UL>
<LI><CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>, if a call to
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A> returns
<CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>,
indicating that it has detected an encoding error before completing
the next multibyte character</LI>

<LI>the number of multibyte characters successfully converted, not
including the terminating null character</LI>
</UL>

<P>The function is not necessarily thread safe if
<CODE>ps</CODE> is a null pointer.</P>

<H2><A NAME="mbsrtowcs_s"></A><CODE>mbsrtowcs_s</CODE></H2>

<PRE>errno_t <B>mbsrtowcs_s</B>(size_t *restrict psize,
    wchar_t *restrict dst, rsize_t maxsize,
    const char *restrict src, rsize_t len,
    mbstate_t *restrict ps); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>dst</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>dst</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>src</CODE> is a null pointer</LI>

<LI><CODE>*src</CODE> is a null pointer</LI>

<LI><CODE>dst</CODE> is not a null pointer and <CODE>len</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>dst</CODE> is not a null pointer and the wide-character sequence
generated by the function does not end with a null wide character within
the first <CODE>maxsize</CODE> elements</LI>

<LI><CODE>ps</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>dst</CODE>
is not a null pointer, the function
stores a null wide character at <CODE>dst[0]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function converts the multibyte string beginning at <CODE>*src</CODE>
to a sequence of wide characters as if by repeated calls of the form:</P>

<PRE>x = mbrtowc(dst, *src, n, ps)</PRE>

<P>where <CODE>n</CODE> is some value &gt; 0.</P>

<P>If <CODE>dst</CODE> is not a null pointer,
the <CODE>mbsrtowcs_s</CODE> function stores at most <CODE>len</CODE>
wide characters by calls to
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>.
The function effectively increments <CODE>dst</CODE> by one
and <CODE>*src</CODE> by <CODE>x</CODE> after each call to
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>
that stores a converted wide character.
After a call that returns zero,
<CODE>mbsrtowcs_s</CODE> stores a null wide character
at <CODE>dst</CODE> and stores
a null pointer at <CODE>*src</CODE>.
If no such null wide character is stored, the function
stores a null wide character at <CODE>dst[len]</CODE>.</P>

<P>If <CODE>dst</CODE> is a null pointer,
<CODE>len</CODE> is effectively assigned a large value.</P>

<P>The function returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="mbstate_t"></A><CODE>mbstate_t</CODE></H2>

<PRE>typedef <I>o-type</I> <B>mbstate_t;</B></PRE>

<P>The type is an object type <I>o-type</I> that can represent a
<A HREF="charset.html#conversion_state">conversion state</A>
for any of the functions
<A HREF="#mbrlen"><CODE>mbrlen</CODE></A>,
<A HREF="#mbrtowc"><CODE>mbrtowc</CODE></A>,
<A HREF="#mbsrtowcs"><CODE>mbsrtowcs</CODE></A>,
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>, or
<A HREF="#wcsrtombs"><CODE>wcsrtombs</CODE></A>.
A definition of the form:</P>

<PRE>mbstate_t mbst = {0};</PRE>

<P>ensures that <CODE>mbst</CODE> represents the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
Note, however, that other values stored in an object of type
<CODE>mbstate_t</CODE> can also represent this state.
To test safely for this state, use the function
<A HREF="#mbsinit"><CODE>mbsinit</CODE></A>.</P>

<H2><A NAME="NULL"></A><CODE>NULL</CODE></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address_constant_expression">
address constant expression</A>.</P>

<H2><A NAME="putwc"></A><CODE>putwc</CODE></H2>

<PRE>wint_t <B>putwc</B>(wchar_t c, FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputwc">fputwc</A>(c, stream)</CODE>
except that a macro version of <CODE>putwc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="putwchar"></A><CODE>putwchar</CODE></H2>

<PRE>wint_t <B>putwchar</B>(wchar_t c);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputwc">fputwc</A>(c, stdout)</CODE>.</P>

<H2><A NAME="rsize_t"></A><CODE>rsize_t</CODE></H2>

<PRE>typedef size_t <B>rsize_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <CODE>size_t</CODE>,
used to represent a function argument to be checked on entry
to a function. It is a
<A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
for an argument of type <CODE>rsize_t</CODE> to be greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>.</P>

<H2><A NAME="size_t"></A><CODE>size_t</CODE></H2>

<PRE>typedef <I>ui-type</I> <B>size_t;</B></PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof_operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="snwprintf_s"></A><CODE>snwprintf_s</CODE></H2>

<PRE>int <B>snwprintf_s</B>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null character at <CODE>s[0]</CODE>.
It then returns a negative value.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores each wide generated character
in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no wide characters.
Otherwise, the function stores up to <CODE>n - 1</CODE>
wide characters and concludes by
storing a null wide character in the next location of the array. It returns
the <I>total</I> number of wide characters generated (even those not stored),
not including the null wide character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="swprintf"></A><CODE>swprintf</CODE></H2>

<PRE>int <B>swprintf</B>(wchar_t *restrict s, size_t n,
    const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes
by storing a null wide character in the next location of the array.
If it cannot generate and store all characters in an array of size <CODE>n</CODE>,
the function returns a negative number. Otherwise,
it returns the number of wide characters generated, not including
the null wide character.</P>

<H2><A NAME="swprintf_s"></A><CODE>swprintf_s</CODE></H2>

<PRE>int <B>swprintf_s</B>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>

<LI>the function attempts to generate more than <CODE>n - 1</CODE>
wide characters</LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null wide character in <CODE>s[0]</CODE>. It then
returns zero.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated wide character in successive locations
of the array object whose first element has the address <CODE>s</CODE>.
If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores
up to <CODE>n - 1</CODE> wide characters and concludes by
storing a null wide character in the next location of the array. It returns
the <I>total</I> number of wide characters generated (even those not stored),
not including the null wide character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="swscanf"></A><CODE>swscanf</CODE></H2>

<PRE>int <B>swscanf</B>(const wchar_t *restrict s,
    const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the function does not store
values before it accesses a null wide character from the array.</P>

<H2><A NAME="swscanf_s"></A><CODE>swscanf_s</CODE></H2>

<PRE>int <B>swscanf_s</B>(const wchar_t *restrict s, const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null wide character from the array.</P>

<H2><A NAME="tm"></A><CODE>tm</CODE></H2>

<PRE>struct <B>tm;</B></PRE>

<P><CODE>struct</CODE> <CODE>tm</CODE> contains members that describe various
properties of the calendar time. The declaration in this header leaves
<CODE>struct <A HREF="time.html#tm">tm</A></CODE> an incomplete type.
Include the header
<A HREF="time.html#&lt;time.h&gt;"><CODE>&lt;time.h&gt;</CODE></A>
to complete the type.</P>

<H2><A NAME="ungetwc"></A><CODE>ungetwc</CODE></H2>

<PRE>wint_t <B>ungetwc</B>(wint_t c, FILE *stream);</PRE>

<P>If <CODE>c</CODE> is not equal to
<A HREF="#WEOF"><CODE>WEOF</CODE></A>, the function stores
<CODE>(<A HREF="#wchar_t">wchar_t</A>)c</CODE>
in the object whose address is <CODE>stream</CODE> and
clears the end-of-file indicator. If <CODE>c</CODE> equals
<A HREF="#WEOF"><CODE>WEOF</CODE></A> or
the store cannot occur, the function returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>; otherwise,
it returns <CODE>(<A HREF="#wchar_t">wchar_t</A>)c</CODE>.
A subsequent library function call that
reads a wide character from the stream <CODE>stream</CODE> obtains this
stored value, which is then forgotten.</P>

<P>Thus, you can effectively
<A HREF="stdio.html#push_back">push back</A> a wide character
to a stream after reading a wide character.</P>

<H2><A NAME="vfwprintf"></A><CODE>vfwprintf</CODE></H2>

<PRE>int <B>vfwprintf</B>(FILE *restrict stream, const wchar_t *restrict format,
    va_list arg);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream <CODE>stream</CODE>.
It returns the number of wide characters generated,
or it returns a negative value
if the function sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfwprintf_s"></A><CODE>vfwprintf_s</CODE></H2>

<PRE>int <B>vfwprintf_s</B>(FILE *restrict stream, const wchar_t *restrict format,
     va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream <CODE>stream</CODE>.
It returns the number
of wide characters generated, or it returns a negative value if the function
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfwscanf"></A><CODE>vfwscanf</CODE></H2>

<PRE>int <B>vfwscanf</B>(FILE *restrict stream, const wchar_t *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfwscanf_s"></A><CODE>vfwscanf_s</CODE></H2>

<PRE>int <B>vfwscanf_s</B>(FILE *restrict stream, const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream <CODE>stream</CODE>.
It returns the number
of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsnwprintf_s"></A><CODE>vsnwprintf_s</CODE></H2>

<PRE>int <B>vsnwprintf_s</B>(wchar_t *restrict s, rsize_t n, const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null wide character at <CODE>s[0]</CODE>.
It then returns a negative value.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
generated wide characters in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no wide characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
wide characters and concludes by
storing a null wide character in the next location of the array. It returns
the <I>total</I> number of wide characters generated (even those not stored),
not including the null wide character,
or a negative value if an encoding error occurs.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vswprintf"></A><CODE>vswprintf</CODE></H2>

<PRE>int <B>vswprintf</B>(wchar_t *restrict s, size_t n, const wchar_t *restrict format,
    va_list arg);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated wide character in successive locations of the array object
whose first element has the address <CODE>s</CODE>.
The function concludes by storing a null wide character
in the next location of the array.
If it cannot generate and store all characters in an array of size <CODE>n</CODE>,
the function returns a negative number. Otherwise,
it returns the number of wide characters generated -- not including
the null wide character.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vswprintf_s"></A><CODE>vswprintf_s</CODE></H2>

<PRE>int <B>vswprintf_s</B>(wchar_t *restrict s, rsize_t n,
    const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>

<LI>the function generates more than <CODE>n</CODE> wide characters,
counting the terminating null character</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null wide character at <CODE>s[0]</CODE>.
It then returns zero.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated wide character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null wide character in the next location of the array. It returns
the number of characters generated, not including the null character,
or a negative value if an encoding error occurs.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vswscanf"></A><CODE>vswscanf</CODE></H2>

<PRE>int <B>vswscanf</B>(const wchar_t *restrict s, const wchar_t *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned wide
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vswscanf_s"></A><CODE>vswscanf_s</CODE></H2>

<PRE>int <B>vswscanf_s</B>(const wchar_t *restrict s, const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
wide character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null wide character from the array.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vwprintf"></A><CODE>vwprintf</CODE></H2>

<PRE>int <B>vwprintf</B>(const wchar_t *restrict format,
    va_list arg);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream
<A HREF="stdio.html#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or a negative value if the function
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vwprintf_s"></A><CODE>vwprintf_s</CODE></H2>

<PRE>int <B>vwprintf_s</B>(const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream
<A HREF="stdio.html#stdout"><CODE>stdout</CODE></A>.
It returns the number of wide characters generated,
or a negative value if the function sets
the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vwscanf"></A><CODE>vwscanf</CODE></H2>

<PRE>int <B>vwscanf</B>(const wchar_t *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream
<A HREF="stdio.html#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#WEOF"><CODE>WEOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vwscanf_s"></A><CODE>vwscanf_s</CODE></H2>

<PRE>int <B>vwscanf_s</B>(const wchar_t *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream
<A HREF="stdio.html#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="WCHAR_MAX"></A><CODE>WCHAR_MAX</CODE></H2>

<PRE>#define <B>WCHAR_MAX</B> <I>&lt;#if expression &gt;= 127&gt;</I></PRE>

<P>The macro yields the maximum value for type
<A HREF="#wchar_t"><CODE>wchar_t</CODE></A>.</P>

<H2><A NAME="WCHAR_MIN"></A><CODE>WCHAR_MIN</CODE></H2>

<PRE>#define <B>WCHAR_MIN</B> <I>&lt;#if expression &lt;= 0&gt;</I></PRE>

<P>The macro yields the minimum value for type
<A HREF="#wchar_t"><CODE>wchar_t</CODE></A>.</P>

<H2><A NAME="wchar_t"></A><CODE>wchar_t</CODE></H2>

<PRE>typedef <I>i-type</I> <B>wchar_t;</B> <B>[keyword in C++]</B></PRE>

<P>The type is the integer type <CODE><I>i-type</I></CODE> of a
<A HREF="charset.html#wide-character_constant">
wide-character constant</A>, such as <CODE>L'X'</CODE>.
You declare an object of type <CODE>wchar_t</CODE> to hold a
<A HREF="charset.html#Wide-Character_Encoding">wide character</A>.</P>

<H2><A NAME="wcrtomb"></A><CODE>wcrtomb</CODE></H2>

<PRE>size_t <B>wcrtomb</B>(char *restrict s, wchar_t wc, mbstate_t *restrict ps);</PRE>

<P>The function determines the number of bytes needed to represent
the wide character <CODE>wc</CODE> as a multibyte character, if possible.
(Not all values representable as type
<A HREF="#wchar_t"><CODE>wchar_t</CODE></A>
are necessarily valid wide-character codes.)</P>

<P>If <CODE>ps</CODE> is not a null pointer, the
<A HREF="charset.html#conversion_state">conversion state</A> for
the multibyte string is assumed to be <CODE>*ps</CODE>. Otherwise, it is
assumed to be <CODE>&amp;internal</CODE>,
where <CODE>internal</CODE> is an object of type
<A HREF="#mbstate_t"><CODE>mbstate_t</CODE></A>
internal to the <CODE>wcrtomb</CODE> function. At
<A HREF="lib_over.html#program_startup">program startup</A>,
<CODE>internal</CODE> is initialized to the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
No other library function alters the value stored
in <CODE>internal</CODE>.</P>

<P>If <CODE>s</CODE> is not a null pointer
and <CODE>wc</CODE> is a valid wide-character
code, the function determines <CODE>x</CODE>, the number of bytes needed
to represent <CODE>wc</CODE> as a multibyte character,
and stores the converted bytes in the array of <I>char</I>
beginning at <CODE>s</CODE>. (<CODE>x</CODE> cannot be greater than
<A HREF="stdlib.html#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)
If <CODE>wc</CODE> is a null wide character,
the function stores any
<A HREF="charset.html#shift_sequence">shift sequence</A>
needed to restore the
<A HREF="charset.html#initial_shift_state">initial shift state</A>,
followed by a null byte. The resulting conversion state is the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.</P>

<P>If <CODE>s</CODE> is a null pointer, the function effectively returns
<CODE>wcrtomb(buf, L'\0', ps)</CODE>, where <CODE>buf</CODE> is a
buffer internal to the function. (The function thus returns the number
of bytes needed to restore the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
and to terminate the multibyte string
pending from a previous call to <CODE>wcrtomb</CODE> or
<A HREF="#wcsrtombs"><CODE>wcsrtombs</CODE></A>
for the same string and
<A HREF="charset.html#conversion_state">conversion state</A>.)</P>

<P>The function returns:</P>

<UL>
<LI><CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>
if <CODE>wc</CODE> is an invalid wide-character code,
in which case the function stores the value
<A HREF="errno.html#EILSEQ"><CODE>EILSEQ</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and leaves the resulting
<A HREF="charset.html#conversion_state">conversion state</A> undefined</LI>

<LI><CODE>x</CODE>, the number of bytes needed
to complete the next muitibyte character, in which case the resulting
<A HREF="charset.html#conversion_state">conversion state</A> indicates
that <CODE>x</CODE> bytes have been generated</LI>
</UL>

<P>The function is not necessarily thread safe if
<CODE>ps</CODE> is a null pointer.</P>

<H2><A NAME="wcrtomb_s"></A><CODE>wcrtomb_s</CODE></H2>

<PRE>errno_t <B>wcrtomb_s</B>(int *restrict pstat,
    char *restrict s, rsize_t maxsize, wchar_t wchar,
    mbstate_t *restrict ps); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>pstat</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is not a null pointer and <CODE>maxsize</CODE> is
less than <CODE>N</CODE>, the number of bytes needed to represent
the multibyte character corresponding to the wide character
<CODE>wchar</CODE> (<CODE>N</CODE> cannot exceed
<A HREF="stdlib.html#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)</LI>

<LI><CODE>s</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>ps</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, other than the first one,
and <CODE>s</CODE> is not a null pointer,
the function stores a null wide character in <CODE>s[0]</CODE>.
If <CODE>pstat</CODE> is not a null pointer,
the function stores <CODE>(size_t)-1</CODE> in <CODE>*pstat</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function determines the number of bytes needed to represent
the wide character <CODE>wc</CODE> as a multibyte character, if possible.
(Not all values representable as type
<A HREF="#wchar_t"><CODE>wchar_t</CODE></A>
are necessarily valid wide-character codes.)
The <A HREF="charset.html#conversion_state">conversion state</A> for
the multibyte string is assumed to be <CODE>*ps</CODE>.</P>

<P>If <CODE>s</CODE> is not a null pointer
and <CODE>wc</CODE> is a valid wide-character
code, the function determines <CODE>x</CODE>, the number of bytes needed
to represent <CODE>wc</CODE> as a multibyte character,
and stores the converted bytes in the array of <I>char</I>
beginning at <CODE>s</CODE>. (<CODE>x</CODE> cannot be greater than
<A HREF="stdlib.html#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)
If <CODE>wc</CODE> is a null wide character,
the function stores any
<A HREF="charset.html#shift_sequence">shift sequence</A>
needed to restore the
<A HREF="charset.html#initial_shift_state">initial shift state</A>,
followed by a null byte. The resulting conversion state is the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.</P>

<P>If <CODE>s</CODE> is a null pointer, the function effectively returns
<CODE>wcrtomb(buf, L'\0', ps)</CODE>, where <CODE>buf</CODE> is a
buffer internal to the function. (The function thus returns the number
of bytes needed to restore the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
and to terminate the multibyte string
pending from a previous call to <CODE>wcrtomb_s</CODE> or
<A HREF="#wcsrtombs_s"><CODE>wcsrtombs_s</CODE></A>
for the same string and
<A HREF="charset.html#conversion_state">conversion state</A>.)</P>

<P>The function returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="wcscat"></A><CODE>wcscat</CODE></H2>

<PRE>wchar_t *<B>wcscat</B>(wchar_t *restrict s1, const wchar_t *restrict s2);</PRE>

<P>The function copies the wide string <CODE>s2</CODE>, including its
terminating null wide character, to successive elements of the array
that stores the wide string <CODE>s1</CODE>, beginning
with the element that stores the terminating null wide character of
<CODE>s1</CODE>. It returns <CODE>s1</CODE>.</P>

<H2><A NAME="wcscat_s"></A><CODE>wcscat_s</CODE></H2>

<PRE>errno_t <B>wcscat_s</B>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI>the value <CODE>M</CODE>, given by
<CODE>maxsize - <A HREF="#wcsnlen_s">wcsnlen_s</A>(s1, maxsize)</CODE>,
is not greater than <CODE>N</CODE>, given by
<CODE>wcsnlen_s(s2, M)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE> beginning
at the address <CODE>s2 + M</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null wide character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the string <CODE>s2</CODE>, including its
terminating null wide character, to successive elements
of the array of <CODE>wchar_t</CODE> that stores the string <CODE>s1</CODE>,
beginning with the element that stores
the terminating null character of <CODE>s1</CODE>.
It returns zero.</P>

<H2><A NAME="wcschr"></A><CODE>wcschr</CODE></H2>

<PRE>wchar_t *<B>wcschr</B>(const wchar_t *s, wchar_t c); <B>[not in C++]</B>
const wchar_t *<B>wcschr</B>(const wchar_t *s, wchar_t c); <B>[C++ only]</B>
wchar_t *<B>wcschr</B>(wchar_t *s, wchar_t c); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of the wide string
<CODE>s</CODE> that equals <CODE>c</CODE>.
It considers the terminating null wide
character as part of the wide string. If successful, the function
returns the address of the matching element; otherwise, it returns
a null pointer.</P>

<H2><A NAME="wcscmp"></A><CODE>wcscmp</CODE></H2>

<PRE>int <B>wcscmp</B>(const wchar_t *s1, const wchar_t *s2);</PRE>

<P>The function compares successive elements from two wide strings,
<CODE>s1</CODE> and <CODE>s2</CODE>,
until it finds elements that are not equal.</P>

<UL>
<LI>If all elements are equal, the function returns zero.</LI>

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE>, the function returns a positive number.</LI>

<LI>Otherwise, the function returns a negative number.</LI>
</UL>

<H2><A NAME="wcscoll"></A><CODE>wcscoll</CODE></H2>

<PRE>int <B>wcscoll</B>(const wchar_t *s1, const wchar_t *s2);</PRE>

<P>The function compares two wide strings,
<CODE>s1</CODE> and <CODE>s2</CODE>,
using a comparison rule that depends on the current
<A HREF="charset.html#locale">locale</A>. If <CODE>s1</CODE> compares
greater than <CODE>s2</CODE> by this rule,
the function returns a positive number.
If the two wide strings compare equal, it returns zero. Otherwise, it
returns a negative number.</P>

<H2><A NAME="wcscpy"></A><CODE>wcscpy</CODE></H2>

<PRE>wchar_t *<B>wcscpy</B>(wchar_t *restrict s1, const wchar_t *restrict s2);</PRE>

<P>The function copies the wide string <CODE>s2</CODE>, including its
terminating null wide character, to successive elements of the array
whose first element has the address <CODE>s1</CODE>. It
returns <CODE>s1</CODE>.</P>

<H2><A NAME="wcscpy_s"></A><CODE>wcscpy_s</CODE></H2>

<PRE>errno_t <B>wcscpy_s</B>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is not greater than <CODE>N</CODE>, given by
<CODE><A HREF="#wcsnlen_s">wcsnlen_s</A>(s2, maxsize)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE>
beginning at the address <CODE>s1</CODE>
overlaps the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE>
beginning at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null wide character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the wide string <CODE>s2</CODE>,
including its terminating null wide character,
to successive elements of the array of <CODE>wchar_t</CODE>
whose first element has the address <CODE>s1</CODE>.
It returns zero.</P>

<H2><A NAME="wcscspn"></A><CODE>wcscspn</CODE></H2>

<PRE>size_t <B>wcscspn</B>(const wchar_t *s1, const wchar_t *s2);</PRE>

<P>The function searches for the first element <CODE>s1[i]</CODE>
in the wide string <CODE>s1</CODE> that equals <I>any one</I> of the elements
of the wide string <CODE>s2</CODE> and returns <CODE>i.</CODE>
Each terminating null wide character is considered
part of its wide string.</P>

<H2><A NAME="wcsftime"></A><CODE>wcsftime</CODE></H2>

<PRE>size_t <B>wcsftime</B>(wchar_t *restrict s, size_t maxsize,
    const wchar_t *restrict format, const struct tm *restrict timeptr);</PRE>

<P>The function generates formatted text, under the control of
the format <CODE>format</CODE> and the values stored in the time structure
<CODE>*tptr</CODE>. It stores each generated wide character in successive
locations of the array object of size <CODE>n</CODE> whose first element
has the address <CODE>s</CODE>. The function then stores a null wide character
in the next location of the array. It returns <CODE>x</CODE>, the number
of wide characters generated, if <CODE>x &lt; n</CODE>; otherwise,
it returns zero, and the values stored in the array are indeterminate.</P>

<P>For each wide character other than <CODE>%</CODE> in the format, the
function stores that wide character in the array object. Each occurrence
of <CODE>%</CODE> followed by another character in the format is a
<B><A NAME="conversion_specifier"></A>conversion specifier</B>.
For each conversion specifier, the function stores a
replacement wide character sequence. Conversion specifiers are the
same as for the function
<A HREF="time.html#strftime"><CODE>strftime</CODE></A>.</P>

<H2><A NAME="wcslen"></A><CODE>wcslen</CODE></H2>

<PRE>size_t <B>wcslen</B>(const wchar_t *s);</PRE>

<P>The function returns the number of wide characters in the wide
string <CODE>s</CODE>, <I>not</I> including
its terminating null wide character.</P>

<H2><A NAME="wcsncat"></A><CODE>wcsncat</CODE></H2>

<PRE>wchar_t *<B>wcsncat</B>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);</PRE>

<P>The function copies the wide string <CODE>s2</CODE>, <I>not</I> including
its terminating null wide character,
to successive elements of the array
that stores the wide string <CODE>s1</CODE>, beginning
with the element that stores the terminating null wide character of
<CODE>s1</CODE>. The function copies no more than
<CODE>n</CODE> wide characters from <CODE>s2</CODE>.
It then stores a null wide character, in the next
element to be altered in <CODE>s1</CODE>, and returns <CODE>s1</CODE>.</P>

<H2><A NAME="wcsncat_s"></A><CODE>wcsncat_s</CODE></H2>

<PRE>errno_t <B>wcsncat_s</B>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI>the value <CODE>M</CODE>, given by
<CODE>maxsize - <A HREF="#wcsnlen_s">wcsnlen_s</A>(s1, maxsize)</CODE>,
is not greater than <CODE>N</CODE>, given by
<CODE>wcsnlen_s(s2, n)</CODE></LI>

<LI>the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N + 1</CODE> <CODE>wchar_t</CODE> beginning
at the address <CODE>s2 + M</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null wide character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the wide string <CODE>s2</CODE>,
<I>not</I> including its terminating null wide character,
to successive elements of the array of
<CODE>wchar_t</CODE> that stores the string <CODE>s1</CODE>, beginning with the
element that stores the terminating null wide character of <CODE>s1</CODE>. The
function copies no more than <CODE>n</CODE> characters from
<CODE>s2</CODE>. It then stores a null wide character, in the next element to be
altered in <CODE>s1</CODE>, and returns zero.</P>

<H2><A NAME="wcsncmp"></A><CODE>wcsncmp</CODE></H2>

<PRE>int <B>wcsncmp</B>(const wchar_t *s1, const wchar_t *s2,
    size_t n);</PRE>

<P>The function compares successive elements from two wide strings,
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements
that are not equal or until it has compared the first
<CODE>n</CODE> elements of the two wide strings.</P>

<UL>
<LI>If all elements are equal, the function returns zero.</LI>

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE>, the function returns a positive number.</LI>

<LI>Otherwise, it returns a negative number.</LI>
</UL>

<H2><A NAME="wcsncpy"></A><CODE>wcsncpy</CODE></H2>

<PRE>wchar_t *<B>wcsncpy</B>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);</PRE>

<P>The function copies the wide string <CODE>s2</CODE>, <I>not</I> including
its terminating null wide character, to successive elements of the array
whose first element has the address <CODE>s1</CODE>.
It copies no more than <CODE>n</CODE> wide characters
from <CODE>s2</CODE>. The function then stores
zero or more null wide characters in the next elements
to be altered in <CODE>s1</CODE> until it stores a total of <CODE>n</CODE>
wide characters. It returns <CODE>s1</CODE>.</P>

<H2><A NAME="wcsncpy_s"></A><CODE>wcsncpy_s</CODE></H2>

<PRE>errno_t <B>wcsncpy_s</B>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is not greater than <CODE>N</CODE>, given by
<CODE><A HREF="#wcsnlen_s">wcsnlen_s</A>(s2, n)</CODE></LI>

<LI>the array of <CODE>N</CODE> <CODE>wchar_t</CODE> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>N</CODE> <CODE>wchar_t</CODE> beginning
at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null wide character in <CODE>s1[0]</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the wide string <CODE>s2</CODE>,
<I>not</I> including its terminating null wide character, to successive
elements of the array of <CODE>wchar_t</CODE> whose first element has
the address <CODE>s1</CODE>. It copies no
more than <CODE>n</CODE> wide characters from <CODE>s2</CODE>. The function then
stores a null wide character in the next elements to be altered in
<CODE>s1</CODE>. It returns zero.</P>

<H2><A NAME="wcsnlen_s"></A><CODE>wcsnlen_s</CODE></H2>

<PRE>size_t <B>wcsnlen_s</B>(const wchar_t *s, size_t maxsize); <B>[added with TR24731]</B></PRE>

<P>If <CODE>s</CODE> is a null pointer, the function returns zero.
Otherwise, if a null wide character occurs in the first <CODE>maxsize</CODE>
elements of the array beginning at <CODE>s</CODE>, the function
returns the number of wide characters before the first null wide character.
Otherwise, the function returns <CODE>maxsize</CODE>.</P>

<H2><A NAME="wcspbrk"></A><CODE>wcspbrk</CODE></H2>

<PRE>wchar_t *<B>wcspbrk</B>(const wchar_t *s1, const wchar_t *s2); <B>[not in C++]</B>
const wchar_t *<B>wcspbrk</B>(const wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>
wchar_t *<B>wcspbrk</B>(wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first element <CODE>s1[i]</CODE>
in the wide string <CODE>s1</CODE> that equals <I>any one</I> of the elements
of the wide string <CODE>s2</CODE>. It considers each terminating null wide
character as part of its wide string. If <CODE>s1[i]</CODE> is not
the terminating null wide character, the function returns
<CODE>&amp;s1[i]</CODE>; otherwise, it returns a null pointer.</P>

<H2><A NAME="wcsrchr"></A><CODE>wcsrchr</CODE></H2>

<PRE>wchar_t *<B>wcsrchr</B>(const wchar_t *s, wchar_t c); <B>[not in C++]</B>
const wchar_t *<B>wcsrchr</B>(const wchar_t *s, wchar_t c); <B>[C++ only]</B>
wchar_t *<B>wcsrchr</B>(wchar_t *s, wchar_t c); <B>[C++ only]</B></PRE>

<P>The function searches for the last element of the wide string
<CODE>s</CODE> that equals <CODE>c</CODE>.
It considers the terminating null wide
character as part of the wide string. If successful, the function
returns the address of the matching element; otherwise, it returns
a null pointer.</P>

<H2><A NAME="wcsrtombs"></A><CODE>wcsrtombs</CODE></H2>

<PRE>size_t <B>wcsrtombs</B>(char *restrict dst, const wchar_t **restrict src,
    size_t len, mbstate_t *restrict ps);</PRE>

<P>The function converts the wide-character string beginning at
<CODE>*src</CODE> to a sequence of multibyte characters as if by repeated
calls of the form:</P>

<PRE>x = wcrtomb(dst ? dst : buf, *src, ps != 0 ? ps : &amp;internal)</PRE>

<P>where <CODE>buf</CODE> is an array of type <I>char</I>
and <CODE>internal</CODE> is an object of type
<A HREF="#mbstate_t"><CODE>mbstate_t</CODE></A>,
both internal to the <CODE>wcsrtombs</CODE> function. At
<A HREF="lib_over.html#program_startup">program startup</A>,
<CODE>internal</CODE> is initialized to the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
No other library function alters the value
stored in <CODE>internal</CODE>.</P>

<P>If <CODE>dst</CODE> is not a null pointer,
the <CODE>wcsrtombs</CODE> function stores at most
<CODE>len</CODE> bytes by calls to
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>. The function
effectively increments <CODE>dst</CODE> by <CODE>x</CODE>
and <CODE>*src</CODE> by one after each call to
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>
that stores a <I>complete</I> converted
multibyte character in the remaining space available. After a call
that stores a complete null multibyte character at <CODE>dst</CODE>
(including any
<A HREF="charset.html#shift_sequence">shift sequence</A>
needed to restore the
<A HREF="charset.html#initial_shift_state">initial shift state</A>),
the function stores a null pointer at <CODE>*src</CODE>.</P>

<P>If <CODE>dst</CODE> is a null pointer,
<CODE>len</CODE> is effectively assigned a large value.</P>

<P>The function returns:</P>

<UL>
<LI><CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>, if a call to
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>
returns <CODE>(<A HREF="#size_t">size_t</A>)-1</CODE>,
indicating that it has detected an invalid wide-character code</LI>

<LI>the number of bytes successfully converted, not including the
terminating null byte</LI>
</UL>

<P>The function is not necessarily thread safe if
<CODE>ps</CODE> is a null pointer.</P>

<H2><A NAME="wcsrtombs_s"></A><CODE>wcsrtombs_s</CODE></H2>

<PRE>errno_t <B>wcsrtombs_s</B>(size_t *restrict psize,
    char *restrict dst, rsize_t maxsize,
    const wchar_t *restrict src, rsize_t len,
    mbstate_t *ps); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>dst</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>dst</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>src</CODE> is a null pointer</LI>

<LI><CODE>dst</CODE> is not a null pointer and <CODE>len</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>ps</CODE> is a null pointer</LI>

<LI><CODE>dst</CODE> is not a null pointer and the multibyte sequence
generated by the function does not end with a null character within
the first <CODE>maxsize</CODE> elements</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>dst</CODE>
is not a null pointer, the function
stores a null character at <CODE>dst[0]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function converts the wide-character string beginning at
<CODE>*src</CODE> to a sequence of multibyte characters as if by repeated
calls of the form:</P>

<PRE>x = wcrtomb(dst ? dst : buf, *src, ps)</PRE>

<P>where <CODE>buf</CODE> is an array of type <I>char</I>
internal to the <CODE>wcsrtombs</CODE> function.</P>

<P>If <CODE>dst</CODE> is not a null pointer,
the <CODE>wcsrtombs_s</CODE> function stores at most
<CODE>len</CODE> bytes by calls to
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>. The function
effectively increments <CODE>dst</CODE> by <CODE>x</CODE>
and <CODE>*src</CODE> by one after each call to
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>
that stores a <I>complete</I> converted
multibyte character in the remaining space available. After a call
that stores a complete null multibyte character at <CODE>dst</CODE>
(including any
<A HREF="charset.html#shift_sequence">shift sequence</A>
needed to restore the
<A HREF="charset.html#initial_shift_state">initial shift state</A>),
the function stores a null pointer at <CODE>*src</CODE>.
If no such null cnaracter is stored, the function
stores a null wide immediately after the last stored byte.</P>

<P>If <CODE>dst</CODE> is a null pointer,
<CODE>len</CODE> is effectively assigned a large value.</P>

<P>The function returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="wcsspn"></A><CODE>wcsspn</CODE></H2>

<PRE>size_t <B>wcsspn</B>(const wchar_t *s1, const wchar_t *s2);</PRE>

<P>The function searches for the first element <CODE>s1[i]</CODE>
in the wide string <CODE>s1</CODE> that equals <I>none</I> of the elements
of the wide string <CODE>s2</CODE> and returns <CODE>i</CODE>. It considers
the terminating null wide character as
part of the wide string <CODE>s1</CODE> only.</P>

<H2><A NAME="wcsstr"></A><CODE>wcsstr</CODE></H2>

<PRE>wchar_t *<B>wcsstr</B>(const wchar_t *s1, const wchar_t *s2); <B>[not in C++]</B>
const wchar_t *<B>wcsstr</B>(const wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B>
wchar_t *<B>wcsstr</B>(wchar_t *s1, const wchar_t *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first sequence of elements in
the wide string <CODE>s1</CODE> that matches the sequence of elements in
the wide string <CODE>s2</CODE>, <I>not</I> including its terminating null
wide character. If successful, the function returns the address of
the matching first element; otherwise, it returns a null pointer.</P>

<H2><A NAME="wcstod"></A><CODE>wcstod</CODE></H2>

<PRE>double <B>wcstod</B>(const wchar_t *restrict nptr,
    wchar_t **restrict endptr);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>double.</I> If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial wide characters of the wide string <CODE>s</CODE> must
match the same pattern as recognized by the function
<A HREF="stdlib.html#strtod"><CODE>strtod</CODE></A>,
where each wide character <CODE>wc</CODE> is converted as if by calling
<CODE><A HREF="#wctob">wctob</A>(wc))</CODE>.</P>

<P>If the wide string <CODE>s</CODE> matches this pattern,
its equivalent value is the value returned by
<A HREF="stdlib.html#strtod"><CODE>strtod</CODE></A>
for the converted sequence.
If the wide string <CODE>s</CODE> does not match a valid pattern,
the value stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>wcstod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="wcstof"></A><CODE>wcstof</CODE></H2>

<PRE>float <B>wcstof</B>(const wchar_t *restrict nptr,
 wchar_t **restrict endptr);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>float.</I> If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial wide characters of the wide string <CODE>s</CODE> must
match the same pattern as recognized by the function
<A HREF="stdlib.html#strtod"><CODE>strtod</CODE></A>,
where each wide character <CODE>wc</CODE> is converted as if by calling
<CODE><A HREF="#wctob">wctob</A>(wc))</CODE>.</P>

<P>If the wide string <CODE>s</CODE> matches this pattern,
its equivalent value is the value returned by
<A HREF="stdlib.html#strtof"><CODE>strtof</CODE></A>
for the converted sequence.
If the wide string <CODE>s</CODE> does not match a valid pattern,
the value stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>wcstod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="wcstok"></A><CODE>wcstok</CODE></H2>

<PRE>wchar_t *<B>wcstok</B>(wchar_t *restrict s1, const wchar_t *restrict s2,
    wchar_t **restrict ptr);</PRE>

<P>If <CODE>s1</CODE> is not a null pointer, the function begins a search
of the wide string <CODE>s1</CODE>. Otherwise, it begins a search of the
wide string whose address was last stored in <CODE>*ptr</CODE> on an earlier
call to the function, as described below. The search proceeds as follows:</P>

<OL>
<LI>The function searches the wide string for <CODE>begin</CODE>, the
address of the first element that equals <I>none</I> of the elements
of the wide string <CODE>s2</CODE> (a set of token separators). It considers
the terminating null character as part of the search wide string only.</LI>

<LI>If the search does not find an element, the function stores
the address of the terminating null wide character in <CODE>*ptr</CODE>
(so that a subsequent search beginning with that address will fail)
and returns a null pointer. Otherwise, the function searches from
<CODE>begin</CODE> for <CODE>end</CODE>,
the address of the first element that
equals <I>any one</I> of the elements of the wide string <CODE>s2</CODE>.
It again considers the terminating null wide character as part of
the search string only.</LI>

<LI>If the search does not find an element, the function stores
the address of the terminating null wide character in <CODE>*ptr</CODE>.
Otherwise, it stores a null wide character in the element whose address
is <CODE>end.</CODE> Then it stores the address of the next element after
<CODE>end</CODE> in <CODE>*ptr</CODE>
(so that a subsequent search beginning with
that address will continue with the remaining elements of the wide string)
and returns <CODE>begin</CODE>.</LI>
</OL>

<H2><A NAME="wcstok_s"></A><CODE>wcstok_s</CODE></H2>

<PRE>char 8<B>wcstok_s</B>(wchar_t *restrict s1, rsize_t *restrict psize1,
    const wchar_t *restrict s2, wchar_t **restrict pbuf1); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>psize1</CODE> is a null pointer</LI>

<LI><CODE>*psize1</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>pbuf1</CODE> is a null pointer</LI>

<LI>the function fails to find the locations <CODE>begin</CODE>
or <CODE>end</CODE>, or a null wide character,
in the first <CODE>*psize1</CODE> elements of
the array to be searched as described below</LI>
</UL>

<P>If such a violation occurs,
the function stores nothing and returns a null pointer.</P>

<P>Otherwise, if <CODE>s1</CODE> is not a null pointer,
the function begins a search of the wide string <CODE>s1</CODE>.
If <CODE>s1</CODE> is a null pointer, it begins a search of the wide string
whose address was last stored in an internal static-duration object on an
earlier call to the function, as described below. The search proceeds as
follows:</P>

<OL>
<LI>The function searches the string for <CODE>begin</CODE>,
the address of the first element that equals
<I>none</I> of the elements of the wide string
<CODE>s2</CODE> (a set of token separators). It considers the terminating
null wide character as part of the search string only.</LI>

<LI>If the search does not find an element, the function stores the address
of the terminating null wide character in the internal static-duration object (so
that a subsequent search beginning with that address will fail) and returns a
null pointer. Otherwise, the function searches from <CODE>begin</CODE> for
<CODE>end</CODE>, the address of the first element
that equals <I>any one</I> of the elements of the string <CODE>s2</CODE>.
It again considers the terminating
null wide character as part of the search string only.</LI>

<LI>If the search does not find an element, the function stores the address
of the terminating null wide character in the internal static-duration object.
Otherwise, it stores a null wide character in the element whose address is
<CODE>end</CODE>. Then it stores the address
of the next element after <CODE>end</CODE> in
the internal static-duration object
(so that a subsequent search beginning with
that address will continue with the remaining elements of the string) and
returns <CODE>begin</CODE>.</LI>
</OL>

<H2><A NAME="wcstol"></A><CODE>wcstol</CODE></H2>

<PRE>long <B>wcstol</B>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>long.</I> If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial wide characters of the wide string <CODE>s</CODE> must
match the same pattern as recognized by the function
<A HREF="stdlib.html#strtol"><CODE>strtol</CODE></A>,
with the same <CODE>base</CODE> argument,
where each wide character <CODE>wc</CODE> is converted as if by calling
<CODE><A HREF="#wctob">wctob</A>(wc))</CODE>.</P>

<P>If the wide string <CODE>s</CODE> matches this pattern,
its equivalent value is the value returned by
<A HREF="stdlib.html#strtol"><CODE>strtol</CODE></A>,
with the same <CODE>base</CODE> argument,
for the converted sequence.
If the wide string <CODE>s</CODE> does not match a valid pattern,
the value stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the equivalent value is too large
in magnitude to represent as type <I>long,</I>
<CODE>wcstol</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns either
<A HREF="limits.html#LONG_MAX"><CODE>LONG_MAX</CODE></A>
if <CODE>x</CODE> is positive or
<A HREF="limits.html#LONG_MIN"><CODE>LONG_MIN</CODE></A>
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="wcstold"></A><CODE>wcstold</CODE></H2>

<PRE>long double <B>wcstof</B>(const wchar_t *restrict nptr,
 wchar_t **restrict endptr);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>long double.</I> If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial wide characters of the wide string <CODE>s</CODE> must
match the same pattern as recognized by the function
<A HREF="stdlib.html#strtod"><CODE>strtod</CODE></A>,
where each wide character <CODE>wc</CODE> is converted as if by calling
<CODE><A HREF="#wctob">wctob</A>(wc))</CODE>.</P>

<P>If the wide string <CODE>s</CODE> matches this pattern,
its equivalent value is the value returned by
<A HREF="stdlib.html#strtold"><CODE>strtold</CODE></A>
for the converted sequence.
If the wide string <CODE>s</CODE> does not match a valid pattern,
the value stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>wcstod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="wcstoll"></A><CODE>wcstoll</CODE></H2>

<PRE>long long <B>wcstoll</B>(const wchar_t *restrict nptr, wchar_t **restrict endptr,
    int base);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>long long.</I> If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial wide characters of the wide string <CODE>s</CODE> must
match the same pattern as recognized by the function
<A HREF="stdlib.html#strtol"><CODE>strtol</CODE></A>,
with the same <CODE>base</CODE> argument,
where each wide character <CODE>wc</CODE> is converted as if by calling
<CODE><A HREF="#wctob">wctob</A>(wc))</CODE>.</P>

<P>If the wide string <CODE>s</CODE> matches this pattern,
its equivalent value is the value returned by
<A HREF="stdlib.html#strtoll"><CODE>strtoll</CODE></A>,
with the same <CODE>base</CODE> argument,
for the converted sequence.
If the wide string <CODE>s</CODE> does not match a valid pattern,
the value stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the equivalent value is too large
in magnitude to represent as type <I>long long,</I>
<CODE>wcstoll</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns either
<A HREF="limits.html#LLONG_MAX"><CODE>LLONG_MAX</CODE></A>
if <CODE>x</CODE> is positive or
<A HREF="limits.html#LLONG_MIN"><CODE>LLONG_MIN</CODE></A>
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="wcstoul"></A><CODE>wcstoul</CODE></H2>

<PRE>unsigned long <B>wcstoul</B>(const wchar_t *restrict nptr,
     wchar_t **restrict endptr, int base);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>unsigned long.</I> If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P><CODE>wcstoul</CODE> converts strings exactly as does
<A HREF="#wcstol"><CODE>wcstol</CODE></A>,
but checks only if the equivalent value is too large
to represent as type <I>unsigned long.</I>
In this case, <CODE>wcstoul</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULONG_MAX"><CODE>ULONG_MAX</CODE></A>.</P>

<H2><A NAME="wcstoull"></A><CODE>wcstoull</CODE></H2>

<PRE>unsigned long long <B>wcstoull</B>(const wchar_t *restrict nptr,
     wchar_t **restrict endptr, int base);</PRE>

<P>The function converts the initial wide characters of the wide
string <CODE>s</CODE> to an equivalent value <CODE>x</CODE>
of type <I>unsigned long long.</I> If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the wide string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P><CODE>wcstoull</CODE> converts strings exactly as does
<A HREF="#wcstoll"><CODE>wcstoll</CODE></A>,
but checks only if the equivalent value is too large
to represent as type <I>unsigned long long.</I>
In this case, <CODE>wcstoull</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULLONG_MAX"><CODE>ULLONG_MAX</CODE></A>.</P>

<H2><A NAME="wcsxfrm"></A><CODE>wcsxfrm</CODE></H2>

<PRE>size_t <B>wcsxfrm</B>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);</PRE>

<P>The function stores a wide string in the array
whose first element has the address <CODE>s1</CODE>. It stores no more than
<CODE>n</CODE> wide characters, <I>including</I> the terminating null wide
character, and returns the number of wide characters needed to represent
the entire wide string, <I>not</I> including the terminating null
wide character. If the value returned is <CODE>n</CODE> or greater, the
values stored in the array are indeterminate. (If <CODE>n</CODE> is zero,
<CODE>s1</CODE> can be a null pointer.)</P>

<P><CODE>wcsxfrm</CODE> generates the wide string it stores from the
wide string <CODE>s2</CODE> by using a transformation rule that depends
on the current
<A HREF="charset.html#locale">locale</A>.
For example, if <CODE>x</CODE> is a transformation
of <CODE>s1</CODE> and <CODE>y</CODE> is a transformation
of <CODE>s2</CODE>, then
<CODE><A HREF="#wcscmp">wcscmp</A>(x, y)</CODE>
returns the same value as
<CODE><A HREF="#wcscoll">wcscoll</A>(s1, s2)</CODE>.</P>

<H2><A NAME="wctob"></A><CODE>wctob</CODE></H2>

<PRE>int <B>wctob</B>(wint_t c);</PRE>

<P>The function determines whether <CODE>c</CODE> can be represented
as a one-byte multibyte character <CODE>x</CODE>, beginning in the
<A HREF="charset.html#initial_shift_state">initial shift state</A>.
(It effectively calls
<A HREF="#wcrtomb"><CODE>wcrtomb</CODE></A>
to make the conversion.) If so, the function returns
<CODE>x</CODE>. Otherwise, it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="WEOF"></A><CODE>WEOF</CODE></H2>

<PRE>#define <B>WEOF</B> <I>&lt;</I>wint_t <I>constant expression&gt;</I></PRE>

<P>The macro yields the return value, of type
<A HREF="#wint_t"><CODE>wint_t</CODE></A>,
used to signal the end of a
<A HREF="lib_file.html#wide_stream">wide stream</A>
or to report an error condition.</P>

<H2><A NAME="wint_t"></A><CODE>wint_t</CODE></H2>

<PRE>typedef <I>i_type</I> <B>wint_t;</B></PRE>

<P>The type is the integer type <CODE><I>i_type</I></CODE>
that can represent all values of type
<A HREF="#wchar_t"><CODE>wchar_t</CODE></A>
as well as the value of the macro
<A HREF="#WEOF"><CODE>WEOF</CODE></A>,
and that doesn't change when
<A HREF="express.html#Promoting">promoted</A>.</P>

<H2><A NAME="wmemchr"></A><CODE>wmemchr</CODE></H2>

<PRE>wchar_t *<B>wmemchr</B>(const wchar_t *s, wchar_t c,
    size_t n); <B>[not in C++]</B>
const wchar_t *<B>wmemchr</B>(const wchar_t *s, wchar_t c,
    size_t n); <B>[C++ only]</B>
wchar_t *<B>wmemchr</B>(wchar_t *s, wchar_t c,
    size_t n); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of an array
beginning at the address <CODE>s</CODE> with size <CODE>n</CODE>,
that equals <CODE>c</CODE>. If successful,
it returns the address of the matching element;
otherwise, it returns a null pointer.</P>

<H2><A NAME="wmemcmp"></A><CODE>wmemcmp</CODE></H2>

<PRE>int <B>wmemcmp</B>(const wchar_t *s1, const wchar_t *s2,
    size_t n);</PRE>

<P>The function compares successive elements from two arrays
beginning at the addresses <CODE>s1</CODE> and <CODE>s2</CODE>
(both of size <CODE>n</CODE>),
until it finds elements that are not equal:</P>

<UL>
<LI>If all elements are equal, the function returns zero.</LI>

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE>, the function returns a positive number.</LI>

<LI>Otherwise, the function returns a negative number.</LI>
</UL>

<H2><A NAME="wmemcpy"></A><CODE>wmemcpy</CODE></H2>

<PRE>wchar_t *<B>wmemcpy</B>(wchar_t *restrict s1, const wchar_t *restrict s2,
    size_t n);</PRE>

<P>The function copies the array beginning at
the address <CODE>s2</CODE> to the array beginning at
the address <CODE>s1</CODE> (both of size <CODE>n</CODE>).
It returns <CODE>s1</CODE>.
The elements of the arrays can be accessed and stored in any order.</P>

<H2><A NAME="wmemcpy_s"></A><CODE>wmemcpy_s</CODE></H2>

<PRE>errno_t <B>wmemcpy_s</B>(wchar_t *restrict s1, rsize_t maxsize,
    const wchar_t *restrict s2, size_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than <CODE>maxsize</CODE></LI>

<LI>the array of <CODE>n</CODE> <CODE>wchar_t</CODE> beginning at the address
<CODE>s1</CODE> overlaps the array of <CODE>n</CODE> <CODE>wchar_t</CODE> beginning
at the address <CODE>s2</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores null wide characters in the first <CODE>maxsize</CODE>
elements of the array of <I>char</I> beginning at the address <CODE>s1</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the array of <CODE>wchar_t</CODE>
beginning at the address
<CODE>s2</CODE> to the array of <CODE>wchar_t</CODE> beginning at the address
<CODE>s1</CODE> (both of size <CODE>n</CODE>). It returns zero.</P>

<H2><A NAME="wmemmove"></A><CODE>wmemmove</CODE></H2>

<PRE>wchar_t *<B>wmemmove</B>(wchar_t *s1, const wchar_t *s2,
    size_t n);</PRE>

<P>The function copies the array beginning at
<CODE>s2</CODE> to the array beginning at <CODE>s1</CODE> (both
of size <CODE>n</CODE>). It returns <CODE>s1</CODE>.
If the arrays overlap, the
function accesses each of the element values from <CODE>s2</CODE> before
it stores a new value in that element, so the copy is not corrupted.</P>

<H2><A NAME="wmemmove_s"></A><CODE>wmemmove_s</CODE></H2>

<PRE>errno_t <B>wmemmove_s</B>(wchar_t *s1, rsize_t maxsize,
    const wchar_t *s2, size_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s1</CODE> is a null pointer</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s2</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than <CODE>maxsize</CODE></LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores null characters in the first <CODE>maxsize</CODE>
elements of the array of <CODE>wchar_t</CODE> beginning at the address <CODE>s1</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function copies the array of <CODE>wchar_t</CODE> beginning at
<CODE>s2</CODE> to the array of <CODE>wchar_t</CODE> beginning at <CODE>s1</CODE>
(both of size <CODE>n</CODE>). It returns zero. If the arrays
overlap, the function accesses each of the element values from
<CODE>s2</CODE> before it stores a new value in that element, so the copy is
not corrupted.</P>

<H2><A NAME="wmemset"></A><CODE>wmemset</CODE></H2>

<PRE>wchar_t *<B>wmemset</B>(wchar_t *s, wchar_t c, size_t n);</PRE>

<P>The function stores <CODE>c</CODE> in each of the elements of the
array beginning at <CODE>s</CODE>, with size <CODE>n</CODE>.
It returns <CODE>s</CODE>.</P>

<H2><A NAME="wprintf"></A><CODE>wprintf</CODE></H2>

<PRE>int <B>wprintf</B>(const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream
<A HREF="stdio.html#stdout"><CODE>stdout</CODE></A>. It returns the
number of wide characters generated, or it returns a negative value
if the function sets the error indicator for the stream.</P>

<H2><A NAME="wprintf_s"></A><CODE>wprintf_s</CODE></H2>

<PRE>int <B>wprintf_s</B>(const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated wide character to the stream
<A HREF="stdio.html#stdout"><CODE>stdout</CODE></A>.
It returns the number of wide characters generated,
or it returns a negative value if the function
sets the error indicator for the stream.</P>

<H2><A NAME="wscanf"></A><CODE>wscanf</CODE></H2>

<PRE>int <B>wscanf</B>(const wchar_t *restrict format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream
<A HREF="stdio.html#stdin"><CODE>stdin</CODE></A>. It returns the
number of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A>
if the function does not store values before it sets the end-of-file
or error indicators for the stream.</P>

<H2><A NAME="wscanf_s"></A><CODE>wscanf_s</CODE></H2>

<PRE>int <B>wscanf_s</B>(const wchar_t *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned wide character from the stream
<A HREF="stdio.html#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="stdio.html#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
