<HTML><HEAD>
<TITLE>&lt;slist&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;slist&gt;"></A><CODE>&lt;slist&gt;</CODE></H1><HR>

<P>Include the nonstandard header
<B><CODE>&lt;slist&gt;</CODE></B> to define the
<A HREF="lib_cont.html#Containers">container</A>
template class <CODE>slist</CODE> and several supporting
templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Alloc&gt;
    class <B><A HREF="#slist">slist</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const slist&lt;Ty, Alloc&gt;&amp; left,
        const slist&lt;Ty, Alloc&gt;&amp; right);

template&lt;class Ty, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(
        slist&lt;Ty, Alloc&gt;&amp; left,
        slist&lt;Ty, Alloc&gt;&amp; right);
}  // namespace std</PRE>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator!=</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator==</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#slist"><CODE>slist</CODE></A>. The function returns
<CODE>left.<A HREF="#slist__size">size</A>() == right.size() &amp;&amp;
<A HREF="algorith.html#equal">equal</A>(left.
<A HREF="#slist__begin">begin</A>(), left.
<A HREF="#slist__end">end</A>(), right.begin())</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#slist"><CODE>slist</CODE></A>. The function returns
<CODE><A HREF="algorith.html#lexicographical_compare">lexicographical_compare</A>(left.
<A HREF="#slist__begin">begin</A>(), left.
<A HREF="#slist__end">end</A>(), right.begin(), right.end())</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const slist &lt;Ty, Alloc&gt;&amp; left,
        const slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="slist"></A><CODE>slist</CODE></H2>

<HR>
<P><B><CODE><A HREF="#slist__allocator_type">allocator_type</A>
&middot; <A HREF="#slist__assign">assign</A>
&middot; <A HREF="#slist__back">back</A>
&middot; <A HREF="#slist__begin">begin</A>
&middot; <A HREF="#slist__clear">clear</A>
&middot; <A HREF="#slist__const_iterator">const_iterator</A>
&middot; <A HREF="#slist__const_pointer">const_pointer</A>
&middot; <A HREF="#slist__const_reference">const_reference</A>
&middot; <A HREF="#slist__difference_type">difference_type</A>
&middot; <A HREF="#slist__empty">empty</A>
&middot; <A HREF="#slist__end">end</A>
&middot; <A HREF="#slist__erase">erase</A>
&middot; <A HREF="#slist__front">front</A>
&middot; <A HREF="#slist__get_allocator">get_allocator</A>
&middot; <A HREF="#slist__insert">insert</A>
&middot; <A HREF="#slist__iterator">iterator</A>
&middot; <A HREF="#slist__slist">slist</A>
&middot; <A HREF="#slist__max_size">max_size</A>
&middot; <A HREF="#slist__merge">merge</A>
&middot; <A HREF="#slist__operator2">operator=</A>
&middot; <A HREF="#slist__pointer">pointer</A>
&middot; <A HREF="#slist__pop_back">pop_back</A>
&middot; <A HREF="#slist__pop_front">pop_front</A>
&middot; <A HREF="#slist__previous">previous</A>
&middot; <A HREF="#slist__push_back">push_back</A>
&middot; <A HREF="#slist__push_front">push_front</A>
&middot; <A HREF="#slist__reference">reference</A>
&middot; <A HREF="#slist__remove">remove</A>
&middot; <A HREF="#slist__remove_if">remove_if</A>
&middot; <A HREF="#slist__resize">resize</A>
&middot; <A HREF="#slist__reverse">reverse</A>
&middot; <A HREF="#slist__size">size</A>
&middot; <A HREF="#slist__size_type">size_type</A>
&middot; <A HREF="#slist__sort">sort</A>
&middot; <A HREF="#slist__splice">splice</A>
&middot; <A HREF="#slist__swap">swap</A>
&middot; <A HREF="#slist__unique">unique</A>
&middot; <A HREF="#slist__value_type">value_type</A>
</CODE></B></P>
<HR> 

<PRE>template&lt;class Ty, class Alloc = allocator&lt;Ty&gt; &gt;
    class <B>slist</B> {
public:
    typedef Alloc <B><A HREF="#slist__allocator_type">allocator_type</A></B>;
    typedef typename Alloc::pointer <B><A HREF="#slist__pointer">pointer</A></B>;
    typedef typename Alloc::const_pointer
        <B><A HREF="#slist__const_pointer">const_pointer</A></B>;
    typedef typename Alloc::reference <B><A HREF="#slist__reference">reference</A></B>;
    typedef typename Alloc::const_reference <B><A HREF="#slist__const_reference">const_reference</A></B>;
    typedef typename Alloc::value_type <B><A HREF="#slist__value_type">value_type</A></B>;
    typedef typename Alloc::size_type <B><A HREF="#slist__size_type">size_type</A></B>;
    typedef typename Alloc::difference_type <B><A HREF="#slist__difference_type">difference_type</A></B>;

    typedef T0 <B><A HREF="#slist__iterator">iterator</A></B>;
    typedef T1 <B><A HREF="#slist__const_iterator">const_iterator</A></B>;

    <B><A HREF="#slist__slist">slist</A></B>();
    explicit <B><A HREF="#slist__slist">slist</A></B>(const Alloc&amp; al);
    explicit <B><A HREF="#slist__slist">slist</A></B>(size_type n);
    <B><A HREF="#slist__slist">slist</A></B>(size_type n, const Ty&amp; val);
    <B><A HREF="#slist__slist">slist</A></B>(size_type n, const Ty&amp; val, const Alloc&amp; al);
    <B><A HREF="#slist__slist">slist</A></B>(const slist&amp; right);
    template&lt;class InIt&gt;
        <B><A HREF="#slist__slist">slist</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#slist__slist">slist</A></B>(InIt first, InIt last, const Alloc&amp; al);
 
    slist&amp; <B><A HREF="#slist__operator2">operator=</A></B>(const slist&amp; right);

   iterator <B><A HREF="#slist__begin">begin</A></B>();
    const_iterator <B><A HREF="#slist__begin">begin</A></B>() const;
    iterator <B><A HREF="#slist__end">end</A></B>();
    const_iterator <B><A HREF="#slist__end">end</A></B>() const;

    iterator <B><A HREF="#slist__previous">previous</A></B>(const_iterator it);
    const_iterator <B><A HREF="#slist__previous">previous</A></B>(const_iterator it) const;

    void <B><A HREF="#slist__resize">resize</A></B>(size_type n);
    void <B><A HREF="#slist__resize">resize</A></B>(size_type n, const Ty&amp; x);
    size_type <B><A HREF="#slist__size">size</A></B>() const;
    size_type <B><A HREF="#slist__max_size">max_size</A></B>() const;
    bool <B><A HREF="#slist__empty">empty</A></B>() const;

    Alloc <B><A HREF="#slist__get_allocator">get_allocator</A></B>() const;

    reference <B><A HREF="#slist__front">front</A></B>();
    const_reference <B><A HREF="#slist__front">front</A></B>() const;
    reference <B><A HREF="#slist__back">back</A></B>();
    const_reference <B><A HREF="#slist__back">back</A></B>() const;

    void <B><A HREF="#slist__push_front">push_front</A></B>(const Ty&amp; xVAL);
    void <B><A HREF="#slist__pop_front">pop_front</A></B>();

    void <B><A HREF="#slist__push_back">push_back</A></B>(const Ty&amp; val);
    void <B><A HREF="#slist__pop_back">pop_back</A></B>();

    template&lt;class InIt&gt;
        void <B><A HREF="#slist__assign">assign</A></B>(InIt first, InIt last);
    void <B><A HREF="#slist__assign">assign</A></B>(size_type n, const Ty&amp; x);

    iterator <B><A HREF="#slist__insert">insert</A></B>(const_iterator where, const Ty&amp; x);
    void <B><A HREF="#slist__insert">insert</A></B>(const_iterator where, size_type n, const Ty&amp; x);
    template&lt;class InIt&gt;
        void <B><A HREF="#slist__insert">insert</A></B>(const_iterator where, InIt first, InIt last);

    iterator <B><A HREF="#slist__erase">erase</A></B>(const_iterator where);
    iterator <B><A HREF="#slist__erase">erase</A></B>(const_iterator first, const_iterator last);
    void <B><A HREF="#slist__clear">clear</A></B>();

    void <B><A HREF="#slist__swap">swap</A></B>(slist&amp; right);

    void <B><A HREF="#slist__splice">splice</A></B>(const_iterator where, slist&amp; x);
    void <B><A HREF="#slist__splice">splice</A></B>(const_iterator where, slist&amp; x, iterator first);
    void <B><A HREF="#slist__splice">splice</A></B>(const_iterator where, slist&amp; x, iterator first,
        iterator last);

    void <B><A HREF="#slist__remove">remove</A></B>(const Ty&amp; x);
    template&lt;class Pred&gt;
        void <B><A HREF="#slist__remove_if">remove_if</A></B>(Pred pr);
    void <B><A HREF="#slist__unique">unique</A></B>();
    template&lt;class Pred&gt;
        void <B><A HREF="#slist__unique">unique</A></B>(Pred pr);

    void <B><A HREF="#slist__merge">merge</A></B>(slist&amp; x);
    template&lt;class Pred&gt;
        void <B><A HREF="#slist__merge">merge</A></B>(slist&amp; x, Pred pr);
    void <B><A HREF="#slist__sort">sort</A></B>();
    template&lt;class Pred&gt;
        void <B><A HREF="#slist__sort">sort</A></B>(Pred pr);
    void <B><A HREF="#slist__reverse">reverse</A></B>();
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type <CODE>Ty</CODE>.
The sequence is stored as a singly linked list of elements,
each containing a member of type <CODE>Ty</CODE>.</P>

<P>The object allocates and frees storage for the sequence it controls
through a stored <A HREF="memory.html#allocator_object">allocator object</A>
of class <CODE>Alloc</CODE>. Such an allocator object must have
the same external interface as an object of template class
<A HREF="memory.html#allocator"><CODE>allocator</CODE></A>.
Note that the stored allocator object is <I>not</I> copied when the container
object is assigned.</P>

<P><B><A NAME="slist_reallocation"></A>List reallocation</B>
occurs when a member function must insert, erase or splice elements of
the controlled sequence. In all such cases, only the following iterators
or references become
<B><A NAME="invalid_slist_iterators"></A>invalid</B>:</P>

<UL>
<LI>iterators that designated a position
<B>immediately beyond</B> an inserted element</LI>

<LI>iterators that designate an erased element or a position
<B>immediately beyond</B> an erased element</LI>

<LI>iterators that designate a spliced element or a position
<B>immediately beyond</B> a spliced element</LI>
</UL>

<P>All additions to the controlled sequence occur as if by calls to
<CODE><A HREF="#slist__insert">insert</A></CODE>, which is the
only member function that calls the constructor
<CODE>Ty(const Ty&amp;)</CODE>. If such an expression throws
an exception, the container object inserts no new elements and rethrows
the exception. Thus, an object of template class <CODE>slist</CODE>
is left in a known state when such exceptions occur.</P>

<H3><CODE><A NAME="slist__allocator_type"></A>slist::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE> 

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P> 

<H3><CODE><A NAME="slist__assign"></A>slist::assign</CODE></H3>

<PRE>template&lt;class InIt&gt;
    void <B>assign</B>(InIt first, InIt last);
void <B>assign</B>(size_type n, const Ty&amp; x);</PRE>

<P>If <CODE>InIt</CODE> is an iterator type,
the first member function replaces the sequence
controlled by <CODE>*this</CODE> with the sequence
<CODE>[first, last)</CODE>, which must <I>not</I> overlap
the initial controlled sequence.
Otherwise, it does not participate in overload resolution.</P>

<P>The second member function replaces the sequence
controlled by <CODE>*this</CODE> with a repetition of <CODE>n</CODE>
elements of value <CODE>x</CODE>.</P>

<H3><CODE><A NAME="slist__back"></A>slist::back</CODE></H3>

<PRE>reference <B>back</B>();
const_reference <B>back</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="slist__begin"></A>slist::begin</CODE></H3>

<PRE>const_iterator <B>begin</B>() const;
iterator <B>begin</B>();</PRE>

<P>The member function returns a forward iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P> 

<H3><CODE><A NAME="slist__clear"></A>slist::clear</CODE></H3>

<PRE>void <B>clear</B>();</PRE> 

<P>The member function calls
<CODE><A HREF="#slist__erase">erase</A>(
<A HREF="#slist__begin">begin</A>(),
<A HREF="#slist__end">end</A>())</CODE>.</P> 

<H3><CODE><A NAME="slist__const_iterator"></A>slist::const_iterator</CODE></H3>

<PRE>typedef T1 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
forward iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T1</CODE>.</P> 

<H3><CODE><A NAME="slist__const_pointer"></A>slist::const_pointer</CODE></H3>

<PRE>typedef typename Alloc::const_pointer
    <B>const_pointer</B>;</PRE>

<P>The type describes an object that can serve as a constant pointer
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="slist__const_reference"></A>slist::const_reference</CODE></H3>

<PRE>typedef typename Alloc::const_reference <B>const_reference</B>;</PRE>

<P>The type describes an object that can serve as a constant reference
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="slist__difference_type"></A>slist::difference_type</CODE></H3>

<PRE>typedef typename Alloc::difference_type <B>difference_type</B>;</PRE> 

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence.</P> 

<H3><CODE><A NAME="slist__empty"></A>slist::empty</CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE> 

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="slist__end"></A>slist::end</CODE></H3>

<PRE>const_iterator <B>end</B>() const;
iterator <B>end</B>();</PRE> 

<P>The member function returns a forward iterator that points
just beyond the end of the sequence.</P> 

<H3><CODE><A NAME="slist__erase"></A>slist::erase</CODE></H3>

<PRE>iterator <B>erase</B>(const_iterator where);
iterator <B>erase</B>(const_iterator first, const_iterator last);</PRE>

<P>The first member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>. The second member function
removes the elements of the controlled sequence
in the range <CODE>[first, last)</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#slist__end">end</A>()</CODE> if no such element exists.</P>

<P>Erasing <CODE>N</CODE> elements causes
<CODE>N</CODE> destructor calls.
<A HREF="#slist_reallocation">Reallocation</A> occurs,
so iterators and references become
<A HREF="#invalid_slist_iterators">invalid</A> for the erased
elements and iterators become invalid for any remaining element
immediately beyond an erased element.</P>

<P>The member functions never throw an exception.</P>

<H3><CODE><A NAME="slist__front"></A>slist::front</CODE></H3>

<PRE>reference <B>front</B>();
const_reference <B>front</B>() const;</PRE>

<P>The member function returns a reference to the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="slist__get_allocator"></A>slist::get_allocator</CODE></H3>

<PRE>Alloc <B>get_allocator</B>() const;</PRE> 

<P>The member function returns the stored
<A HREF="memory.html#allocator_object">allocator object</A>.</P> 

<H3><CODE><A NAME="slist__insert"></A>slist::insert</CODE></H3>

<PRE>iterator <B>insert</B>(const_iterator where, const Ty&amp; x);
void <B>insert</B>(const_iterator where, size_type n, const Ty&amp; x);
template&lt;class InIt&gt;
    void <B>insert</B>(const_iterator where, InIt first, InIt last);</PRE>

<P>Each of the member functions inserts, before the element pointed to
by <CODE>where</CODE> in the controlled sequence, a sequence
specified by the remaining operands.
The first member function inserts
a single element with value <CODE>x</CODE> and returns an iterator
that designates the newly inserted element. The second member function
inserts a repetition of <CODE>n</CODE> elements of value <CODE>x</CODE>.</P>

<P>If <CODE>InIt</CODE> is an iterator type,
the third member function inserts the sequence
<CODE>[first, last)</CODE>, which must <I>not</I> overlap
the initial controlled sequence.
Otherwise, it does not participate in overload resolution.</P>


<P>Inserting <CODE>N</CODE> elements causes <CODE>N</CODE>
constructor calls.
<A HREF="#slist_reallocation">Reallocation</A> occurs,
so iterators become
<A HREF="#invalid_slist_iterators">invalid</A> for any element
that was immediately beyond <CODE>where</CODE>.</P>

<P>If an exception is thrown during the
insertion of one or more elements, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__iterator"></A>slist::iterator</CODE></H3>

<PRE>typedef T0 <B>iterator</B>;</PRE> 

<P>The type describes an object that can serve as a forward
iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T0</CODE>.</P> 

<H3><CODE><A NAME="slist__max_size"></A>slist::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const;</PRE> 

<P>The member function returns the length of the longest sequence that
the object can control.</P> 

<H3><CODE><A NAME="slist__merge"></A>slist::merge</CODE></H3>

<PRE>void <B>merge</B>(slist&amp; x);
template&lt;class Pred&gt;
    void <B>merge</B>(slist&amp; x, Pred pr);</PRE>

<P>The member functions remove all elements from the sequence
controlled by <CODE>x</CODE> and insert them in the controlled
sequence. Both sequences must be
<A HREF="lib_stl.html#sequence_ordering">ordered by</A> the same predicate,
described below. The resulting sequence is also ordered by that
predicate.</P>

<P>For the iterators <CODE>Pi</CODE> and <CODE>Pj</CODE>
designating elements at positions <CODE>i</CODE>
and <CODE>j</CODE>, the first member function imposes the
order <CODE>!(*Pj &lt; *Pi)</CODE> whenever <CODE>i &lt; j</CODE>.
(The elements are sorted in <I>ascending</I> order.)
The second member function imposes the order
<CODE>!pr(*Pj, *Pi)</CODE> whenever <CODE>i &lt; j</CODE>.</P>

<P>No pairs of elements in the original controlled sequence
are reversed in the resulting controlled sequence. If a pair
of elements in the resulting controlled sequence compares equal
(<CODE>!(*Pi &lt; *Pj) &amp;&amp; !(*Pj &lt; *Pi)</CODE>),
an element from the original controlled sequence appears before
an element from the sequence controlled by <CODE>x</CODE>.</P>


<P>An exception occurs only if <CODE>pr</CODE> throws an exception.
In that case, the controlled sequence is left in unspecified order
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__operator2"></A>slist::operator=</CODE></H3>

<PRE>slist&amp; <B>operator=</B>(const slist&amp; right);</PRE>

<P>The member operator replaces the controlled sequence
with a copy of the sequence controlled by <CODE>right</CODE>.</P>

<H3><CODE><A NAME="slist__pointer"></A>slist::pointer</CODE></H3>

<PRE>typedef typename Alloc::pointer <B>pointer</B>;</PRE> 

<P>The type describes an object that can serve as a pointer to an
element of the controlled sequence.</P> 

<H3><CODE><A NAME="slist__pop_back"></A>slist::pop_back</CODE></H3>

<PRE>void <B>pop_back</B>();</PRE>

<P>The member function removes the last element of the
controlled sequence, which must be non-empty.
This operation takes time proportional to the number of elements
in the controlled sequence (linear time complexity).</P>

<P>The member function never throws an exception.</P>

<H3><CODE><A NAME="slist__pop_front"></A>slist::pop_front</CODE></H3>

<PRE>void <B>pop_front</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty.</P>

<P>The member function never throws an exception.</P>

<H3><CODE><A NAME="slist__previous"></A>slist::previous</CODE></H3>

<PRE>iterator <B>previous</B>(const_iterator it);
const_iterator <B>previous</B>(const_iterator it) const;</PRE>

<P>The member function returns an iterator that designates the element
immediately preceding <CODE>it</CODE>, if possible; otherwise it returns
<CODE><A HREF="#slist__end">end</A>()</CODE>.
This operation takes time proportional to the number of elements
in the controlled sequence (linear time complexity).</P>

<H3><CODE><A NAME="slist__push_back"></A>slist::push_back</CODE></H3>

<PRE>void <B>push_back</B>(const Ty&amp; val);</PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__push_front"></A>slist::push_front</CODE></H3>

<PRE>void <B>push_front</B>(const Ty&amp; val);</PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the beginning of the controlled sequence.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__reference"></A>slist::reference</CODE></H3>

<PRE>typedef typename Alloc::reference <B>reference</B>;</PRE> 

<P>The type describes an object that can serve as a reference to an
element of the controlled sequence.</P> 

<H3><CODE><A NAME="slist__remove"></A>slist::remove</CODE></H3>

<PRE>void <B>remove</B>(const Ty&amp; x);</PRE>

<P>The member function removes from the controlled sequence
all elements, designated by the iterator <CODE>P</CODE>, for which
<CODE>*P == x</CODE>.</P>

<P>The member function never throws an exception.</P>

<H3><CODE><A NAME="slist__remove_if"></A>slist::remove_if</CODE></H3>

<PRE>template&lt;class Pred&gt;
    void <B>remove_if</B>(Pred pr);</PRE>

<P>The member function removes from the controlled sequence
all elements, designated by the iterator <CODE>P</CODE>, for which
<CODE>pr(*P)</CODE> is true.</P>


<P>An exception occurs only if <CODE>pr</CODE> throws an exception.
In that case, the controlled sequence is left in an unspecified state
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__resize"></A>slist::resize</CODE></H3>

<PRE>void <B>resize</B>(size_type n);
void <B>resize</B>(size_type n, const Ty&amp; x);</PRE> 

<P>The member functions both ensure that
<CODE><A HREF="#slist__size">size</A>()</CODE> henceforth
returns <CODE>n</CODE>. If it must make the controlled sequence longer,
the first member function
appends elements with value <CODE>Ty()</CODE>, while the second member function 
appends elements with value <CODE>x</CODE>.
To make the controlled sequence shorter, both member functions call
<CODE><A HREF="#slist__erase">erase</A>(begin() + n, end())</CODE>.</P> 

<H3><CODE><A NAME="slist__reverse"></A>slist::reverse</CODE></H3>

<PRE>void <B>reverse</B>();</PRE>

<P>The member function reverses the order in which elements appear
in the controlled sequence.</P>

<H3><CODE><A NAME="slist__size"></A>slist::size</CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE> 

<P>The member function returns the length of the controlled sequence.</P> 

<H3><CODE><A NAME="slist__size_type"></A>slist::size_type</CODE></H3>

<PRE>typedef typename Alloc::size_type <B>size_type</B>;</PRE> 

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence.</P> 

<H3><CODE><A NAME="slist__slist"></A>slist::slist</CODE></H3>

<PRE><B>slist</B>();
explicit <B>slist</B>(const Alloc&amp; al);
explicit <B>slist</B>(size_type n);
<B>slist</B>(size_type n, const Ty&amp; val);
<B>slist</B>(size_type n, const Ty&amp; val,
    const Alloc&amp; al);
<B>slist</B>(const slist&amp; right);
template&lt;class InIt&gt;
    <B>slist</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>slist</B>(InIt first, InIt last, const Alloc&amp; al);</PRE>

<P>All constructors store an
<A HREF="memory.html#allocator_object">allocator object</A> and
initialize the controlled sequence. The allocator object is the argument
<CODE>al</CODE>, if present. For the copy constructor, it is
<CODE>right.<A HREF="#slist__get_allocator">get_allocator</A>()</CODE>.
Otherwise, it is <CODE>Alloc()</CODE>.</P>

<P>The first two constructors specify an
empty initial controlled sequence. The third constructor specifies
a repetition of <CODE>n</CODE> elements of value <CODE>Ty()</CODE>.
The fourth and fifth constructors specify
a repetition of <CODE>n</CODE> elements of value <CODE>val</CODE>.
The sixth constructor specifies a copy of the sequence controlled by
<CODE>right</CODE>.</P>

<P>If <CODE>InIt</CODE> is an iterator type,
the next two constructors specify the sequence
<CODE>[first, last)</CODE>.
Otherwise, they do not participate in overload resolution.</P>

<H3><CODE><A NAME="slist__sort"></A>slist::sort</CODE></H3>

<PRE>void <B>sort</B>();
template&lt;class Pred&gt;
    void <B>sort</B>(Pred pr);</PRE>

<P>Both member functions order the elements in the controlled
sequence by a predicate, described below.</P>

<P>For the iterators <CODE>Pi</CODE> and <CODE>Pj</CODE>
designating elements at positions <CODE>i</CODE>
and <CODE>j</CODE>, the first member function imposes the
order <CODE>!(*Pj &lt; *Pi)</CODE> whenever <CODE>i &lt; j</CODE>.
(The elements are sorted in <I>ascending</I> order.)
The member template function imposes the order
<CODE>!pr(*Pj, *Pi)</CODE> whenever <CODE>i &lt; j</CODE>.
No ordered pairs of elements in the original controlled sequence
are reversed in the resulting controlled sequence.
(The sort is stable.)</P>


<P>An exception occurs only if <CODE>pr</CODE> throws an exception.
In that case, the controlled sequence is left in unspecified order
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__splice"></A>slist::splice</CODE></H3>

<PRE>void <B>splice</B>(const_iterator where, slist&amp; x);
void <B>splice</B>(const_iterator where, slist&amp; x, iterator first);
void <B>splice</B>(const_iterator where, slist&amp; x, iterator first,
    iterator last);</PRE>

<P>The first member function inserts the sequence controlled
by <CODE>x</CODE> before the element in the controlled sequence
pointed to by <CODE>where</CODE>. It also removes all elements from
<CODE>x</CODE>. (<CODE>&amp;x</CODE> must not equal <CODE>this</CODE>.)</P>

<P>The second member function removes the element pointed to by
<CODE>first</CODE> in the sequence controlled by <CODE>x</CODE> and
inserts it before the element in the controlled sequence
pointed to by <CODE>where</CODE>. (If <CODE>where == first || where == ++first</CODE>,
no change occurs.)</P>

<P>The third member function inserts the subrange
designated by <CODE>[first, last)</CODE> from the sequence
controlled by <CODE>x</CODE>
before the element in the controlled sequence pointed to by <CODE>where</CODE>.
It also removes the original subrange from the sequence controlled
by <CODE>x</CODE>. (If <CODE>&amp;x == this</CODE>,
the range <CODE>[first, last)</CODE> must not include the element
pointed to by <CODE>where</CODE>.)</P>

<P>If the third member function inserts
<CODE>N</CODE> elements, and <CODE>&amp;x != this</CODE>, an object of class
<CODE><A HREF="#slist__iterator">iterator</A></CODE> is
incremented <CODE>N</CODE> times.
For all <CODE>splice</CODE> member functions, if
<CODE><A HREF="#slist__get_allocator">get_allocator</A>()
== str.get_allocator()</CODE>, no exception occurs.
Otherwise, a copy and a destructor call also
occur for each inserted element.</P>

<P>Iterators or references that designate
spliced elements, or that designate the first element beyond a
sequence of spliced elements, become
<A HREF="#invalid_slist_iterators">invalid</A>.</P>

<H3><CODE><A NAME="slist__swap"></A>slist::swap</CODE></H3>

<PRE>void <B>swap</B>(slist&amp; right);</PRE> 

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. If
<CODE><A HREF="#slist__get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time,
it throws no exceptions, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.
Otherwise, it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P> 

<H3><CODE><A NAME="slist__unique"></A>slist::unique</CODE></H3>

<PRE>void <B>unique</B>();
template&lt;class Pred&gt;
    void <B><A HREF="#slist__unique">unique</A></B>(Pred pr);</PRE>

<P>The first member function removes from the controlled sequence
every element that compares equal to its preceding element.
For the iterators <CODE>Pi</CODE> and <CODE>Pj</CODE>
designating elements at positions <CODE>i</CODE>
and <CODE>j</CODE>, the second member function removes every
element for which <CODE>i + 1 == j &amp;&amp; pr(*Pi, *Pj)</CODE>.</P>


<P>For a controlled sequence of length <CODE>N</CODE>
(&gt; 0), the predicate <CODE>pr(*Pi, *Pj)</CODE>
is evaluated <CODE>N - 1</CODE> times.</P>

<P>An exception occurs only if <CODE>pr</CODE> throws an exception.
In that case, the controlled sequence is left in an unspecified state
and the exception is rethrown.</P>

<H3><CODE><A NAME="slist__value_type"></A>slist::value_type</CODE></H3>

<PRE>typedef typename Alloc::value_type <B>value_type</B>;</PRE> 

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P> 

<H2><A NAME="swap"></A><CODE>swap</CODE></H2> 

<PRE>template&lt;class Ty, class Alloc&gt;
    void <B>swap</B>(
        slist &lt;Ty, Alloc&gt;&amp; left,
        slist &lt;Ty, Alloc&gt;&amp; right);</PRE> 

<P>The template function executes
<CODE>left.<A HREF="#slist__swap">swap</A>(right)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
