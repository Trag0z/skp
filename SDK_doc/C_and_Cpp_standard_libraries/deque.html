<HTML><HEAD>
<TITLE>&lt;deque&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;deque&gt;"></A><CODE>&lt;deque&gt;</CODE></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;deque&gt;</CODE></B> to define the
<A HREF="lib_cont.html#Containers">container</A>
template class <CODE>deque</CODE> and several supporting
templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Alloc&gt;
    class <B><A HREF="#deque">deque</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);
template&lt;class Ty, class Alloc&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const deque&lt;Ty, Alloc&gt;&amp; left,
        const deque&lt;Ty, Alloc&gt;&amp; right);

template&lt;class Ty, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(
        deque&lt;Ty, Alloc&gt;&amp; left,
        deque&lt;Ty, Alloc&gt;&amp; right);
}  // namespace std</PRE>

<H2><A NAME="deque"></A><CODE>deque</CODE></H2>

<HR>
<P><B><CODE><A HREF="#deque__allocator_type">allocator_type</A>
&middot; <A HREF="#deque__assign">assign</A>
&middot; <A HREF="#deque__at">at</A>
&middot; <A HREF="#deque__back">back</A>
&middot; <A HREF="#deque__begin">begin</A>
&middot; <A HREF="#deque__cbegin">cbegin</A>
&middot; <A HREF="#deque__cend">cend</A>
&middot; <A HREF="#deque__clear">clear</A>
&middot; <A HREF="#deque__const_iterator">const_iterator</A>
&middot; <A HREF="#deque__const_pointer">const_pointer</A>
&middot; <A HREF="#deque__const_reference">const_reference</A>
&middot; <A HREF="#deque__const_reverse_iterator">const_reverse_iterator</A>
&middot; <A HREF="#deque__crbegin">crbegin</A>
&middot; <A HREF="#deque__crend">crend</A>
&middot; <A HREF="#deque__deque">deque</A>
&middot; <A HREF="#deque__difference_type">difference_type</A>
&middot; <A HREF="#deque__emplace">emplace</A>
&middot; <A HREF="#deque__emplace_back">emplace_back</A>
&middot; <A HREF="#deque__emplace_front">emplace_front</A>
&middot; <A HREF="#deque__empty">empty</A>
&middot; <A HREF="#deque__end">end</A>
&middot; <A HREF="#deque__erase">erase</A>
&middot; <A HREF="#deque__front">front</A>
&middot; <A HREF="#deque__get_allocator">get_allocator</A>
&middot; <A HREF="#deque__insert">insert</A>
&middot; <A HREF="#deque__iterator">iterator</A>
&middot; <A HREF="#deque__max_size">max_size</A>
&middot; <A HREF="#deque__operator2">operator=</A>
&middot; <A HREF="#deque__operator[]">operator[]</A>
&middot; <A HREF="#deque__pointer">pointer</A>
&middot; <A HREF="#deque__pop_back">pop_back</A>
&middot; <A HREF="#deque__pop_front">pop_front</A>
&middot; <A HREF="#deque__push_back">push_back</A>
&middot; <A HREF="#deque__push_front">push_front</A>
&middot; <A HREF="#deque__rbegin">rbegin</A>
&middot; <A HREF="#deque__reference">reference</A>
&middot; <A HREF="#deque__rend">rend</A>
&middot; <A HREF="#deque__resize">resize</A>
&middot; <A HREF="#deque__reverse_iterator">reverse_iterator</A>
&middot; <A HREF="#deque__shrink_to_fit">shrink_to_fit</A>
&middot; <A HREF="#deque__size">size</A>
&middot; <A HREF="#deque__size_type">size_type</A>
&middot; <A HREF="#deque__swap">swap</A>
&middot; <A HREF="#deque__value_type">value_type</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Ty, class Alloc = allocator&lt;Ty&gt; &gt;
    class <B>deque</B> {
public:
    typedef Alloc <B><A HREF="#deque__allocator_type">allocator_type</A></B>;
    typedef typename Alloc::pointer <B><A HREF="#deque__pointer">pointer</A></B>;
    typedef typename Alloc::const_pointer <B><A HREF="#deque__const_pointer">const_pointer</A></B>;
    typedef typename Alloc::reference <B><A HREF="#deque__reference">reference</A></B>;
    typedef typename Alloc::const_reference <B><A HREF="#deque__const_reference">const_reference</A></B>;
    typedef typename Alloc::value_type <B><A HREF="#deque__value_type">value_type</A></B>;
    typedef typename Alloc::size_type <B><A HREF="#deque__size_type">size_type</A></B>;
    typedef typename Alloc::difference_type <B><A HREF="#deque__difference_type">difference_type</A></B>;

    typedef T0 <B><A HREF="#deque__iterator">iterator</A></B>;
    typedef T1 <B><A HREF="#deque__const_iterator">const_iterator</A></B>;
    typedef reverse_iterator&lt;const_iterator&gt;
        <B><A HREF="#deque__const_reverse_iterator">const_reverse_iterator</A></B>;
    typedef reverse_iterator&lt;iterator&gt;
        <B><A HREF="#deque__reverse_iterator">reverse_iterator</A></B>;

    <B><A HREF="#deque__deque">deque</A></B>();
    explicit <B><A HREF="#deque__deque">deque</A></B>(const Alloc&amp; al);

    explicit <B><A HREF="#deque__deque">deque</A></B>(size_type count);
    <B><A HREF="#deque__deque">deque</A></B>(size_type count, const Ty&amp; val);
    <B><A HREF="#deque__deque">deque</A></B>(size_type count, const Ty&amp; val,
        const Alloc&amp; al);

    <B><A HREF="#deque__deque">deque</A></B>(const deque&amp; right);
    <B><A HREF="#deque__deque">deque</A></B>(const deque&amp; right,
        const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#deque__deque">deque</A></B>(deque&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#deque__deque">deque</A></B>(deque&amp;&amp; right,
        const Alloc&amp; al); <B>[added with C++11]</B>

    template&lt;class InIt&gt;
        <B><A HREF="#deque__deque">deque</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#deque__deque">deque</A></B>(InIt first, InIt last, const Alloc&amp; al);

    <B><A HREF="#deque__deque">deque</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#deque__deque">deque</A></B>(initializer_list&lt;Ty&gt; init,
        const Alloc&amp; al); <B>[added with C++11]</B>

    deque&amp; <B><A HREF="#deque__operator2">operator=</A></B>(const deque&amp; right);
    deque&amp; <B><A HREF="#deque__operator2">operator=</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    deque&amp; <B><A HREF="#deque__operator2">operator=</A></B>(deque&amp;&amp; right); <B>[added with C++11]</B>

    iterator <B><A HREF="#deque__begin">begin</A></B>() noexcept;
    const_iterator <B><A HREF="#deque__begin">begin</A></B>() const noexcept;
    iterator <B><A HREF="#deque__end">end</A></B>() noexcept;
    const_iterator <B><A HREF="#deque__end">end</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#deque__rbegin">rbegin</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#deque__rbegin">rbegin</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#deque__rend">rend</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#deque__rend">rend</A></B>() const noexcept;

    const_iterator <B><A HREF="#deque__cbegin">cbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_iterator <B><A HREF="#deque__cend">cend</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#deque__crbegin">crbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#deque__crend">crend</A></B>() const noexcept; <B>[added with C++11]</B>

    void <B><A HREF="#deque__shrink_to_fit">shrink_to_fit</A></B>(); <B>[added with C++11]</B>
    void <B><A HREF="#deque__resize">resize</A></B>(size_type newsize);
    void <B><A HREF="#deque__resize">resize</A></B>(size_type newsize, const Ty&amp; val);
    size_type <B><A HREF="#deque__size">size</A></B>() const noexcept;
    size_type <B><A HREF="#deque__max_size">max_size</A></B>() const noexcept;
    bool <B><A HREF="#deque__empty">empty</A></B>() const noexcept;

    Alloc <B><A HREF="#deque__get_allocator">get_allocator</A></B>() const noexcept;

    reference <B><A HREF="#deque__at">at</A></B>(size_type pos);
    const_reference <B><A HREF="#deque__at">at</A></B>(size_type pos) const;
    reference <B><A HREF="#deque__operator[]">operator[]</A></B>(size_type pos);
    const_reference <B><A HREF="#deque__operator[]">operator[]</A></B>(size_type pos) const;
    reference <B><A HREF="#deque__front">front</A></B>();
    const_reference <B><A HREF="#deque__front">front</A></B>() const;
    reference <B><A HREF="#deque__back">back</A></B>();
    const_reference <B><A HREF="#deque__back">back</A></B>() const;

    void <B><A HREF="#deque__push_front">push_front</A></B>(const Ty&amp; val);
    void <B><A HREF="#deque__push_front">push_front</A></B>(Ty&amp;&amp; val); <B>[added with C++11]</B>
    template&lt;class... Valty&gt;
        void <B><A HREF="#deque__emplace_front">emplace_front</A></B>(Valty&amp;&amp;... val); <B>[added with C++11]</B>
    void <B><A HREF="#deque__pop_front">pop_front</A></B>();

    void <B><A HREF="#deque__push_back">push_back</A></B>(const Ty&amp; val);
    void <B><A HREF="#deque__push_back">push_back</A></B>(Ty&amp;&amp; val); <B>[added with C++11]</B>
    template&lt;class... Valty&gt;
        void <B><A HREF="#deque__emplace_back">emplace_back</A></B>(Valty&amp;&amp;... val); <B>[added with C++11]</B>
    void <B><A HREF="#deque__pop_back">pop_back</A></B>();

    template&lt;class InIt&gt;
        void <B><A HREF="#deque__assign">assign</A></B>(InIt first, InIt last);
    void <B><A HREF="#deque__assign">assign</A></B>(size_type count, const Ty&amp; val);
    void <B><A HREF="#deque__assign">assign</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>

    iterator <B><A HREF="#deque__insert">insert</A></B>(const_iterator where, const Ty&amp; val);
    iterator <B><A HREF="#deque__insert">insert</A></B>(const_iterator where, size_type count, const Ty&amp; val);
    template&lt;class InIt&gt;
        iterator <B><A HREF="#deque__insert">insert</A></B>(const_iterator where, InIt first, InIt last);
    iterator <B><A HREF="#deque__insert">insert</A></B>(const iterator where,
        initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    iterator <B><A HREF="#deque__insert">insert</A></B>(const_iterator where, Ty&amp;&amp; val); <B>[added with C++11]</B>

    template&lt;class... Valty&gt;
        iterator <B><A HREF="#deque__emplace">emplace</A></B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B>

    iterator <B><A HREF="#deque__erase">erase</A></B>(const_iterator where);
    iterator <B><A HREF="#deque__erase">erase</A></B>(const_iterator first, const_iterator last);
    void <B><A HREF="#deque__clear">clear</A></B>() noexcept;

    void <B><A HREF="#deque__swap">swap</A></B>(deque&amp; right);
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type <CODE>Ty</CODE>.
The sequence is represented in a way that permits insertion
and removal of an element at either end with a single element copy
(constant time).
Such operations in the middle of the sequence require element
copies and assignments proportional to the number of elements
in the sequence (linear time).</P>

<P>The object allocates and frees storage for the sequence it controls
through a stored <A HREF="memory.html#allocator_object">allocator object</A>
of class <CODE>Alloc</CODE>. Such an allocator object must have
the same external interface as an object of template class
<A HREF="memory.html#allocator"><CODE>allocator</CODE></A>.</P>

<P><B><A NAME="deque_reallocation"></A>Deque reallocation</B>
occurs when a member function must insert or erase elements of
the controlled sequence:</P>

<UL>
<LI>If an element is inserted into an empty sequence,
or if an element is erased to leave an empty sequence, then
iterators earlier returned by
<CODE><A HREF="#deque__begin">begin</A>()</CODE> and
<CODE><A HREF="#deque__end">end</A>()</CODE> become
<B><A NAME="invalid_deque_iterators"></A>invalid</B>.</LI>

<LI>If an element is inserted at <CODE>begin()</CODE> or at
<CODE><A HREF="#deque__end">end</A>()</CODE>,
then all iterators become invalid, but no references
that designate existing elements become invalid.</LI>

<LI>If an element is erased at <CODE>begin()</CODE> or at
<CODE><A HREF="#deque__end">end</A>()</CODE>,
then only iterators and references that designate the erased element
become invalid.</LI>

<LI>Otherwise, inserting or erasing an element invalidates
all iterators and references.</LI>
</UL>

<H3><CODE><A NAME="deque__allocator_type"></A>deque::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><CODE><A NAME="deque__assign"></A>deque::assign</CODE></H3>

<PRE>template&lt;class InIt&gt;
    void <B>assign</B>(InIt first, InIt last);
void <B>assign</B>(size_type count, const Ty&amp; val);
void <B>assign</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B></PRE>

<P>If <CODE>InIt</CODE> is an iterator type,
the first member function replaces the sequence
controlled by <CODE>*this</CODE> with the sequence
<CODE>[first, last)</CODE>, which must <I>not</I> overlap
the initial controlled sequence.
Otherwise, it does not participate in overload resolution.</P>

<P>The second member function replaces the sequence
controlled by <CODE>*this</CODE> with a repetition of <CODE>count</CODE>
elements of value <CODE>val</CODE>.</P>

<P>The third member function replaces the controlled sequence
from an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>


<H3><CODE><A NAME="deque__at"></A>deque::at</CODE></H3>

<PRE>const_reference <B>at</B>(size_type pos) const;
reference <B>at</B>(size_type pos);</PRE>

<P>The member function returns a reference to the element of the
controlled sequence at position <CODE>pos</CODE>. If that position is
invalid, the function throws an object of class
<CODE>out_of_range</CODE>.</P>

<H3><CODE><A NAME="deque__back"></A>deque::back</CODE></H3>

<PRE>reference <B>back</B>();
const_reference <B>back</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="deque__begin"></A>deque::begin</CODE></H3>

<PRE>const_iterator <B>begin</B>() const noexcept;
iterator <B>begin</B>() noexcept;</PRE>

<P>The member function returns a random-access iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P>

<H3><CODE><A NAME="deque__cbegin"></A>deque::cbegin</CODE></H3>

<PRE>const_iterator <B>cbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a random-access iterator that points at the
first element of the sequence (or just beyond the end of an empty sequence).</P>

<H3><CODE><A NAME="deque__cend"></A>deque::cend</CODE></H3>

<PRE>const_reference <B>cend</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a random-access iterator that points just
beyond the end of the sequence.</P>

<H3><CODE><A NAME="deque__clear"></A>deque::clear</CODE></H3>

<PRE>void <B>clear</B>() noexcept;</PRE>

<P>The member function calls
<CODE><A HREF="#deque__erase">erase</A>(
<A HREF="#deque__begin">begin</A>(),
<A HREF="#deque__end">end</A>())</CODE>.</P>

<H3><CODE><A NAME="deque__const_iterator"></A>deque::const_iterator</CODE></H3>

<PRE>typedef T1 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
random-access iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="deque__const_pointer"></A>deque::const_pointer</CODE></H3>

<PRE>typedef typename Alloc::const_pointer <B>const_pointer</B>;</PRE>

<P>The type describes an object that can serve as a constant pointer
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="deque__const_reference"></A>deque::const_reference</CODE></H3>

<PRE>typedef typename Alloc::const_reference <B>const_reference</B>;</PRE>

<P>The type describes an object that can serve as a constant reference
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="deque__const_reverse_iterator"></A>deque::const_reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;const_iterator&gt;
    <B>const_reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant reverse
random-access iterator for the controlled sequence.</P>

<H3><CODE><A NAME="deque__crbegin"></A>deque::crbegin</CODE></H3>

<PRE>const_reverse_iterator <B>crbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points just beyond
the end of the controlled sequence. Hence, it designates the beginning
of the reverse sequence.</P>

<H3><CODE><A NAME="deque__crend"></A>deque::crend</CODE></H3>

<PRE>const_reverse_iterator <B>crend</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points at the first
element of the sequence (or just beyond the end of an empty sequence)). Hence,
it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="deque__deque"></A>deque::deque</CODE></H3>

<PRE><B>deque</B>();
explicit <B>deque</B>(const Alloc&amp; al);

explicit <B>deque</B>(size_type count);
<B>deque</B>(size_type count, const Ty&amp; val);
<B>deque</B>(size_type count, const Ty&amp; val,
    const Alloc&amp; al);

<B>deque</B>(const deque&amp; right);
<B>deque</B>(const deque&amp; right,
    const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>deque</B>(deque&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
<B>deque</B>(deque&amp;&amp; right,
    const Alloc&amp; al); <B>[added with C++11]</B>

template&lt;class InIt&gt;
    <B>deque</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>deque</B>(InIt first, InIt last, const Alloc&amp; al);

<B>deque</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
<B>deque</B>(initializer_list&lt;Ty&gt; init,
    const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>All constructors store an
<A HREF="memory.html#allocator_object">allocator object</A> and
initialize the controlled sequence. The allocator object is the argument
<CODE>al</CODE>, if present. Otherwise, for the copy and move constructors, it is
<CODE>right.<A HREF="#deque__get_allocator">get_allocator</A>()</CODE>.
Otherwise, it is <CODE>Alloc()</CODE>.</P>

<P>The first two constructors specify an
empty initial controlled sequence.</P>

<P>The next three constructors specify
a repetition of <CODE>count</CODE> elements of value <CODE>val</CODE>,
if specified. Otherwise the repeated value is <CODE>Ty()</CODE>.</P>

<P>The next four constructors specify
a copy of the sequence controlled by <CODE>right</CODE>.
The last two of these constructors are the same as the first two, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>If <CODE>InIt</CODE> is an iterator type,
the next two constructors specify the sequence
<CODE>[first, last)</CODE>.
Otherwise, they do not participate in overload resolution.</P>

<P>The last two constructors specify the initial controlled sequence
with an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<H3><CODE><A NAME="deque__difference_type"></A>deque::difference_type</CODE></H3>

<PRE>typedef typename Alloc::difference_type <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence.</P>

<H3><CODE><A NAME="deque__emplace"></A>deque::emplace</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    iterator <B>emplace</B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#deque__insert">insert</A>(where, value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<P>The member function is a
<A HREF="lib_cpp.html#variadic_templates">variadic template</A> using
<A HREF="lib_cpp.html#rvalue_references">rvalue references</A>.
It inserts an element with the constructor arguments <CODE>val...</CODE>
before the element pointed to by <CODE>where</CODE> in the controlled sequence.
It returns an iterator that designates the newly inserted element.
Its behavior is otherwise the same as
<CODE><A HREF="#deque__insert">insert</A></CODE>.</P>

<H3><CODE><A NAME="deque__emplace_back"></A>deque::emplace_back</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    void <B>emplace_back</B>(Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#deque__insert">insert</A>(end(), value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<P>Inserting the element
<A HREF="#invalid_deque_iterators">invalidates</A> all iterators,
but no references, to existing elements.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="deque__emplace_front"></A>deque::emplace_front</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    void <B>emplace_front</B>(Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#deque__insert">insert</A>(begin(), value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<P>Inserting the element
<A HREF="#invalid_deque_iterators">invalidates</A> all iterators,
but no references, to existing elements.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="deque__empty"></A>deque::empty</CODE></H3>

<PRE>bool <B>empty</B>() const noexcept;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="deque__end"></A>deque::end</CODE></H3>

<PRE>const_iterator <B>end</B>() const noexcept;
iterator <B>end</B>() noexcept;</PRE>

<P>The member function returns a random-access iterator that points
just beyond the end of the sequence.</P>

<H3><CODE><A NAME="deque__erase"></A>deque::erase</CODE></H3>

<PRE>iterator <B>erase</B>(const_iterator where);
iterator <B>erase</B>(const_iterator first, const_iterator last);</PRE>

<P>The first member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>. The second member function
removes the elements of the controlled sequence
in the range <CODE>[first, last)</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#deque__end">end</A>()</CODE> if no such element exists.</P>

<P>Removing <CODE>N</CODE> elements causes <CODE>N</CODE> destructor calls
and an assignment for each of the elements between the insertion
point and the nearer end of the sequence.
Removing an element at either end
<A HREF="#invalid_deque_iterators">invalidates</A> only iterators and
references that designate the erased elements. Otherwise,
erasing an element invalidates all iterators and references.</P>

<P>The member functions throw an exception only if a copy operation
throws an exception.</P>

<H3><CODE><A NAME="deque__front"></A>deque::front</CODE></H3>

<PRE>reference <B>front</B>();
const_reference <B>front</B>() const;</PRE>

<P>The member function returns a reference to the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="deque__get_allocator"></A>deque::get_allocator</CODE></H3>

<PRE>Alloc <B>get_allocator</B>() const noexcept;</PRE>

<P>The member function returns the stored
<A HREF="memory.html#allocator_object">allocator object</A>.</P>

<H3><CODE><A NAME="deque__insert"></A>deque::insert</CODE></H3>

<PRE>iterator <B>insert</B>(const_iterator where, const Ty&amp; val);
void <B>insert</B>(const_iterator where, size_type count, const Ty&amp; val);
template&lt;class InIt&gt;
    void <B>insert</B>(const_iterator where, InIt first, InIt last);
void <B>insert</B>(const iterator where,
    initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
iterator <B>insert</B>(const_iterator where, Ty&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>Each of the member functions inserts, before the element pointed to
by <CODE>where</CODE> in the controlled sequence, a sequence
specified by the remaining operands. It then returns an iterator
designating the first element in the inserted sequence, or <CODE>where</CODE>
if the inserted sequence is empty.</P>

<P>The first member function inserts
a single element with value <CODE>val</CODE> and returns an iterator
that designates the newly inserted element.
The second member function
inserts a repetition of <CODE>count</CODE> elements of value <CODE>val</CODE>.</P>

<P>If <CODE>InIt</CODE> is an iterator type,
the third member function inserts the sequence
<CODE>[first, last)</CODE>, which must <I>not</I> overlap
the initial controlled sequence.
Otherwise, it does not participate in overload resolution.</P>

<P>The fourth member function inserts the sequence
specified by an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The last member function is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>


<P>When inserting a single element, the number of
element copies is linear in the number of elements between the insertion
point and the nearer end of the sequence. When inserting a single element
at either end of the sequence, the amortized number of element copies
is constant. When inserting <CODE>N</CODE> elements,
the number of element copies is linear in
<CODE>N</CODE> plus the number of elements between the insertion
point and the nearer end of the sequence -- except when the template member
is specialized for <CODE>InIt</CODE> an input or forward iterator, which
behaves like <CODE>N</CODE> single insertions.
Inserting an element at either end
<A HREF="#invalid_deque_iterators">invalidates</A> all iterators,
but no references, that designate existing elements. Otherwise,
inserting an element invalidates all iterators and references.</P>

<P>If an exception is thrown during the
insertion of one or more elements, and the exception is not thrown while
copying an element, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="deque__iterator"></A>deque::iterator</CODE></H3>

<PRE>typedef T0 <B>iterator</B>;</PRE>

<P>The type describes an object that can serve as a random-access
iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T0</CODE>.</P>

<H3><CODE><A NAME="deque__max_size"></A>deque::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const noexcept;</PRE>

<P>The member function returns the length of the longest sequence that
the object can control.</P>

<H3><CODE><A NAME="deque__operator2"></A>deque::operator=</CODE></H3>

<PRE>deque&amp; <B>operator=</B>(const deque&amp; right);
deque&amp; <B>operator=</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
deque&amp; <B>operator=</B>(deque&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first member operator replaces the controlled sequence
with a copy of the sequence controlled by <CODE>right</CODE>.</P>

<P>The second member operator replaces the controlled sequence
from an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The third member operator is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="deque__operator[]"></A>deque::operator[]</CODE></H3>

<PRE>const_reference <B>operator[]</B>(size_type pos) const;
reference <B>operator[]</B>(size_type pos);</PRE>

<P>The member function returns a reference to the element of the
controlled sequence at position <CODE>pos</CODE>. If that position is
invalid, the behavior is undefined.</P>

<H3><CODE><A NAME="deque__pointer"></A>deque::pointer</CODE></H3>

<PRE>typedef typename Alloc::pointer <B>pointer</B>;</PRE>

<P>The type describes an object that can serve as a pointer to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="deque__pop_back"></A>deque::pop_back</CODE></H3>

<PRE>void <B>pop_back</B>();</PRE>

<P>The member function removes the last element of the
controlled sequence, which must be non-empty.
Removing the element
<A HREF="#invalid_deque_iterators">invalidates</A> only iterators and
references that designate the erased element.</P>

<P>The member function never throws an exception.</P>

<H3><CODE><A NAME="deque__pop_front"></A>deque::pop_front</CODE></H3>

<PRE>void <B>pop_front</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty.
Removing the element
<A HREF="#invalid_deque_iterators">invalidates</A> only iterators and
references that designate the erased element.</P>

<P>The member function never throws an exception.</P>

<H3><CODE><A NAME="deque__push_back"></A>deque::push_back</CODE></H3>

<PRE>void <B>push_back</B>(const Ty&amp; val);
void <B>push_back</B>(Ty&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<P>Inserting the element
<A HREF="#invalid_deque_iterators">invalidates</A> all iterators,
but no references, to existing elements.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="deque__push_front"></A>deque::push_front</CODE></H3>

<PRE>void <B>push_front</B>(const Ty&amp; val);
void <B>push_front</B>(Ty&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the beginning of the controlled sequence.</P>

<P>Inserting the element
<A HREF="#invalid_deque_iterators">invalidates</A> all iterators,
but no references, to existing elements.</P>

<P>If an exception is thrown, the container is left unaltered
and the exception is rethrown.</P>

<H3><CODE><A NAME="deque__rbegin"></A>deque::rbegin</CODE></H3>

<PRE>const_reverse_iterator <B>rbegin</B>() const noexcept;
reverse_iterator <B>rbegin</B>() noexcept;</PRE>

<P>The member function returns a reverse iterator that points just
beyond the end of the controlled sequence. Hence, it designates the
beginning of the reverse sequence.</P>

<H3><CODE><A NAME="deque__reference"></A>deque::reference</CODE></H3>

<PRE>typedef typename Alloc::reference <B>reference</B>;</PRE>

<P>The type describes an object that can serve as a reference to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="deque__rend"></A>deque::rend</CODE></H3>

<PRE>const_reverse_iterator <B>rend</B>() const noexcept;
reverse_iterator <B>rend</B>() noexcept;</PRE>

<P>The member function returns a reverse iterator that points at the
first element of the sequence (or just beyond the end of an empty
sequence). Hence, it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="deque__resize"></A>deque::resize</CODE></H3>

<PRE>void <B>resize</B>(size_type newsize);
void <B>resize</B>(size_type newsize, const Ty&amp; val);</PRE>

<P>The member functions both ensure that
<CODE><A HREF="#deque__size">size</A>()</CODE> henceforth
returns <CODE>newsize</CODE>. If it must make the controlled sequence longer,
the first member function
appends elements with value <CODE>Ty()</CODE>, while the second member function
appends elements with value <CODE>val</CODE>.
To make the controlled sequence shorter, both member functions call
<CODE><A HREF="#deque__erase">erase</A>(begin() + newsize, end())</CODE>.</P>

<H3><CODE><A NAME="deque__reverse_iterator"></A>deque::reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;iterator&gt;
    <B>reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a reverse
random-access iterator for the controlled sequence.</P>

<H3><CODE><A NAME="deque__shrink_to_fit"></A>deque::shrink_to_fit</CODE></H3>

<PRE>void <B>shrink_to_fit</B>();</PRE>

<P>The member function eliminates any unneeded storage in the container.</P>

<H3><CODE><A NAME="deque__size"></A>deque::size</CODE></H3>

<PRE>size_type <B>size</B>() const noexcept;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="deque__size_type"></A>deque::size_type</CODE></H3>

<PRE>typedef typename Alloc::size_type <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence.</P>

<H3><CODE><A NAME="deque__swap"></A>deque::swap</CODE></H3>

<PRE>void <B>swap</B>(deque&amp; right);</PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. If
<CODE><A HREF="#deque__get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time,
it throws no exceptions, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.
Otherwise, it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P>

<H3><CODE><A NAME="deque__value_type"></A>deque::value_type</CODE></H3>

<PRE>typedef typename Alloc::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator!=</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator==</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#deque"><CODE>deque</CODE></A>. The function returns
<CODE>left.<A HREF="#deque__size">size</A>() == right.size() &amp;&amp;
<A HREF="algorith.html#equal">equal</A>(left.
<A HREF="#deque__begin">begin</A>(), left.
<A HREF="#deque__end">end</A>(), right.begin())</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#deque"><CODE>deque</CODE></A>. The function returns
<CODE><A HREF="algorith.html#lexicographical_compare">lexicographical_compare</A>(left.
<A HREF="#deque__begin">begin</A>(), left.
<A HREF="#deque__end">end</A>(), right.begin(), right.end())</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const deque &lt;Ty, Alloc&gt;&amp; left,
        const deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="swap"></A><CODE>swap</CODE></H2>

<PRE>template&lt;class Ty, class Alloc&gt;
    void <B>swap</B>(
        deque &lt;Ty, Alloc&gt;&amp; left,
        deque &lt;Ty, Alloc&gt;&amp; right);</PRE>

<P>The template function executes
<CODE>left.<A HREF="#deque__swap">swap</A>(right)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
