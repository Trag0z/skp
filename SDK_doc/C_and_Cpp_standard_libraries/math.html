<HTML><HEAD>
<TITLE>&lt;math.h&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;math.h&gt;"></A><CODE>&lt;math.h&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#FP_FAST_FMA">FP_FAST_FMA</A>
&middot; <A HREF="#FP_FAST_FMAF">FP_FAST_FMAF</A>
&middot; <A HREF="#FP_FAST_FMAL">FP_FAST_FMAL</A>
&middot; <A HREF="#FP_ILOGB0">FP_ILOGB0</A>
&middot; <A HREF="#FP_ILOGBNAN">FP_ILOGBNAN</A>
&middot; <A HREF="#FP_INFINITE">FP_INFINITE</A>
&middot; <A HREF="#FP_NAN">FP_NAN</A>
&middot; <A HREF="#FP_NORMAL">FP_NORMAL</A>
&middot; <A HREF="#FP_SUBNORMAL">FP_SUBNORMAL</A>
&middot; <A HREF="#FP_ZERO">FP_ZERO</A>
&middot; <A HREF="#HUGE_VAL">HUGE_VAL</A>
&middot; <A HREF="#HUGE_VALF">HUGE_VALF</A>
&middot; <A HREF="#HUGE_VALL">HUGE_VALL</A>
&middot; <A HREF="#INFINITY">INFINITY</A>
&middot; <A HREF="#MATH_ERRNO">MATH_ERRNO</A>
&middot; <A HREF="#MATH_ERREXCEPT">MATH_ERREXCEPT</A>
&middot; <A HREF="#math_errhandling">math_errhandling</A>
&middot; <A HREF="#NAN_macro">NAN</A>
</CODE></B></P>

<P><B><CODE><A HREF="#FP_CONTRACT">FP_CONTRACT</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abs">abs</A>
&middot; <A HREF="#acos">acos</A>
&middot; <A HREF="#acosh">acosh</A>
&middot; <A HREF="#asin">asin</A>
&middot; <A HREF="#asinh">asinh</A>
&middot; <A HREF="#atan">atan</A>
&middot; <A HREF="#atanh">atanh</A>
&middot; <A HREF="#atan2">atan2</A>
&middot; <A HREF="#cbrt">cbrt</A>
&middot; <A HREF="#ceil">ceil</A>
&middot; <A HREF="#copysign">copysign</A>
&middot; <A HREF="#cos">cos</A>
&middot; <A HREF="#cosh">cosh</A>
&middot; <A HREF="#double_t">double_t</A>
&middot; <A HREF="#erf">erf</A>
&middot; <A HREF="#erfc">erfc</A>
&middot; <A HREF="#exp">exp</A>
&middot; <A HREF="#expm1">expm1</A>
&middot; <A HREF="#exp2">exp2</A>
&middot; <A HREF="#fabs">fabs</A>
&middot; <A HREF="#fdim">fdim</A>
&middot; <A HREF="#float_t">float_t</A>
&middot; <A HREF="#floor">floor</A>
&middot; <A HREF="#fma">fma</A>
&middot; <A HREF="#fmax">fmax</A>
&middot; <A HREF="#fmin">fmin</A>
&middot; <A HREF="#fmod">fmod</A>
&middot; <A HREF="#fpclassify">fpclassify</A>
&middot; <A HREF="#frexp">frexp</A>
&middot; <A HREF="#hypot">hypot</A>
&middot; <A HREF="#ilogb">ilogb</A>
&middot; <A HREF="#isfinite">isfinite</A>
&middot; <A HREF="#isgreater">isgreater</A>
&middot; <A HREF="#isgreaterequal">isgreaterequal</A>
&middot; <A HREF="#isinf">isinf</A>
&middot; <A HREF="#isless">isless</A>
&middot; <A HREF="#islessequal">islessequal</A>
&middot; <A HREF="#islessgreater">islessgreater</A>
&middot; <A HREF="#isnan">isnan</A>
&middot; <A HREF="#isnormal">isnormal</A>
&middot; <A HREF="#isunordered">isunordered</A>
&middot; <A HREF="#ldexp">ldexp</A>
&middot; <A HREF="#lgamma">lgamma</A>
&middot; <A HREF="#llrint">llrint</A>
&middot; <A HREF="#llround">llround</A>
&middot; <A HREF="#log">log</A>
&middot; <A HREF="#log10">log10</A>
&middot; <A HREF="#log1p">log1p</A>
&middot; <A HREF="#log2">log2</A>
&middot; <A HREF="#logb">logb</A>
&middot; <A HREF="#lrint">lrint</A>
&middot; <A HREF="#lround">lround</A>
&middot; <A HREF="#modf">modf</A>
&middot; <A HREF="#nan">nan</A>
&middot; <A HREF="#nearbyint">nearbyint</A>
&middot; <A HREF="#nextafter">nextafter</A>
&middot; <A HREF="#nexttoward">nexttoward</A>
&middot; <A HREF="#pow">pow</A>
&middot; <A HREF="#remainder">remainder</A>
&middot; <A HREF="#remquo">remquo</A>
&middot; <A HREF="#rint">rint</A>
&middot; <A HREF="#round">round</A>
&middot; <A HREF="#scalbln">scalbln</A>
&middot; <A HREF="#scalbn">scalbn</A>
&middot; <A HREF="#signbit">signbit</A>
&middot; <A HREF="#sin">sin</A>
&middot; <A HREF="#sinh">sinh</A>
&middot; <A HREF="#sqrt">sqrt</A>
&middot; <A HREF="#tan">tan</A>
&middot; <A HREF="#tanh">tanh</A>
&middot; <A HREF="#tgamma">tgamma</A>
&middot; <A HREF="#trunc">trunc</A>
</CODE></B></P>

<P><B><CODE><A HREF="#acosf">acosf</A>
&middot; <A HREF="#acoshf">acoshf</A>
&middot; <A HREF="#asinf">asinf</A>
&middot; <A HREF="#asinhf">asinhf</A>
&middot; <A HREF="#atanf">atanf</A>
&middot; <A HREF="#atanhf">atanhf</A>
&middot; <A HREF="#atan2f">atan2f</A>
&middot; <A HREF="#cbrtf">cbrtf</A>
&middot; <A HREF="#ceilf">ceilf</A>
&middot; <A HREF="#copysignf">copysignf</A>
&middot; <A HREF="#cosf">cosf</A>
&middot; <A HREF="#coshf">coshf</A>
&middot; <A HREF="#erff">erff</A>
&middot; <A HREF="#erfcf">erfcf</A>
&middot; <A HREF="#expf">expf</A>
&middot; <A HREF="#exp2f">exp2f</A>
&middot; <A HREF="#expm1f">expm1f</A>
&middot; <A HREF="#fabsf">fabsf</A>
&middot; <A HREF="#fdimf">fdimf</A>
&middot; <A HREF="#floorf">floorf</A>
&middot; <A HREF="#fmaf">fmaf</A>
&middot; <A HREF="#fmaxf">fmaxf</A>
&middot; <A HREF="#fminf">fminf</A>
&middot; <A HREF="#fmodf">fmodf</A>
&middot; <A HREF="#frexpf">frexpf</A>
&middot; <A HREF="#hypotf">hypotf</A>
&middot; <A HREF="#ilogbf">ilogbf</A>
&middot; <A HREF="#ldexpf">ldexpf</A>
&middot; <A HREF="#lgammaf">lgammaf</A>
&middot; <A HREF="#llrintf">llrintf</A>
&middot; <A HREF="#llroundf">llroundf</A>
&middot; <A HREF="#logf">logf</A>
&middot; <A HREF="#log10f">log10f</A>
&middot; <A HREF="#log1pf">log1pf</A>
&middot; <A HREF="#log2f">log2f</A>
&middot; <A HREF="#logbf">logbf</A>
&middot; <A HREF="#lrintf">lrintf</A>
&middot; <A HREF="#lroundf">lroundf</A>
&middot; <A HREF="#modff">modff</A>
&middot; <A HREF="#nanf">nanf</A>
&middot; <A HREF="#nearbyintf">nearbyintf</A>
&middot; <A HREF="#nextafterf">nextafterf</A>
&middot; <A HREF="#nexttowardf">nexttowardf</A>
&middot; <A HREF="#powf">powf</A>
&middot; <A HREF="#remainderf">remainderf</A>
&middot; <A HREF="#remquof">remquof</A>
&middot; <A HREF="#rintf">rintf</A>
&middot; <A HREF="#roundf">roundf</A>
&middot; <A HREF="#scalblnf">scalblnf</A>
&middot; <A HREF="#scalbnf">scalbnf</A>
&middot; <A HREF="#sinf">sinf</A>
&middot; <A HREF="#sinhf">sinhf</A>
&middot; <A HREF="#sqrtf">sqrtf</A>
&middot; <A HREF="#tanf">tanf</A>
&middot; <A HREF="#tanhf">tanhf</A>
&middot; <A HREF="#tgammaf">tgammaf</A>
&middot; <A HREF="#truncf">truncf</A>
</CODE></B></P>

<P><B><CODE><A HREF="#acosl">acosl</A>
&middot; <A HREF="#acoshl">acoshl</A>
&middot; <A HREF="#asinl">asinl</A>
&middot; <A HREF="#asinhl">asinhl</A>
&middot; <A HREF="#atanl">atanl</A>
&middot; <A HREF="#atanhl">atanhl</A>
&middot; <A HREF="#atan2l">atan2l</A>
&middot; <A HREF="#cbrtl">cbrtl</A>
&middot; <A HREF="#ceill">ceill</A>
&middot; <A HREF="#copysignl">copysignl</A>
&middot; <A HREF="#cosl">cosl</A>
&middot; <A HREF="#coshl">coshl</A>
&middot; <A HREF="#erfl">erfl</A>
&middot; <A HREF="#erfcl">erfcl</A>
&middot; <A HREF="#expl">expl</A>
&middot; <A HREF="#exp2l">exp2l</A>
&middot; <A HREF="#expm1l">expm1l</A>
&middot; <A HREF="#fabsl">fabsl</A>
&middot; <A HREF="#fdiml">fdiml</A>
&middot; <A HREF="#floorl">floorl</A>
&middot; <A HREF="#fmal">fmal</A>
&middot; <A HREF="#fmaxl">fmaxl</A>
&middot; <A HREF="#fminl">fminl</A>
&middot; <A HREF="#fmodl">fmodl</A>
&middot; <A HREF="#frexpl">frexpl</A>
&middot; <A HREF="#hypotl">hypotl</A>
&middot; <A HREF="#ilogbl">ilogbl</A>
&middot; <A HREF="#ldexpl">ldexpl</A>
&middot; <A HREF="#lgammal">lgammal</A>
&middot; <A HREF="#llrintl">llrintl</A>
&middot; <A HREF="#llroundl">llroundl</A>
&middot; <A HREF="#logl">logl</A>
&middot; <A HREF="#log10l">log10l</A>
&middot; <A HREF="#log1pl">log1pl</A>
&middot; <A HREF="#log2l">log2l</A>
&middot; <A HREF="#logbl">logbl</A>
&middot; <A HREF="#lrintl">lrintl</A>
&middot; <A HREF="#lroundl">lroundl</A>
&middot; <A HREF="#modfl">modfl</A>
&middot; <A HREF="#nanl">nanl</A>
&middot; <A HREF="#nearbyintl">nearbyintl</A>
&middot; <A HREF="#nextafterl">nextafterl</A>
&middot; <A HREF="#nexttowardl">nexttowardl</A>
&middot; <A HREF="#powl">powl</A>
&middot; <A HREF="#remainderl">remainderl</A>
&middot; <A HREF="#remquol">remquol</A>
&middot; <A HREF="#rintl">rintl</A>
&middot; <A HREF="#roundl">roundl</A>
&middot; <A HREF="#scalblnl">scalblnl</A>
&middot; <A HREF="#scalbnl">scalbnl</A>
&middot; <A HREF="#sinl">sinl</A>
&middot; <A HREF="#sinhl">sinhl</A>
&middot; <A HREF="#sqrtl">sqrtl</A>
&middot; <A HREF="#tanl">tanl</A>
&middot; <A HREF="#tanhl">tanhl</A>
&middot; <A HREF="#tgammal">tgammal</A>
&middot; <A HREF="#truncl">truncl</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;math.h&gt;</CODE></B>
to declare a number of functions that perform
common mathematical operations on real floating-point values
(of type <I>float, double,</I> or <I>long double</I>).</P>

<P>A <B><A NAME="domain_error"></A>domain error</B>
occurs when the function is
not defined for its input argument value or values. A function can report
a domain error by storing the value of
<A HREF="errno.html#EDOM"><CODE>EDOM</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returning a particular value defined for each implementation.
Or it can raise an
invalid floating-point exception.
The macro <CODE><A HREF="#math_errhandling">math_errhandling</A></CODE>
specifies whether either or both of these approaches is taken.</P>

<P>A <B><A NAME="range_error"></A>range error</B>
occurs when the return value of the
function is defined but cannot be represented.
A function can report a range error by storing the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returning one of several values:</P>

<UL>
<LI><CODE><A HREF="#HUGE_VAL">HUGE_VAL</A></CODE>
-- if the value of a function returning <I>double</I> is positive
and too large in magnitude to represent</LI>

<LI><CODE><A HREF="#HUGE_VALF">HUGE_VALF</A></CODE>
-- if the value of a function returning <I>float</I> is positive
and too large in magnitude to represent</LI>

<LI><CODE><A HREF="#HUGE_VALL">HUGE_VALL</A></CODE>
-- if the value of a function returning <I>long double</I> is positive
and too large in magnitude to represent</LI>

<LI><CODE>-<A HREF="#HUGE_VAL">HUGE_VAL</A></CODE>
-- if the value of a function returning <I>double</I> is negative
and too large in magnitude to represent</LI>

<LI><CODE>-<A HREF="#HUGE_VALF">HUGE_VALF</A></CODE>
-- if the value of a function returning <I>float</I> is negative
and too large in magnitude to represent</LI>

<LI><CODE>-<A HREF="#HUGE_VALL">HUGE_VALL</A></CODE>
-- if the value of a function returning <I>long double</I> is negative
and too large in magnitude to represent</LI>

<LI>zero -- if the value of the function is too small to represent
with a finite value</LI>
</UL>

<P>Or it can raise an
invalid floating-point exception.
The macro <CODE><A HREF="#math_errhandling">math_errhandling</A></CODE>
specifies whether either or both of these approaches is taken.</P>

<P>The pragma:</P>

<PRE>#pragma STD <B><A NAME="FP_CONTRACT"></A>FP_CONTRACT</B> [ON|OFF|DEFAULT]</PRE>

<P>(added with C99)
controls the behavior of real floating-point expression contraction. If the parameter is
<CODE>ON</CODE>, the translator is permitted to evaluate an expression atomically,
possibly omitting rounding errors and the raising of floating-point exceptions.
If the parameter is <CODE>OFF</CODE>, contraction is disallowed.
The parameter <CODE>DEFAULT</CODE> restores the original state,
which is implementation defined.
If the pragma occurs outside an external declaration,
it remains in effect until overridden by another such pragma. If the pragma occurs
inside an external declaration, it must precede all explicit declarations and
statements within a compound statement. It remains in effect until overridden by
another such pragma or until the end of the compound statement.</P>

<P>Many of the functions declared in this header have
<B><A NAME="additional_overloads"></A>additional overloads</B> in C++,
which behave much like the
<A HREF="tgmath.html#generic_functions">generic functions</A> defined in
<CODE><A HREF="tgmath.html">&lt;tgmath.h&gt;</A></CODE>.
The following functions have such additional overloads:</P>

<PRE>acos        exp         lgamma      remquo
acosh       exp2        llrint      rint
asin        expm1       llround     round
asinh       fabs        log         scalbln
atan        fdim        log10       scalbn
atan2       floor       log1p       sin
atanh       fma         logb        sinh
cbrt        fmax        lrint       sqrt
ceil        fmin        lround      tan
copysign    fmod        nearbyint   tanh
cos         frexp       nextafter   tgamma
cosh        hypot       nexttoward  trunc
erf         ilogb       pow
erfc        ldexp       remainder</PRE>
<HR>

<PRE>    /* MACROS */
#define <A HREF="#HUGE_VAL"><B>HUGE_VAL</B></A> <I>&lt;double rvalue&gt;</I>
#define <A HREF="#HUGE_VALF"><B>HUGE_VALF</B></A> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B>
#define <A HREF="#HUGE_VALL"><B>HUGE_VALL</B></A> <I>&lt;long double rvalue&gt;</I> <B>[added with C99]</B>

#define <A HREF="#INFINITY"><B>INFINITY</B></A> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B>
#define <A HREF="#NAN_macro"><B>NAN</B></A> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B>

#define <A HREF="#FP_FAST_FMA"><B>FP_FAST_FMA</B></A> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B>
#define <A HREF="#FP_FAST_FMAF"><B>FP_FAST_FMAF</B></A> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B>
#define <A HREF="#FP_FAST_FMAL"><B>FP_FAST_FMAL</B></A> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B>

#define <A HREF="#FP_INFINITE"><B>FP_INFINITE</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#FP_NAN"><B>FP_NAN</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#FP_NORMAL"><B>FP_NORMAL</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#FP_SUBNORMAL"><B>FP_SUBNORMAL</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#FP_ZERO"><B>FP_ZERO</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>

#define <A HREF="#FP_ILOGB0"><B>FP_ILOGB0</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#FP_ILOGBNAN"><B>FP_ILOGBNAN</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B>

#define <A HREF="#MATH_ERRNO"><B>MATH_ERRNO</B></A>       1 <B>[added with C99]</B>
#define <A HREF="#MATH_ERREXCEPT"><B>MATH_ERREXCEPT</B></A>   2 <B>[added with C99]</B>
#define <A HREF="#math_errhandling"><B>math_errhandling</B></A> <I>&lt;int rvalue [0, 4)&gt;</I> <B>[added with C99]</B>

    /* TYPES */
typedef <I>f-type</I> <A HREF="#double_t"><B>double_t</B></A>; <B>[added with C99]</B>
typedef <I>f-type</I> <A HREF="#float_t"><B>float_t</B></A>; <B>[added with C99]</B>

    /* GENERIC FUNCTION MACROS  <B>[macros in C, functions in C++]</B> */
#define <A HREF="#signbit"><B>signbit</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>

#define <A HREF="#fpclassify"><B>fpclassify</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, int functions in C++]</B>
#define <A HREF="#isfinite"><B>isfinite</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isinf"><B>isinf</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isnan"><B>isnan</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isnormal"><B>isnormal</B></A>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>

#define <A HREF="#isgreater"><B>isgreater</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isgreaterequal"><B>isgreaterequal</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isless"><B>isless</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#islessequal"><B>islessequal</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#islessgreater"><B>islessgreater</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>
#define <A HREF="#isunordered"><B>isunordered</B></A>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B>

    /* FUNCTIONS */
double <A HREF="#abs"><B>abs</B></A>(double x); <B>[C++ only]</B>
float <A HREF="#abs"><B>abs</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#abs"><B>abs</B></A>(long double x); <B>[C++ only]</B>

double <A HREF="#acos"><B>acos</B></A>(double x);
float <A HREF="#acos"><B>acos</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#acos"><B>acos</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#acosf"><B>acosf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#acosl"><B>acosl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#asin"><B>asin</B></A>(double x);
float <A HREF="#asin"><B>asin</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#asin"><B>asin</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#asinf"><B>asinf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#asinl"><B>asinl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#atan"><B>atan</B></A>(double x);
float <A HREF="#atan"><B>atan</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#atan"><B>atan</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#atanf"><B>atanf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#atanl"><B>atanl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#atan2"><B>atan2</B></A>(double y, double x);
float <A HREF="#atan2"><B>atan2</B></A>(float y, float x); <B>[C++ only]</B>
long double <A HREF="#atan2"><B>atan2</B></A>(long double y, long double x); <B>[C++ only]</B>
float <A HREF="#atan2f"><B>atan2f</B></A>(float y, float x); <B>[required with C99]</B>
long double <A HREF="#atan2l"><B>atan2l</B></A>(long double y,
    long double x); <B>[required with C99]</B>

double <A HREF="#ceil"><B>ceil</B></A>(double x);
float <A HREF="#ceil"><B>ceil</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#ceil"><B>ceil</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#ceilf"><B>ceilf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#ceill"><B>ceill</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#cos"><B>cos</B></A>(double x);
float <A HREF="#cos"><B>cos</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#cos"><B>cos</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#cosf"><B>cosf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#cosl"><B>cosl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#cosh"><B>cosh</B></A>(double x);
float <A HREF="#cosh"><B>cosh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#cosh"><B>cosh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#coshf"><B>coshf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#coshl"><B>coshl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#exp"><B>exp</B></A>(double x);
float <A HREF="#exp"><B>exp</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#exp"><B>exp</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#expf"><B>expf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#expl"><B>expl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#fabs"><B>fabs</B></A>(double x);
float <A HREF="#fabs"><B>fabs</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#fabs"><B>fabs</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#fabsf"><B>fabsf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#fabsl"><B>fabsl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#floor"><B>floor</B></A>(double x);
float <A HREF="#floor"><B>floor</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#floor"><B>floor</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#floorf"><B>floorf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#floorl"><B>floorl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#fmod"><B>fmod</B></A>(double x, double y);
float <A HREF="#fmod"><B>fmod</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#fmod"><B>fmod</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#fmodf"><B>fmodf</B></A>(float x, float y); <B>[required with C99]</B>
long double <A HREF="#fmodl"><B>fmodl</B></A>(long double x,
    long double y); <B>[required with C99]</B>

double <A HREF="#frexp"><B>frexp</B></A>(double x, int *pexp);
float <A HREF="#frexp"><B>frexp</B></A>(float x, int *pexp); <B>[C++ only]</B>
long double <A HREF="#frexp"><B>frexp</B></A>(long double x, int *pexp); <B>[C++ only]</B>
float <A HREF="#frexpf"><B>frexpf</B></A>(float x, int *pexp); <B>[required with C99]</B>
long double <A HREF="#frexpl"><B>frexpl</B></A>(long double x, int *pexp); <B>[required with C99]</B>

double <A HREF="#ldexp"><B>ldexp</B></A>(double x, int ex);
float <A HREF="#ldexp"><B>ldexp</B></A>(float x, int ex); <B>[C++ only]</B>
long double <A HREF="#ldexp"><B>ldexp</B></A>(long double x, int ex); <B>[C++ only]</B>
float <A HREF="#ldexpf"><B>ldexpf</B></A>(float x, int ex); <B>[required with C99]</B>
long double <A HREF="#ldexpl"><B>ldexpl</B></A>(long double x, int ex); <B>[required with C99]</B>

double <A HREF="#log"><B>log</B></A>(double x);
float <A HREF="#log"><B>log</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#log"><B>log</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#logf"><B>logf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#logl"><B>logl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#log10"><B>log10</B></A>(double x);
float <A HREF="#log10"><B>log10</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#log10"><B>log10</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#log10f"><B>log10f</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#log10l"><B>log10l</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#modf"><B>modf</B></A>(double x, double *pint);
float <A HREF="#modf"><B>modf</B></A>(float x, float *pint); <B>[C++ only]</B>
long double <A HREF="#modf"><B>modf</B></A>(long double x,
    long double *pint); <B>[C++ only]</B>
float <A HREF="#modff"><B>modff</B></A>(float x, float *pint); <B>[required with C99]</B>
long double <A HREF="#modfl"><B>modfl</B></A>(long double x,
    long double *pint); <B>[required with C99]</B>

double <A HREF="#pow"><B>pow</B></A>(double x, double y);
float <A HREF="#pow"><B>pow</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#pow"><B>pow</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#powf"><B>powf</B></A>(float x, float y); <B>[required with C99]</B>
long double <A HREF="#powl"><B>powl</B></A>(long double x,
    long double y); <B>[required with C99]</B>

double <A HREF="#sin"><B>sin</B></A>(double x);
float <A HREF="#sin"><B>sin</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#sin"><B>sin</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#sinf"><B>sinf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#sinl"><B>sinl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#sinh"><B>sinh</B></A>(double x);
float <A HREF="#sinh"><B>sinh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#sinh"><B>sinh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#sinhf"><B>sinhf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#sinhl"><B>sinhl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#sqrt"><B>sqrt</B></A>(double x);
float <A HREF="#sqrt"><B>sqrt</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#sqrt"><B>sqrt</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#sqrtf"><B>sqrtf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#sqrtl"><B>sqrtl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#tan"><B>tan</B></A>(double x);
float <A HREF="#tan"><B>tan</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#tan"><B>tan</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#tanf"><B>tanf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#tanl"><B>tanl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#tanh"><B>tanh</B></A>(double x);
float <A HREF="#tanh"><B>tanh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#tanh"><B>tanh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#tanhf"><B>tanhf</B></A>(float x); <B>[required with C99]</B>
long double <A HREF="#tanhl"><B>tanhl</B></A>(long double x); <B>[required with C99]</B>

double <A HREF="#acosh"><B>acosh</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#acosh"><B>acosh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#acosh"><B>acosh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#acoshf"><B>acoshf</B></A>(float x);
long double <A HREF="#acoshl"><B>acoshl</B></A>(long double x);

double <A HREF="#asinh"><B>asinh</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#asinh"><B>asinh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#asinh"><B>asinh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#asinhf"><B>asinhf</B></A>(float x);
long double <A HREF="#asinhl"><B>asinhl</B></A>(long double x);

double <A HREF="#atanh"><B>atanh</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#atanh"><B>atanh</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#atanh"><B>atanh</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#atanhf"><B>atanhf</B></A>(float x);
long double <A HREF="#atanhl"><B>atanhl</B></A>(long double x);

double <A HREF="#cbrt"><B>cbrt</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#cbrt"><B>cbrt</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#cbrt"><B>cbrt</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#cbrtf"><B>cbrtf</B></A>(float x);
long double <A HREF="#cbrtl"><B>cbrtl</B></A>(long double x);

double <A HREF="#copysign"><B>copysign</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#copysign"><B>copysign</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#copysign"><B>copysign</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#copysignf"><B>copysignf</B></A>(float x, float y);
long double <A HREF="#copysignl"><B>copysignl</B></A>(long double x, long double y);

double <A HREF="#erf"><B>erf</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#erf"><B>erf</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#erf"><B>erf</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#erff"><B>erff</B></A>(float x);
long double <A HREF="#erfl"><B>erfl</B></A>(long double x);

double <A HREF="#erfc"><B>erfc</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#erfc"><B>erfc</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#erfc"><B>erfc</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#erfcf"><B>erfcf</B></A>(float x);
long double <A HREF="#erfcl"><B>erfcl</B></A>(long double x);

double <A HREF="#exp2"><B>exp2</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#exp2"><B>exp2</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#exp2"><B>exp2</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#exp2f"><B>exp2f</B></A>(float x);
long double <A HREF="#exp2l"><B>exp2l</B></A>(long double x);

double <A HREF="#expm1"><B>expm1</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#expm1"><B>expm1</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#expm1"><B>expm1</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#expm1f"><B>expm1f</B></A>(float x);
long double <A HREF="#expm1l"><B>expm1l</B></A>(long double x);

double <A HREF="#fdim"><B>fdim</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#fdim"><B>fdim</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#fdim"><B>fdim</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#fdimf"><B>fdimf</B></A>(float x, float y);
long double <A HREF="#fdiml"><B>fdiml</B></A>(long double x, long double y);

double <A HREF="#fma"><B>fma</B></A>(double x, double y, double z); <B>[all added with C99]</B>
float <A HREF="#fma"><B>fma</B></A>(float x, float y, float z); <B>[C++ only]</B>
long double <A HREF="#fma"><B>fma</B></A>(long double x, long double y, long double z); <B>[C++ only]</B>
float <A HREF="#fmaf"><B>fmaf</B></A>(float x, float y, float z);
long double <A HREF="#fmal"><B>fmal</B></A>(long double x, long double y, long double z);

double <A HREF="#fmax"><B>fmax</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#fmax"><B>fmax</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#fmax"><B>fmax</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#fmaxf"><B>fmaxf</B></A>(float x, float y);
long double <A HREF="#fmaxl"><B>fmaxl</B></A>(long double x, long double y);

double <A HREF="#fmin"><B>fmin</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#fmin"><B>fmin</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#fmin"><B>fmin</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#fminf"><B>fminf</B></A>(float x, float y);
long double <A HREF="#fminl"><B>fminl</B></A>(long double x, long double y);

double <A HREF="#hypot"><B>hypot</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#hypot"><B>hypot</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#hypot"><B>hypot</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#hypotf"><B>hypotf</B></A>(float x, float y);
long double <A HREF="#hypotl"><B>hypotl</B></A>(long double x, long double y);

int <A HREF="#ilogb"><B>ilogb</B></A>(double x); <B>[all added with C99]</B>
int <A HREF="#ilogb"><B>ilogb</B></A>(float x); <B>[C++ only]</B>
int <A HREF="#ilogb"><B>ilogb</B></A>(long double x); <B>[C++ only]</B>
int <A HREF="#ilogbf"><B>ilogbf</B></A>(float x);
int <A HREF="#ilogbl"><B>ilogbl</B></A>(long double x);

double <A HREF="#lgamma"><B>lgamma</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#lgamma"><B>lgamma</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#lgamma"><B>lgamma</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#lgammaf"><B>lgammaf</B></A>(float x);
long double <A HREF="#lgammal"><B>lgammal</B></A>(long double x);

long long <A HREF="#llrint"><B>llrint</B></A>(double x); <B>[all added with C99]</B>
long long <A HREF="#llrint"><B>llrint</B></A>(float x); <B>[C++ only]</B>
long long <A HREF="#llrint"><B>llrint</B></A>(long double x); <B>[C++ only]</B>
long long <A HREF="#llrintf"><B>llrintf</B></A>(float x);
long long <A HREF="#llrintl"><B>llrintl</B></A>(long double x);

long long <A HREF="#llround"><B>llround</B></A>(double x); <B>[all added with C99]</B>
long long <A HREF="#llround"><B>llround</B></A>(float x); <B>[C++ only]</B>
long long <A HREF="#llround"><B>llround</B></A>(long double x); <B>[C++ only]</B>
long long <A HREF="#llroundf"><B>llroundf</B></A>(float x);
long long <A HREF="#llroundl"><B>llroundl</B></A>(long double x);

double <A HREF="#log1p"><B>log1p</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#log1p"><B>log1p</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#log1p"><B>log1p</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#log1pf"><B>log1pf</B></A>(float x);
long double <A HREF="#log1pl"><B>log1pl</B></A>(long double x);

double <A HREF="#log2"><B>log2</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#log2"><B>log2</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#log2"><B>log2</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#log2f"><B>log2f</B></A>(float x);
long double <A HREF="#log2l"><B>log2l</B></A>(long double x);

double <A HREF="#logb"><B>logb</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#logb"><B>logb</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#logb"><B>logb</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#logbf"><B>logbf</B></A>(float x);
long double <A HREF="#logbl"><B>logbl</B></A>(long double x);

long <A HREF="#lrint"><B>lrint</B></A>(double x); <B>[all added with C99]</B>
long <A HREF="#lrint"><B>lrint</B></A>(float x); <B>[C++ only]</B>
long <A HREF="#lrint"><B>lrint</B></A>(long double x); <B>[C++ only]</B>
long <A HREF="#lrintf"><B>lrintf</B></A>(float x);
long <A HREF="#lrintl"><B>lrintl</B></A>(long double x);

long <A HREF="#lround"><B>lround</B></A>(double x); <B>[all added with C99]</B>
long <A HREF="#lround"><B>lround</B></A>(float x); <B>[C++ only]</B>
long <A HREF="#lround"><B>lround</B></A>(long double x); <B>[C++ only]</B>
long <A HREF="#lroundf"><B>lroundf</B></A>(float x);
long <A HREF="#lroundl"><B>lroundl</B></A>(long double x);

double <A HREF="#nan"><B>nan</B></A>(const char *str); <B>[all added with C99]</B>
float <A HREF="#nanf"><B>nanf</B></A>(const char *str);
long double <A HREF="#nanl"><B>nanl</B></A>(const char *str);

double <A HREF="#nearbyint"><B>nearbyint</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#nearbyint"><B>nearbyint</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#nearbyint"><B>nearbyint</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#nearbyintf"><B>nearbyintf</B></A>(float x);
long double <A HREF="#nearbyintl"><B>nearbyintl</B></A>(long double x);

double <A HREF="#nextafter"><B>nextafter</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#nextafter"><B>nextafter</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#nextafter"><B>nextafter</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#nextafterf"><B>nextafterf</B></A>(float x, float y);
long double <A HREF="#nextafterl"><B>nextafterl</B></A>(long double x, long double y);

double <A HREF="#nexttoward"><B>nexttoward</B></A>(double x, long double y); <B>[all added with C99]</B>
float <A HREF="#nexttoward"><B>nexttoward</B></A>(float x, long double y); <B>[C++ only]</B>
long double <A HREF="#nexttoward"><B>nexttoward</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#nexttowardf"><B>nexttowardf</B></A>(float x, long double y);
long double <A HREF="#nexttowardl"><B>nexttowardl</B></A>(long double x, long double y);

double <A HREF="#remainder"><B>remainder</B></A>(double x, double y); <B>[all added with C99]</B>
float <A HREF="#remainder"><B>remainder</B></A>(float x, float y); <B>[C++ only]</B>
long double <A HREF="#remainder"><B>remainder</B></A>(long double x, long double y); <B>[C++ only]</B>
float <A HREF="#remainderf"><B>remainderf</B></A>(float x, float y);
long double <A HREF="#remainderl"><B>remainderl</B></A>(long double x, long double y);

double <A HREF="#remquo"><B>remquo</B></A>(double x, double y, int *pquo); <B>[all added with C99]</B>
float <A HREF="#remquo"><B>remquo</B></A>(float x, float y, int *pquo); <B>[C++ only]</B>
long double <A HREF="#remquo"><B>remquo</B></A>(long double x, long double y, int *pquo); <B>[C++ only]</B>
float <A HREF="#remquof"><B>remquof</B></A>(float x, float y, int *pquo);
long double <A HREF="#remquol"><B>remquol</B></A>(long double x, long double y, int *pquo);

double <A HREF="#rint"><B>rint</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#rint"><B>rint</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#rint"><B>rint</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#rintf"><B>rintf</B></A>(float x);
long double <A HREF="#rintl"><B>rintl</B></A>(long double x);

double <A HREF="#round"><B>round</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#round"><B>round</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#round"><B>round</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#roundf"><B>roundf</B></A>(float x);
long double <A HREF="#roundl"><B>roundl</B></A>(long double x);

double <A HREF="#scalbln"><B>scalbln</B></A>(double x, long ex); <B>[all added with C99]</B>
float <A HREF="#scalbln"><B>scalbln</B></A>(float x, long ex); <B>[C++ only]</B>
long double <A HREF="#scalbln"><B>scalbln</B></A>(long double x, long ex); <B>[C++ only]</B>
float <A HREF="#scalblnf"><B>scalblnf</B></A>(float x, long ex);
long double <A HREF="#scalblnl"><B>scalblnl</B></A>(long double x, long ex);

double <A HREF="#scalbn"><B>scalbn</B></A>(double x, int ex); <B>[all added with C99]</B>
float <A HREF="#scalbn"><B>scalbn</B></A>(float x, int ex); <B>[C++ only]</B>
long double <A HREF="#scalbn"><B>scalbn</B></A>(long double x, int ex); <B>[C++ only]</B>
float <A HREF="#scalbnf"><B>scalbnf</B></A>(float x, int ex);
long double <A HREF="#scalbnl"><B>scalbnl</B></A>(long double x, int ex);

double <A HREF="#tgamma"><B>tgamma</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#tgamma"><B>tgamma</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#tgamma"><B>tgamma</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#tgammaf"><B>tgammaf</B></A>(float x);
long double <A HREF="#tgammal"><B>tgammal</B></A>(long double x);

double <A HREF="#trunc"><B>trunc</B></A>(double x); <B>[all added with C99]</B>
float <A HREF="#trunc"><B>trunc</B></A>(float x); <B>[C++ only]</B>
long double <A HREF="#trunc"><B>trunc</B></A>(long double x); <B>[C++ only]</B>
float <A HREF="#truncf"><B>truncf</B></A>(float x);
long double <A HREF="#truncl"><B>truncl</B></A>(long double x);
</PRE>

<H2><A NAME="abs"></A><CODE>abs</CODE>,
<A NAME="fabs"></A><CODE>fabs</CODE>,
<A NAME="fabsf"></A><CODE>fabsf</CODE>,
<A NAME="fabsl"></A><CODE>fabsl</CODE></H2>

<PRE>double <B>abs</B>(double x); <B>[C++ only]</B>
float <B>abs</B>(float x); <B>[C++ only]</B>
long double <B>abs</B>(long double x); <B>[C++ only]</B>
double <B>fabs</B>(double x);
float <B>fabs</B>(float x); <B>[C++ only]</B>
long double <B>fabs</B>(long double x); <B>[C++ only]</B>
float <B>fabsf</B>(float x); <B>[required with C99]</B>
long double <B>fabsl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the magnitude of <CODE>x</CODE>,
<CODE>|x|</CODE>.</P>

<H2><A NAME="acos"></A><CODE>acos</CODE>,
<A NAME="acosf"></A><CODE>acosf</CODE>,
<A NAME="acosl"></A><CODE>acosl</CODE></H2>

<PRE>double <B>acos</B>(double x);
float <B>acos</B>(float x); <B>[C++ only]</B>
long double <B>acos</B>(long double x); <B>[C++ only]</B>
float <B>acosf</B>(float x); <B>[required with C99]</B>
long double <B>acosl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the angle whose cosine is <CODE>x</CODE>, in
the range [0, pi] radians. A domain error occurs if <CODE>1 &lt; |x|</CODE>.</P>

<H2><A NAME="acosh"></A><CODE>acosh</CODE>,
<A NAME="acoshf"></A><CODE>acoshf</CODE>,
<A NAME="acoshl"></A><CODE>acoshl</CODE></H2>

<PRE>double <B>acosh</B>(double x); <B>[all added with C99]</B>
float <B>acosh</B>(float x); <B>[C++ only]</B>
long double <B>acosh</B>(long double x); <B>[C++ only]</B>
float <B>acoshf</B>(float x);
long double <B>acoshl</B>(long double x);</PRE>

<P>The function returns the hyperbolic arccosine of <CODE>x</CODE>, in
the range [0, infinity]. A domain error occurs if <CODE>x &lt; 1</CODE>.</P>

<H2><A NAME="asin"></A><CODE>asin</CODE>,
<A NAME="asinf"></A><CODE>asinf</CODE>,
<A NAME="asinl"></A><CODE>asinl</CODE></H2>

<PRE>double <B>asin</B>(double x);
float <B>asin</B>(float x); <B>[C++ only]</B>
long double <B>asin</B>(long double x); <B>[C++ only]</B>
float <B>asinf</B>(float x); <B>[required with C99]</B>
long double <B>asinl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the angle whose sine is <CODE>x</CODE>, in the
range [-pi/2, +pi/2] radians. A domain error occurs
if <CODE>1 &lt; |x|</CODE>.</P>

<H2><A NAME="asinh"></A><CODE>asinh</CODE>,
<A NAME="asinhf"></A><CODE>asinhf</CODE>,
<A NAME="asinhl"></A><CODE>asinhl</CODE></H2>

<PRE>double <B>asinh</B>(double x); <B>[all added with C99]</B>
float <B>asinh</B>(float x); <B>[C++ only]</B>
long double <B>asinh</B>(long double x); <B>[C++ only]</B>
float <B>asinhf</B>(float x);
long double <B>asinhl</B>(long double x);</PRE>

<P>The function returns the hyperbolic arcsine of <CODE>x</CODE>.</P>

<H2><A NAME="atan"></A><CODE>atan</CODE>,
<A NAME="atanf"></A><CODE>atanf</CODE>,
<A NAME="atanl"></A><CODE>atanl</CODE></H2>

<PRE>double <B>atan</B>(double x);
float <B>atan</B>(float x); <B>[C++ only]</B>
long double <B>atan</B>(long double x); <B>[C++ only]</B>
float <B>atanf</B>(float x); <B>[required with C99]</B>
long double <B>atanl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the angle whose tangent is <CODE>x</CODE>, in
the range [-pi/2, +pi/2] radians.</P>

<H2><A NAME="atan2"></A><CODE>atan2</CODE>,
<A NAME="atan2f"></A><CODE>atan2f</CODE>,
<A NAME="atan2l"></A><CODE>atan2l</CODE></H2>

<PRE>double <B>atan2</B>(double y, double x);
float <B>atan2</B>(float y, float x); <B>[C++ only]</B>
long double <B>atan2</B>(long double y, long double x); <B>[C++ only]</B>
float <B>atan2f</B>(float y, float x); <B>[required with C99]</B>
long double <B>atan2l</B>(long double y,
    long double x); <B>[required with C99]</B></PRE>

<P>The function returns the angle whose tangent is <CODE>y/x</CODE>,
in the full angular range [-pi, +pi] radians. A domain error may occur
if both <CODE>x</CODE> and <CODE>y</CODE> are zero.</P>

<H2><A NAME="atanh"></A><CODE>atanh</CODE>,
<A NAME="atanhf"></A><CODE>atanhf</CODE>,
<A NAME="atanhl"></A><CODE>atanhl</CODE></H2>

<PRE>double <B>atanh</B>(double x); <B>[all added with C99]</B>
float <B>atanh</B>(float x); <B>[C++ only]</B>
long double <B>atanh</B>(long double x); <B>[C++ only]</B>
float <B>atanhf</B>(float x);
long double <B>atanhl</B>(long double x);</PRE>

<P>The function returns the hyperbolic arctangent of <CODE>x</CODE>.
A domain error occurs if <CODE>x &lt; -1</CODE> or <CODE>+1 &lt; x</CODE>.</P>

<H2><A NAME="cbrt"></A><CODE>cbrt</CODE>,
<A NAME="cbrtf"></A><CODE>cbrtf</CODE>,
<A NAME="cbrtl"></A><CODE>cbrtl</CODE></H2>

<PRE>double <B>cbrt</B>(double x); <B>[all added with C99]</B>
float <B>cbrt</B>(float x); <B>[C++ only]</B>
long double <B>cbrt</B>(long double x); <B>[C++ only]</B>
float <B>cbrtf</B>(float x);
long double <B>cbrtl</B>(long double x);</PRE>

<P>The function returns the real cube root of <CODE>x</CODE>,
<CODE>x^(1/3)</CODE>.</P>

<H2><A NAME="ceil"></A><CODE>ceil</CODE>,
<A NAME="ceilf"></A><CODE>ceilf</CODE>,
<A NAME="ceill"></A><CODE>ceill</CODE></H2>

<PRE>double <B>ceil</B>(double x);
float <B>ceil</B>(float x); <B>[C++ only]</B>
long double <B>ceil</B>(long double x); <B>[C++ only]</B>
float <B>ceilf</B>(float x); <B>[required with C99]</B>
long double <B>ceill</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the smallest integer value not less than
<CODE>x</CODE>.</P>

<H2><A NAME="copysign"></A><CODE>copysign</CODE>,
<A NAME="copysignf"></A><CODE>copysignf</CODE>,
<A NAME="copysignl"></A><CODE>copysignl</CODE></H2>

<PRE>double <B>copysign</B>(double x, double y); <B>[all added with C99]</B>
float <B>copysign</B>(float x, float y); <B>[C++ only]</B>
long double <B>copysign</B>(long double x, long double y); <B>[C++ only]</B>
float <B>copysignf</B>(float x, float y);
long double <B>copysignl</B>(long double x, long double y);</PRE>

<P>The function returns <CODE>x</CODE>, with its sign bit replaced from
<CODE>y</CODE>.</P>

<H2><A NAME="cos"></A><CODE>cos</CODE>,
<A NAME="cosf"></A><CODE>cosf</CODE>,
<A NAME="cosl"></A><CODE>cosl</CODE></H2>

<PRE>double <B>cos</B>(double x);
float <B>cos</B>(float x); <B>[C++ only]</B>
long double <B>cos</B>(long double x); <B>[C++ only]</B>
float <B>cosf</B>(float x); <B>[required with C99]</B>
long double <B>cosl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the cosine of <CODE>x</CODE>.
If <CODE>x</CODE> is large the value returned
might not be meaningful, but the function reports no error.</P>

<H2><A NAME="cosh"></A><CODE>cosh</CODE>,
<A NAME="coshf"></A><CODE>coshf</CODE>,
<A NAME="coshl"></A><CODE>coshl</CODE></H2>

<PRE>double <B>cosh</B>(double x);
float <B>cosh</B>(float x); <B>[C++ only]</B>
long double <B>cosh</B>(long double x); <B>[C++ only]</B>
float <B>coshf</B>(float x); <B>[required with C99]</B>
long double <B>coshl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the hyperbolic cosine of <CODE>x</CODE>.</P>

<H2><A NAME="double_t"></A><CODE>double_t</CODE></H2>

<PRE>typedef <I>f-type</I> <B>double_t</B>; <B>[added with C99]</B></PRE>

<P>The type is a synonym for the floating-point type <CODE><I>f-type</I></CODE>,
which is one of:</P>

<UL>
<LI><I>double</I> if
<CODE><A HREF="float.html#FLT_EVAL_METHOD">FLT_EVAL_METHOD</A></CODE> is zero</LI>

<LI><I>double</I> if <CODE>FLT_EVAL_METHOD</CODE> is 1</LI>

<LI><I>long double</I> if <CODE>FLT_EVAL_METHOD</CODE> is 2</LI>
</UL>

<P>Otherwise, <CODE>double_t</CODE> is a real floating-point type
at least as wide as
<CODE><A HREF="#float_t">float_t</A></CODE>.</P>

<H2><A NAME="erf"></A><CODE>erf</CODE>,
<A NAME="erff"></A><CODE>erff</CODE>,
<A NAME="erfl"></A><CODE>erfl</CODE></H2>

<PRE>double <B>erf</B>(double x); <B>[all added with C99]</B>
float <B>erf</B>(float x); <B>[C++ only]</B>
long double <B>erf</B>(long double x); <B>[C++ only]</B>
float <B>erff</B>(float x);
long double <B>erfl</B>(long double x);</PRE>

<P>The function returns the error function of <CODE>x</CODE>.</P>

<H2><A NAME="erfc"></A><CODE>erfc</CODE>,
<A NAME="erfcf"></A><CODE>erfcf</CODE>,
<A NAME="erfcl"></A><CODE>erfcl</CODE></H2>

<PRE>double <B>erfc</B>(double x); <B>[all added with C99]</B>
float <B>erfc</B>(float x); <B>[C++ only]</B>
long double <B>erfc</B>(long double x); <B>[C++ only]</B>
float <B>erfcf</B>(float x);
long double <B>erfcl</B>(long double x);</PRE>

<P>The function returns the complementary error function of <CODE>x</CODE>.</P>

<H2><A NAME="exp"></A><CODE>exp</CODE>,
<A NAME="expf"></A><CODE>expf</CODE>,
<A NAME="expl"></A><CODE>expl</CODE></H2>

<PRE>double <B>exp</B>(double x);
float <B>exp</B>(float x); <B>[C++ only]</B>
long double <B>exp</B>(long double x); <B>[C++ only]</B>
float <B>expf</B>(float x); <B>[required with C99]</B>
long double <B>expl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the exponential of <CODE>x</CODE>,
e^<CODE>x</CODE>.</P>

<H2><A NAME="expm1"></A><CODE>expm1</CODE>,
<A NAME="expm1f"></A><CODE>expm1f</CODE>,
<A NAME="expm1l"></A><CODE>expm1l</CODE></H2>

<PRE>double <B>expm1</B>(double x); <B>[all added with C99]</B>
float <B>expm1</B>(float x); <B>[C++ only]</B>
long double <B>expm1</B>(long double x); <B>[C++ only]</B>
float <B>expm1f</B>(float x);
long double <B>expm1l</B>(long double x);</PRE>

<P>The function returns one less than the exponential function of <CODE>x</CODE>,
e^<CODE>x</CODE> - 1.</P>

<H2><A NAME="exp2"></A><CODE>exp2</CODE>,
<A NAME="exp2f"></A><CODE>exp2f</CODE>,
<A NAME="exp2l"></A><CODE>exp2l</CODE></H2>

<PRE>double <B>exp2</B>(double x); <B>[all added with C99]</B>
float <B>exp2</B>(float x); <B>[C++ only]</B>
long double <B>exp2</B>(long double x); <B>[C++ only]</B>
float <B>exp2f</B>(float x);
long double <B>exp2l</B>(long double x);</PRE>

<P>The function returns two raised to the power <CODE>x</CODE>,
2^<CODE>x</CODE>.</P>

<H2><A NAME="fdim"></A><CODE>fdim</CODE>,
<A NAME="fdimf"></A><CODE>fdimf</CODE>,
<A NAME="fdiml"></A><CODE>fdiml</CODE></H2>

<PRE>double <B>fdim</B>(double x, double y); <B>[all added with C99]</B>
float <B>fdim</B>(float x, float y); <B>[C++ only]</B>
long double <B>fdim</B>(long double x, long double y); <B>[C++ only]</B>
float <B>fdimf</B>(float x, float y);
long double <B>fdiml</B>(long double x, long double y);</PRE>

<P>The function returns the larger of <CODE>x - y</CODE> and zero.</P>

<H2><A NAME="float_t"></A><CODE>float_t</CODE></H2>

<PRE>typedef <I>f-type</I> <B>float_t</B>; <B>[added with C99]</B></PRE>

<P>The type is a synonym for the floating-point type <CODE><I>f-type</I></CODE>,
which is one of:</P>

<UL>
<LI><I>float</I> if
<CODE><A HREF="float.html#FLT_EVAL_METHOD">FLT_EVAL_METHOD</A></CODE> is zero</LI>

<LI><I>double</I> if <CODE>FLT_EVAL_METHOD</CODE> is 1</LI>

<LI><I>long double</I> if <CODE>FLT_EVAL_METHOD</CODE> is 2</LI>
</UL>

<P>Otherwise, <CODE>float_t</CODE> is a real floating-point type not wider than
<CODE><A HREF="#double_t">double_t</A></CODE>.</P>

<H2><A NAME="floor"></A><CODE>floor</CODE>,
<A NAME="floorf"></A><CODE>floorf</CODE>,
<A NAME="floorl"></A><CODE>floorl</CODE></H2>

<PRE>double <B>floor</B>(double x);
float <B>floor</B>(float x); <B>[C++ only]</B>
long double <B>floor</B>(long double x); <B>[C++ only]</B>
float <B>floorf</B>(float x); <B>[required with C99]</B>
long double <B>floorl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the largest integer value not greater than
<CODE>x</CODE>.</P>

<H2><A NAME="fma"></A><CODE>fma</CODE>,
<A NAME="fmaf"></A><CODE>fmaf</CODE>,
<A NAME="fmal"></A><CODE>fmal</CODE></H2>

<PRE>double <B>fma</B>(double x, double y, double z); <B>[all added with C99]</B>
float <B>fma</B>(float x, float y, float z); <B>[C++ only]</B>
long double <B>fma</B>(long double x, long double y, long double z); <B>[C++ only]</B>
float <B>fmaf</B>(float x, float y, float z);
long double <B>fmal</B>(long double x, long double y, long double z);</PRE>

<P>The function returns <CODE>x * y + z</CODE>, to arbitrary intermediate
precision.</P>

<H2><A NAME="fmax"></A><CODE>fmax</CODE>,
<A NAME="fmaxf"></A><CODE>fmaxf</CODE>,
<A NAME="fmaxl"></A><CODE>fmaxl</CODE></H2>

<PRE>double <B>fmax</B>(double x, double y); <B>[all added with C99]</B>
float <B>fmax</B>(float x, float y); <B>[C++ only]</B>
long double <B>fmax</B>(long double x, long double y); <B>[C++ only]</B>
float <B>fmaxf</B>(float x, float y);
long double <B>fmaxl</B>(long double x, long double y);</PRE>

<P>The function returns the larger (more positive) of <CODE>x</CODE> and <CODE>y</CODE>.</P>

<H2><A NAME="fmin"></A><CODE>fmin</CODE>,
<A NAME="fminf"></A><CODE>fminf</CODE>,
<A NAME="fminl"></A><CODE>fminl</CODE></H2>

<PRE>double <B>fmin</B>(double x, double y); <B>[all added with C99]</B>
float <B>fmin</B>(float x, float y); <B>[C++ only]</B>
long double <B>fmin</B>(long double x, long double y); <B>[C++ only]</B>
float <B>fminf</B>(float x, float y);
long double <B>fminl</B>(long double x, long double y);</PRE>

<P>The function returns the smaller (more negative) of <CODE>x</CODE> and <CODE>y</CODE>.</P>

<H2><A NAME="fmod"></A><CODE>fmod</CODE>,
<A NAME="fmodf"></A><CODE>fmodf</CODE>,
<A NAME="fmodl"></A><CODE>fmodl</CODE></H2>

<PRE>double <B>fmod</B>(double x, double y);
float <B>fmod</B>(float x, float y); <B>[C++ only]</B>
long double <B>fmod</B>(long double x, long double y); <B>[C++ only]</B>
float <B>fmodf</B>(float x, float y); <B>[required with C99]</B>
long double <B>fmodl</B>(long double x,
    long double y); <B>[required with C99]</B></PRE>

<P>The function returns the remainder of <CODE>x/y</CODE>,
which is defined as follows:</P>

<UL>
<LI>If <CODE>y</CODE> is zero,
the function either reports a domain error or simply returns zero.</LI>

<LI>Otherwise, the function determines the unique signed integer value
<CODE>i</CODE> such that the returned value <CODE>x - i * y</CODE> has the
same sign as <CODE>x</CODE> and magnitude less than <CODE>|y|</CODE>.</LI>
</UL>

<H2><A NAME="fpclassify"></A><CODE>fpclassify</CODE></H2>

<PRE>#define <B>fpclassify</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, int functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and evaluates to:</P>

<UL>
<LI><CODE><A HREF="#FP_INFINITE">FP_INFINITE</A></CODE> for an argument that is
positive or negative infinity</LI>

<LI><CODE><A HREF="#FP_NAN">FP_NAN</A></CODE> for an argument that is
not-a-number (NaN)</LI>

<LI><CODE><A HREF="#FP_NORMAL">FP_NORMAL</A></CODE> for an argument that is
finite and normalized</LI>

<LI><CODE><A HREF="#FP_SUBNORMAL">FP_SUBNORMAL</A></CODE> for an argument
that is finite and denormalized</LI>

<LI><CODE><A HREF="#FP_ZERO">FP_ZERO</A></CODE> for an argument that is
positive or negative zero</LI>
</UL>

<P>or possibly some other implementation-defined value.</P>

<H2><A NAME="FP_FAST_FMA"></A><CODE>FP_FAST_FMA</CODE></H2>

<PRE>#define <B>FP_FAST_FMA</B> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B></PRE>

<P>The macro is defined only if the call
<CODE><A HREF="#fma">fma</A>(x, y, z)</CODE> executes about as fast as
the <I>double</I> expression <CODE>x * y + z</CODE>.</P>

<H2><A NAME="FP_FAST_FMAF"></A><CODE>FP_FAST_FMAF</CODE></H2>

<PRE>#define <B>FP_FAST_FMAF</B> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B></PRE>

<P>The macro is defined only if the call
<CODE><A HREF="#fmaf">fmaf</A>(x, y, z)</CODE> executes about as fast as
the <I>float</I> expression <CODE>x * y + z</CODE>.</P>

<H2><A NAME="FP_FAST_FMAL"></A><CODE>FP_FAST_FMAL</CODE></H2>

<PRE>#define <B>FP_FAST_FMAL</B> <I>&lt;integer constant expression&gt;</I> <B>[optional with C99]</B></PRE>

<P>The macro is defined only if the call
<CODE><A HREF="#fmal">fmal</A>(x, y, z)</CODE> executes about as fast as
the <I>long double</I> expression <CODE>x * y + z</CODE>.</P>

<H2><A NAME="FP_ILOGB0"></A><CODE>FP_ILOGB0</CODE></H2>

<PRE>#define <B>FP_ILOGB0</B> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value returned by
<CODE><A HREF="#ilogb">ilogb</A></CODE> for an argument that is
positive or negative zero. The value of the macro is either
<CODE><A HREF="limits.html#INT_MIN">INT_MIN</A></CODE> or
<CODE>-<A HREF="limits.html#INT_MAX">INT_MAX</A></CODE>.</P>

<H2><A NAME="FP_ILOGBNAN"></A><CODE>FP_ILOGBNAN</CODE></H2>

<PRE>#define <B>FP_ILOGBNAN</B> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value returned by
<CODE><A HREF="#ilogb">ilogb</A></CODE> for an argument that is
not-a-number (NaN). The value of the macro is either
<CODE><A HREF="limits.html#INT_MIN">INT_MIN</A></CODE> or
<CODE><A HREF="limits.html#INT_MAX">INT_MAX</A></CODE>.</P>

<H2><A NAME="FP_INFINITE"></A><CODE>FP_INFINITE</CODE></H2>

<PRE>#define <B>FP_INFINITE</B> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value of the macro
<CODE><A HREF="#fpclassify">fpclassify</A></CODE> for an argument that is
positive or negative infinity.</P>

<H2><A NAME="FP_NAN"></A><CODE>FP_NAN</CODE></H2>

<PRE>#define <B>FP_NAN</B> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value of the macro
<CODE><A HREF="#fpclassify">fpclassify</A></CODE> for an argument that is
not-a-number (NaN).</P>

<H2><A NAME="FP_NORMAL"></A><CODE>FP_NORMAL</CODE></H2>

<PRE>#define <A HREF="#FP_NORMAL"><B>FP_NORMAL</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value of the macro
<CODE><A HREF="#fpclassify">fpclassify</A></CODE> for an argument that is
finite and normalized.</P>

<H2><A NAME="FP_SUBNORMAL"></A><CODE>FP_SUBNORMAL</CODE></H2>

<PRE>#define <A HREF="#FP_SUBNORMAL"><B>FP_SUBNORMAL</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value of the macro
<CODE><A HREF="#fpclassify">fpclassify</A></CODE> for an argument that is
finite and denormalized.</P>

<H2><A NAME="FP_ZERO"></A><CODE>FP_ZERO</CODE></H2>

<PRE>#define <A HREF="#FP_ZERO"><B>FP_ZERO</B></A> <I>&lt;integer constant expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro defines the value of the macro
<CODE><A HREF="#fpclassify">fpclassify</A></CODE> for an argument that is
positive or negative zero.</P>

<H2><A NAME="frexp"></A><CODE>frexp</CODE>,
<A NAME="frexpf"></A><CODE>frexpf</CODE>,
<A NAME="frexpl"></A><CODE>frexpl</CODE></H2>

<PRE>double <B>frexp</B>(double x, int *pexp);
float <B>frexp</B>(float x, int *pexp); <B>[C++ only]</B>
long double <B>frexp</B>(long double x, int *pexp); <B>[C++ only]</B>
float <B>frexpf</B>(float x, int *pexp); <B>[required with C99]</B>
long double <B>frexpl</B>(long double x, int *pexp); <B>[required with C99]</B></PRE>

<P>The function determines a fraction <CODE>frac</CODE> and an exponent integer
<CODE>ex</CODE> that represent the value of <CODE>x</CODE>.
It returns the value <CODE>frac</CODE> and stores the integer
<CODE>ex</CODE> in <CODE>*pexp</CODE>, such that:</P>

<UL>
<LI><CODE>|frac|</CODE> is in the interval [1/2, 1) or is zero</LI>

<LI><CODE>x == frac * 2^ex</CODE></LI>
</UL>

<P>If <CODE>x</CODE> is zero, <CODE>*pexp</CODE> is also zero.</P>

<H2><A NAME="HUGE_VAL"></A><CODE>HUGE_VAL</CODE></H2>

<PRE>#define <B>HUGE_VAL</B> <I>&lt;double rvalue&gt;</I></PRE>

<P>The macro yields the <I>double</I> value returned by some functions
on a range error. The value can be a representation of infinity.</P>

<H2><A NAME="HUGE_VALF"></A><CODE>HUGE_VALF</CODE></H2>

<PRE>#define <B>HUGE_VALF</B> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields the <I>float</I> value returned by some functions
on a range error. The value can be a representation of infinity.</P>

<H2><A NAME="HUGE_VALL"></A><CODE>HUGE_VALL</CODE></H2>

<PRE>#define <B>HUGE_VALL</B> <I>&lt;long double rvalue&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields the <I>long double</I> value returned by some functions
on a range error. The value can be a representation of infinity.</P>

<H2><A NAME="hypot"></A><CODE>hypot</CODE>,
<A NAME="hypotf"></A><CODE>hypotf</CODE>,
<A NAME="hypotl"></A><CODE>hypotl</CODE></H2>

<PRE>double <B>hypot</B>(double x, double y); <B>[all added with C99]</B>
float <B>hypot</B>(float x, float y); <B>[C++ only]</B>
long double <B>hypot</B>(long double x, long double y); <B>[C++ only]</B>
float <B>hypotf</B>(float x, float y);
long double <B>hypotl</B>(long double x, long double y);</PRE>

<P>The function returns the square root of <CODE>x^2 + y^2</CODE>.</P>

<H2><A NAME="ilogb"></A><CODE>ilogb</CODE>,
<A NAME="ilogbf"></A><CODE>ilogbf</CODE>,
<A NAME="ilogbl"></A><CODE>ilogbl</CODE></H2>

<PRE>int <B>ilogb</B>(double x); <B>[all added with C99]</B>
int <B>ilogb</B>(float x); <B>[C++ only]</B>
int <B>ilogb</B>(long double x); <B>[C++ only]</B>
int <B>ilogbf</B>(float x);
int <B>ilogbl</B>(long double x);</PRE>

<P>The function returns:</P>

<UL>
<LI>for <CODE>x</CODE> not-a-number (NaN), the value of the macro
<CODE><A HREF="#FP_ILOGBNAN">FP_ILOGBNAN</A></CODE></LI>

<LI>for <CODE>x</CODE> equal to zero, the value of the macro
<CODE><A HREF="#FP_ILOGB0">FP_ILOGB0</A></CODE></LI>

<LI>for <CODE>x</CODE> equal to positive or negative infinity,
the value of the macro
<CODE><A HREF="limits.html#INT_MAX">INT_MAX</A></CODE></LI>
</UL>

<P>Otherwise, it returns
<CODE>(int)<A HREF="#logb">logb</A>(x)</CODE>.</P>

<H2><A NAME="INFINITY"></A><CODE>INFINITY</CODE></H2>

<PRE>#define <B>INFINITY</B> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields a <I>float</I> value that represents positive infinity.</P>

<H2><A NAME="isfinite"></A><CODE>isfinite</CODE></H2>

<PRE>#define <B>isfinite</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and yields a nonzero value only if <CODE>x</CODE>
is finite.</P>

<H2><A NAME="isgreater"></A><CODE>isgreater</CODE></H2>

<PRE>#define <B>isgreater</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if <CODE>x &gt; y</CODE> and
neither <CODE>x</CODE> nor <CODE>y</CODE> is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="isgreaterequal"></A><CODE>isgreaterequal</CODE></H2>

<PRE>#define <B>isgreaterequal</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if <CODE>x &gt;= y</CODE> and
neither <CODE>x</CODE> nor <CODE>y</CODE> is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="isinf"></A><CODE>isinf</CODE></H2>

<PRE>#define <B>isinf</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and yields a nonzero value only if <CODE>x</CODE>
is positive or negative infinity.</P>

<H2><A NAME="isless"></A><CODE>isless</CODE></H2>

<PRE>#define <B>isless</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if <CODE>x &lt; y</CODE> and
neither <CODE>x</CODE> nor <CODE>y</CODE> is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="islessequal"></A><CODE>islessequal</CODE></H2>

<PRE>#define <B>islessequal</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if <CODE>x &lt;= y</CODE> and
neither <CODE>x</CODE> nor <CODE>y</CODE> is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="islessgreater"></A><CODE>islessgreater</CODE></H2>

<PRE>#define <B>islessgreater</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if <CODE>x &lt; y || x &gt; y</CODE> and
neither <CODE>x</CODE> nor <CODE>y</CODE> is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="isnan"></A><CODE>isnan</CODE></H2>

<PRE>#define <B>isnan</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and yields a nonzero value only if <CODE>x</CODE>
is not-a-number (NaN).</P>

<H2><A NAME="isnormal"></A><CODE>isnormal</CODE></H2>

<PRE>#define <B>isnormal</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and yields a nonzero value only if <CODE>x</CODE>
is finite and normalized.</P>

<H2><A NAME="isunordered"></A><CODE>isunordered</CODE></H2>

<PRE>#define <B>isunordered</B>(x, y) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts two rvalue arguments <CODE>x</CODE> and <CODE>y</CODE>,
at least one of which is a real floating-point type,
and yields the value 1 only if at least one of the two arguments
is not-a-number (NaN).
Otherwise, it yields the value zero. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="ldexp"></A><CODE>ldexp</CODE>,
<A NAME="ldexpf"></A><CODE>ldexpf</CODE>,
<A NAME="ldexpl"></A><CODE>ldexpl</CODE></H2>

<PRE>double <B>ldexp</B>(double x, int ex);
float <B>ldexp</B>(float x, int ex); <B>[C++ only]</B>
long double <B>ldexp</B>(long double x, int ex); <B>[C++ only]</B>
float <B>ldexpf</B>(float x, int ex); <B>[required with C99]</B>
long double <B>ldexpl</B>(long double x, int ex); <B>[required with C99]</B></PRE>

<P>The function returns <CODE>x * 2^ex</CODE>.</P>

<H2><A NAME="lgamma"></A><CODE>lgamma</CODE>,
<A NAME="lgammaf"></A><CODE>lgammaf</CODE>,
<A NAME="lgammal"></A><CODE>lgammal</CODE></H2>

<PRE>double <B>lgamma</B>(double x); <B>[all added with C99]</B>
float <B>lgamma</B>(float x); <B>[C++ only]</B>
long double <B>lgamma</B>(long double x); <B>[C++ only]</B>
float <B>lgammaf</B>(float x);
long double <B>lgammal</B>(long double x);</PRE>

<P>The function returns the natural logarithm of the absolute value
of the gamma function of <CODE>x</CODE>.</P>

<H2><A NAME="llrint"></A><CODE>llrint</CODE>,
<A NAME="llrintf"></A><CODE>llrintf</CODE>,
<A NAME="llrintl"></A><CODE>llrintl</CODE></H2>

<PRE>long long <B>llrint</B>(double x); <B>[all added with C99]</B>
long long <B>llrint</B>(float x); <B>[C++ only]</B>
long long <B>llrint</B>(long double x); <B>[C++ only]</B>
long long <B>llrintf</B>(float x);
long long <B>llrintl</B>(long double x);</PRE>

<P>The function returns the nearest <I>long long</I> integer to <CODE>x</CODE>,
consistent with the current
rounding mode. It raises an
invalid floating-point exception
if the magnitude of the rounded value is too large to represent. And it raises an
inexact floating-point exception
if the return value does not equal <CODE>x</CODE>.</P>

<H2><A NAME="llround"></A><CODE>llround</CODE>,
<A NAME="llroundf"></A><CODE>llroundf</CODE>,
<A NAME="llroundl"></A><CODE>llroundl</CODE></H2>

<PRE>long long <B>llround</B>(double x); <B>[all added with C99]</B>
long long <B>llround</B>(float x); <B>[C++ only]</B>
long long <B>llround</B>(long double x); <B>[C++ only]</B>
long long <B>llroundf</B>(float x);
long long <B>llroundl</B>(long double x);</PRE>

<P>The function returns the nearest <I>long long</I> integer to <CODE>x</CODE>,
rounding halfway values away from zero,
regardless of the current
rounding mode.</P>

<H2><A NAME="log"></A><CODE>log</CODE>,
<A NAME="logf"></A><CODE>logf</CODE>,
<A NAME="logl"></A><CODE>logl</CODE></H2>

<PRE>double <B>log</B>(double x);
float <B>log</B>(float x); <B>[C++ only]</B>
long double <B>log</B>(long double x); <B>[C++ only]</B>
float <B>logf</B>(float x); <B>[required with C99]</B>
long double <B>logl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the natural logarithm of <CODE>x</CODE>.
A domain error occurs if <CODE>x &lt; 0</CODE>.</P>

<H2><A NAME="log10"></A><CODE>log10</CODE>,
<A NAME="log10f"></A><CODE>log10f</CODE>,
<A NAME="log10l"></A><CODE>log10l</CODE></H2>

<PRE>double <B>log10</B>(double x);
float <B>log10</B>(float x); <B>[C++ only]</B>
long double <B>log10</B>(long double x); <B>[C++ only]</B>
float <B>log10f</B>(float x); <B>[required with C99]</B>
long double <B>log10l</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the base-10 logarithm of <CODE>x</CODE>.
A domain error occurs if <CODE>x &lt; 0</CODE>.</P>

<H2><A NAME="log1p"></A><CODE>log1p</CODE>,
<A NAME="log1pf"></A><CODE>log1pf</CODE>,
<A NAME="log1pl"></A><CODE>log1pl</CODE></H2>

<PRE>double <B>log1p</B>(double x); <B>[all added with C99]</B>
float <B>log1p</B>(float x); <B>[C++ only]</B>
long double <B>log1p</B>(long double x); <B>[C++ only]</B>
float <B>log1pf</B>(float x);
long double <B>log1pl</B>(long double x);</PRE>

<P>The function returns the natural logarithm of <CODE>1 + x</CODE>.
A domain error occurs if <CODE>x &lt; -1</CODE>.</P>

<H2><A NAME="log2"></A><CODE>log2</CODE>,
<A NAME="log2f"></A><CODE>log2f</CODE>,
<A NAME="log2l"></A><CODE>log2l</CODE></H2>

<PRE>double <B>log2</B>(double x); <B>[all added with C99]</B>
float <B>log2</B>(float x); <B>[C++ only]</B>
long double <B>log2</B>(long double x); <B>[C++ only]</B>
float <B>log2f</B>(float x);
long double <B>log2l</B>(long double x);</PRE>

<P>The function returns the base-2 logarithm of <CODE>x</CODE>.
A domain error occurs if <CODE>x &lt; 0</CODE>.</P>

<H2><A NAME="logb"></A><CODE>logb</CODE>,
<A NAME="logbf"></A><CODE>logbf</CODE>,
<A NAME="logbl"></A><CODE>logbl</CODE></H2>

<PRE>double <B>logb</B>(double x); <B>[all added with C99]</B>
float <B>logb</B>(float x); <B>[C++ only]</B>
long double <B>logb</B>(long double x); <B>[C++ only]</B>
float <B>logbf</B>(float x);
long double <B>logbl</B>(long double x);</PRE>

<P>The function determines an integer exponent <CODE>ex</CODE> and a fraction
<CODE>frac</CODE> that represent the value of a finite <CODE>x</CODE>.
It returns the value <CODE>ex</CODE> such that:</P>

<UL>
<LI><CODE>x == frac * <A HREF="float.html#FLT_RADIX">FLT_RADIX^ex</A></CODE></LI>

<LI><CODE>|frac|</CODE> is in the interval [1, <CODE>FLT_RADIX</CODE>)</LI>
</UL>

<P>A domain error may occur if <CODE>x</CODE> is zero.</P>

<H2><A NAME="lrint"></A><CODE>lrint</CODE>,
<A NAME="lrintf"></A><CODE>lrintf</CODE>,
<A NAME="lrintl"></A><CODE>lrintl</CODE></H2>

<PRE>long <B>lrint</B>(double x); <B>[all added with C99]</B>
long <B>lrint</B>(float x); <B>[C++ only]</B>
long <B>lrint</B>(long double x); <B>[C++ only]</B>
long <B>lrintf</B>(float x);
long <B>lrintl</B>(long double x);</PRE>

<P>The function returns the nearest <I>long</I> integer to <CODE>x</CODE>,
consistent with the current
rounding mode. It raises an
invalid floating-point exception
if the magnitude of the rounded value is too large to represent. And it raises an
inexact floating-point exception
if the return value does not equal <CODE>x</CODE>.</P>

<H2><A NAME="lround"></A><CODE>lround</CODE>,
<A NAME="lroundf"></A><CODE>lroundf</CODE>,
<A NAME="lroundl"></A><CODE>lroundl</CODE></H2>

<PRE>long <B>lround</B>(double x); <B>[all added with C99]</B>
long <B>lround</B>(float x); <B>[C++ only]</B>
long <B>lround</B>(long double x); <B>[C++ only]</B>
long <B>lroundf</B>(float x);
long <B>lroundl</B>(long double x);</PRE>

<P>The function returns the nearest <I>long</I> integer to <CODE>x</CODE>,
rounding halfway values away from zero, regardless of the current
rounding mode.</P>

<H2><A NAME="MATH_ERRNO"></A><CODE>MATH_ERRNO</CODE></H2>

<PRE>#define <B>MATH_ERRNO</B> 1 <B>[added with C99]</B></PRE>

<P>The macro yields the value 1. It is used for testing the value of
the macro <CODE><A HREF="#math_errhandling">math_errhandling</A></CODE>
to determine whether a math function reports an error by
storing a nonzero value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="MATH_ERREXCEPT"></A><CODE>MATH_ERREXCEPT</CODE></H2>

<PRE>#define <B>MATH_ERREXCEPT</B>   2 <B>[added with C99]</B></PRE>

<P>The macro yields the value 2. It is used for testing the value of
the macro <CODE><A HREF="#math_errhandling">math_errhandling</A></CODE>
to determine whether a math function reports an error by raising an
<B>invalid floating-point exception</B>.</P>

<H2><A NAME="math_errhandling"></A><CODE>math_errhandling</CODE></H2>

<PRE>#define <B>math_errhandling</B> <I>&lt;int rvalue [0, 4)&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro specifies how math functions report a
<A HREF="#domain_error">domain error</A> or a
<A HREF="#range_error">range error</A>. Specifically:</P>

<UL>
<LI>if <CODE>(math_errhandling &amp;
<A HREF="#MATH_ERRNO">MATH_ERRNO</A>) != 0</CODE>
then the math function stores a nonzero value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns a particular value that characterizes the error.</LI>

<LI>if <CODE>(math_errhandling &amp;
<A HREF="#MATH_ERREXCEPT">MATH_ERREXCEPT</A>) != 0</CODE>
then the math function raises an
invalid floating-point exception.</LI>
</UL>

<P>The value of the macro remains unchanged during program execution.</P>

<H2><A NAME="modf"></A><CODE>modf</CODE>,
<A NAME="modff"></A><CODE>modff</CODE>,
<A NAME="modfl"></A><CODE>modfl</CODE></H2>

<PRE>double <B>modf</B>(double x, double *pint);
float <B>modf</B>(float x, float *pint); <B>[C++ only]</B>
long double <B>modf</B>(long double x,
    long double *pint); <B>[C++ only]</B>
float <B>modff</B>(float x, float *pint); <B>[required with C99]</B>
long double <B>modfl</B>(long double x,
    long double *pint); <B>[required with C99]</B></PRE>

<P>The function determines an integer <CODE>i</CODE> plus a fraction
<CODE>frac</CODE> that represent the value of <CODE>x</CODE>.
It returns the value <CODE>frac</CODE> and stores the integer
<CODE>i</CODE> in <CODE>*pint</CODE>, such that:</P>

<UL>
<LI><CODE>x == frac + i</CODE></LI>

<LI><CODE>|frac|</CODE> is in the interval [0, 1)</LI>

<LI>both <CODE>frac</CODE> and <CODE>i</CODE> have the
same sign as <CODE>x</CODE></LI>
</UL>

<H2><A NAME="NAN_macro"></A><CODE>NAN</CODE></H2>

<PRE>#define <B>NAN</B> <I>&lt;float rvalue&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields a <I>float</I> value that represents not-a-number
(NaN).</P>

<H2><A NAME="nan"></A><CODE>nan</CODE>,
<A NAME="nanf"></A><CODE>nanf</CODE>,
<A NAME="nanl"></A><CODE>nanl</CODE></H2>

<PRE>double <B>nan</B>(const char *str); <B>[all added with C99]</B>
float <B>nanf</B>(const char *str);
long double <B>nanl</B>(const char *str);</PRE>

<P>The function converts a null-terminated sequence beginning at <CODE>str</CODE>
to a not-a-number (NaN) code. Specifically, the
call <CODE>nan("n-char-seq")</CODE> effectively returns
<CODE><A HREF="stdlib.html#strtod">strtod</A>("NAN(n-char-seq)", (char**)0)</CODE>
if the conversion succeeds; otherwise it returns
<CODE>strtod("NAN")</CODE>.</P>

<H2><A NAME="nearbyint"></A><CODE>nearbyint</CODE>,
<A NAME="nearbyintf"></A><CODE>nearbyintf</CODE>,
<A NAME="nearbyintl"></A><CODE>nearbyintl</CODE></H2>

<PRE>double <B>nearbyint</B>(double x); <B>[all added with C99]</B>
float <B>nearbyint</B>(float x); <B>[C++ only]</B>
long double <B>nearbyint</B>(long double x); <B>[C++ only]</B>
float <B>nearbyintf</B>(float x);
long double <B>nearbyintl</B>(long double x);</PRE>

<P>The function returns <CODE>x</CODE> rounded to the nearest integer,
consistent with the current
rounding mode but without raising an
inexact floating-point exception.</P>

<H2><A NAME="nextafter"></A><CODE>nextafter</CODE>,
<A NAME="nextafterf"></A><CODE>nextafterf</CODE>,
<A NAME="nextafterl"></A><CODE>nextafterl</CODE></H2>

<PRE>double <B>nextafter</B>(double x, double y); <B>[all added with C99]</B>
float <B>nextafter</B>(float x, float y); <B>[C++ only]</B>
long double <B>nextafter</B>(long double x, long double y); <B>[C++ only]</B>
float <B>nextafterf</B>(float x, float y);
long double <B>nextafterl</B>(long double x, long double y);</PRE>

<P>The function returns:</P>

<UL>
<LI>if <CODE>x &lt; y</CODE>, the next representable value after
<CODE>x</CODE></LI>

<LI>if <CODE>x == y</CODE>, <CODE>y</CODE></LI>

<LI>if <CODE>x &gt; y</CODE>, the next representable value before
<CODE>x</CODE></LI>
</UL>

<H2><A NAME="nexttoward"></A><CODE>nexttoward</CODE>,
<A NAME="nexttowardf"></A><CODE>nexttowardf</CODE>,
<A NAME="nexttowardl"></A><CODE>nexttowardl</CODE></H2>

<PRE>double <B>nexttoward</B>(double x, long double y); <B>[all added with C99]</B>
float <B>nexttoward</B>(float x, long double y); <B>[C++ only]</B>
long double <B>nexttoward</B>(long double x, long double y); <B>[C++ only]</B>
float <B>nexttowardf</B>(float x, long double y);
long double <B>nexttowardl</B>(long double x, long double y);</PRE>

<P>The function returns:</P>

<UL>
<LI>if <CODE>x &lt; y</CODE>, the next representable value after
<CODE>x</CODE></LI>

<LI>if <CODE>x == y</CODE>, <CODE>y</CODE></LI>

<LI>if <CODE>x &gt; y</CODE>, the next representable value before
<CODE>x</CODE></LI>
</UL>

<H2><A NAME="pow"></A><CODE>pow</CODE>,
<A NAME="powf"></A><CODE>powf</CODE>,
<A NAME="powl"></A><CODE>powl</CODE></H2>

<PRE>double <B>pow</B>(double x, double y);
float <B>pow</B>(float x, float y); <B>[C++ only]</B>
long double <B>pow</B>(long double x, long double y); <B>[C++ only]</B>
float <B>powf</B>(float x, float y); <B>[required with C99]</B>
long double <B>powl</B>(long double x,
    long double y); <B>[required with C99]</B></PRE>

<P>The function returns <CODE>x</CODE> raised to the power <CODE>y</CODE>,
<CODE>x^y</CODE>.</P>

<H2><A NAME="remainder"></A><CODE>remainder</CODE>,
<A NAME="remainderf"></A><CODE>remainderf</CODE>,
<A NAME="remainderl"></A><CODE>remainderl</CODE></H2>

<PRE>double <B>remainder</B>(double x, double y); <B>[all added with C99]</B>
float <B>remainder</B>(float x, float y); <B>[C++ only]</B>
long double <B>remainder</B>(long double x, long double y); <B>[C++ only]</B>
float <B>remainderf</B>(float x, float y);
long double <B>remainderl</B>(long double x, long double y);</PRE>

<P>The function effectively returns
<CODE><A HREF="#remquo">remquo</A>(x, y, &amp;temp)</CODE>, where
<CODE>temp</CODE> is a temporary object of type <I>int</I> local to the
function.</P>

<H2><A NAME="remquo"></A><CODE>remquo</CODE>,
<A NAME="remquof"></A><CODE>remquof</CODE>,
<A NAME="remquol"></A><CODE>remquol</CODE></H2>

<PRE>double <B>remquo</B>(double x, double y, int *pquo); <B>[all added with C99]</B>
float <B>remquo</B>(float x, float y, int *pquo); <B>[C++ only]</B>
long double <B>remquo</B>(long double x, long double y, int *pquo); <B>[C++ only]</B>
float <B>remquof</B>(float x, float y, int *pquo);
long double <B>remquol</B>(long double x, long double y, int *pquo);</PRE>

<P>The function computes the remainder <CODE>rem == x - n*y</CODE>, where
<CODE>n == x/y</CODE> rounded to the nearest integer, or to the nearest
even integer if <CODE>|n - x/y| == 1/2</CODE>. If <CODE>rem</CODE> is zero,
it has the same sign as <CODE>x</CODE>. A domain error occurs if
<CODE>y</CODE> is zero.</P>

<P>The function stores in <CODE>*pquo</CODE> at least three of the
low-order bits of <CODE>|x/y|</CODE>, negated if <CODE>x/y &lt; 0</CODE>.
It returns <CODE>rem</CODE>.</P>

<H2><A NAME="rint"></A><CODE>rint</CODE>,
<A NAME="rintf"></A><CODE>rintf</CODE>,
<A NAME="rintl"></A><CODE>rintl</CODE></H2>

<PRE>double <B>rint</B>(double x); <B>[all added with C99]</B>
float <B>rint</B>(float x); <B>[C++ only]</B>
long double <B>rint</B>(long double x); <B>[C++ only]</B>
float <B>rintf</B>(float x);
long double <B>rintl</B>(long double x);</PRE>

<P>The function returns <CODE>x</CODE> rounded to the nearest integer,
using the current
rounding mode. It may raise an
inexact floating-point exception
if the return value does not equal <CODE>x</CODE>.</P>

<H2><A NAME="round"></A><CODE>round</CODE>,
<A NAME="roundf"></A><CODE>roundf</CODE>,
<A NAME="roundl"></A><CODE>roundl</CODE></H2>

<PRE>double <B>round</B>(double x); <B>[all added with C99]</B>
float <B>round</B>(float x); <B>[C++ only]</B>
long double <B>round</B>(long double x); <B>[C++ only]</B>
float <B>roundf</B>(float x);
long double <B>roundl</B>(long double x);</PRE>

<P>The function returns <CODE>x</CODE> rounded to the nearest integer
<CODE>n</CODE>, or to the value with larger magnitude if
<CODE>|n - x| == 1/2</CODE>.</P>

<H2><A NAME="scalbln"></A><CODE>scalbln</CODE>,
<A NAME="scalblnf"></A><CODE>scalblnf</CODE>,
<A NAME="scalblnl"></A><CODE>scalblnl</CODE></H2>

<PRE>double <B>scalbln</B>(double x, long ex); <B>[all added with C99]</B>
float <B>scalbln</B>(float x, long ex); <B>[C++ only]</B>
long double <B>scalbln</B>(long double x, long ex); <B>[C++ only]</B>
float <B>scalblnf</B>(float x, long ex);
long double <B>scalblnl</B>(long double x, long ex);</PRE>

<P>The function returns <CODE>x *
<A HREF="float.html#FLT_RADIX">FLT_RADIX</A>^ex</CODE>.</P>

<H2><A NAME="scalbn"></A><CODE>scalbn</CODE>,
<A NAME="scalbnf"></A><CODE>scalbnf</CODE>,
<A NAME="scalbnl"></A><CODE>scalbnl</CODE></H2>

<PRE>double <B>scalbn</B>(double x, int ex); <B>[all added with C99]</B>
float <B>scalbn</B>(float x, int ex); <B>[C++ only]</B>
long double <B>scalbn</B>(long double x, int ex); <B>[C++ only]</B>
float <B>scalbnf</B>(float x, int ex);
long double <B>scalbnl</B>(long double x, int ex);</PRE>

<P>The function returns <CODE>x *
<A HREF="float.html#FLT_RADIX">FLT_RADIX</A>^ex</CODE>.</P>

<H2><A NAME="signbit"></A><CODE>signbit</CODE></H2>

<PRE>#define <B>signbit</B>(x) <I>&lt;int rvalue&gt;</I> <B>[added with C99, bool functions in C++]</B></PRE>

<P>The <A HREF="tgmath.html#generic_functions">generic-function</A> macro
accepts an rvalue argument <CODE>x</CODE> of some
real floating-point type and yields a nonzero value only if
the (negative) sign bit of <CODE>x</CODE> is set. The macro never raises an
invalid floating-point exception.</P>

<H2><A NAME="sin"></A><CODE>sin</CODE>,
<A NAME="sinf"></A><CODE>sinf</CODE>,
<A NAME="sinl"></A><CODE>sinl</CODE></H2>

<PRE>double <B>sin</B>(double x);
float <B>sin</B>(float x); <B>[C++ only]</B>
long double <B>sin</B>(long double x); <B>[C++ only]</B>
float <B>sinf</B>(float x); <B>[required with C99]</B>
long double <B>sinl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the sine of <CODE>x</CODE>.
If <CODE>x</CODE> is large
the value returned might not be meaningful, but
the function reports no error.</P>

<H2><A NAME="sinh"></A><CODE>sinh</CODE>,
<A NAME="sinhf"></A><CODE>sinhf</CODE>,
<A NAME="sinhl"></A><CODE>sinhl</CODE></H2>

<PRE>double <B>sinh</B>(double x);
float <B>sinh</B>(float x); <B>[C++ only]</B>
long double <B>sinh</B>(long double x); <B>[C++ only]</B>
float <B>sinhf</B>(float x); <B>[required with C99]</B>
long double <B>sinhl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the hyperbolic sine of <CODE>x</CODE>.</P>

<H2><A NAME="sqrt"></A><CODE>sqrt</CODE>,
<A NAME="sqrtf"></A><CODE>sqrtf</CODE>,
<A NAME="sqrtl"></A><CODE>sqrtl</CODE></H2>

<PRE>double <B>sqrt</B>(double x);
float <B>sqrt</B>(float x); <B>[C++ only]</B>
long double <B>sqrt</B>(long double x); <B>[C++ only]</B>
float <B>sqrtf</B>(float x); <B>[required with C99]</B>
long double <B>sqrtl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the real square root of <CODE>x</CODE>,
<CODE>x^(1/2)</CODE>. A domain error occurs if <CODE>x &lt; 0</CODE>.</P>

<H2><A NAME="tan"></A><CODE>tan</CODE>,
<A NAME="tanf"></A><CODE>tanf</CODE>,
<A NAME="tanl"></A><CODE>tanl</CODE></H2>

<PRE>double <B>tan</B>(double x);
float <B>tan</B>(float x); <B>[C++ only]</B>
long double <B>tan</B>(long double x); <B>[C++ only]</B>
float <B>tanf</B>(float x); <B>[required with C99]</B>
long double <B>tanl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the tangent of <CODE>x</CODE>.
If <CODE>x</CODE> is large the value returned
might not be meaningful,
but the function reports no error.</P>

<H2><A NAME="tanh"></A><CODE>tanh</CODE>,
<A NAME="tanhf"></A><CODE>tanhf</CODE>,
<A NAME="tanhl"></A><CODE>tanhl</CODE></H2>

<PRE>double <B>tanh</B>(double x);
float <B>tanh</B>(float x); <B>[C++ only]</B>
long double <B>tanh</B>(long double x); <B>[C++ only]</B>
float <B>tanhf</B>(float x); <B>[required with C99]</B>
long double <B>tanhl</B>(long double x); <B>[required with C99]</B></PRE>

<P>The function returns the hyperbolic tangent of <CODE>x</CODE>.</P>

<H2><A NAME="tgamma"></A><CODE>tgamma</CODE>,
<A NAME="tgammaf"></A><CODE>tgammaf</CODE>,
<A NAME="tgammal"></A><CODE>tgammal</CODE></H2>

<PRE>double <B>tgamma</B>(double x); <B>[all added with C99]</B>
float <B>tgamma</B>(float x); <B>[C++ only]</B>
long double <B>tgamma</B>(long double x); <B>[C++ only]</B>
float <B>tgammaf</B>(float x);
long double <B>tgammal</B>(long double x);</PRE>

<P>The function computes the gamma function of <CODE>x</CODE>.
A domain error occurs if <CODE>x</CODE> is a negative integer.</P>

<H2><A NAME="trunc"></A><CODE>trunc</CODE>,
<A NAME="truncf"></A><CODE>truncf</CODE>,
<A NAME="truncl"></A><CODE>truncl</CODE></H2>

<PRE>double <B>trunc</B>(double x); <B>[all added with C99]</B>
float <B>trunc</B>(float x); <B>[C++ only]</B>
long double <B>trunc</B>(long double x); <B>[C++ only]</B>
float <B>truncf</B>(float x);
long double <B>truncl</B>(long double x);</PRE>

<P>The function returns <CODE>x</CODE> rounded to the nearest integer
<CODE>n</CODE> not larger in magnitude than <CODE>x</CODE>
(toward zero).</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
