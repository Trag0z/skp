<HTML><HEAD>
<TITLE>&lt;float.h&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;float.h&gt;"></A><CODE>&lt;float.h&gt;</CODE></H1><HR>

<P>Include the standard header <B><CODE>&lt;float.h&gt;</CODE></B>
to determine various properties of floating-point type representations.
The standard header <CODE>&lt;float.h&gt;</CODE> is available even in a
freestanding implementation.</P>

<P>You can test the values of any of the integer macros except
<A HREF="#FLT_ROUNDS"><CODE>FLT_ROUNDS</CODE></A> in an
<A HREF="preproc.html#if_directive"><I>if</I> directive</A>.
(The macros expand to
<A HREF="preproc.html#if_expression"><I>#if</I> expressions</A>.)
All other macros defined in this header expand to
<A HREF="express.html#floating-point_constant_expression">floating-point constant expressions</A>.</P>

<P>Some target environments can change
the rounding and error-reporting properties of floating-point type
representations while the program is running.</P>

<PRE>#define <A HREF="#FLT_RADIX"><B>FLT_RADIX</B></A> <I>&lt;#if expression &gt;= 2&gt;</I>
#define <A HREF="#FLT_ROUNDS"><B>FLT_ROUNDS</B></A> <I>&lt;integer rvalue&gt;</I>
#define <A HREF="#FLT_EVAL_METHOD"><B>FLT_EVAL_METHOD</B></A> <I>&lt;#if expression&gt;</I> <B>[added with C99]</B>
#define <A HREF="#DECIMAL_DIG"><B>DECIMAL_DIG</B></A> <I>&lt;#if expression&gt; &gt;= 10</I> <B>[added with C99]</B>

#define <A HREF="#DBL_DIG"><B>DBL_DIG</B></A> <I>&lt;#if expression &gt;= 10&gt;</I>
#define <A HREF="#DBL_EPSILON"><B>DBL_EPSILON</B></A> <I>&lt;double constant &lt;= 10^(-9)&gt;</I>
#define <A HREF="#DBL_MANT_DIG"><B>DBL_MANT_DIG</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#DBL_MAX"><B>DBL_MAX</B></A> <I>&lt;double constant &gt;= 10^37&gt;</I>
#define <A HREF="#DBL_MAX_10_EXP"><B>DBL_MAX_10_EXP</B></A> <I>&lt;#if expression &gt;= 37&gt;</I>
#define <A HREF="#DBL_MAX_EXP"><B>DBL_MAX_EXP</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#DBL_MIN"><B>DBL_MIN</B></A> <I>&lt;double constant &lt;= 10^(-37)&gt;</I>
#define <A HREF="#DBL_MIN_10_EXP"><B>DBL_MIN_10_EXP</B></A> <I>&lt;#if expression &lt;= -37&gt;</I>
#define <A HREF="#DBL_MIN_EXP"><B>DBL_MIN_EXP</B></A> <I>&lt;#if expression&gt;</I>

#define <A HREF="#FLT_DIG"><B>FLT_DIG</B></A> <I>&lt;#if expression &gt;= 6&gt;</I>
#define <A HREF="#FLT_EPSILON"><B>FLT_EPSILON</B></A> <I>&lt;float constant &lt;= 10^(-5)&gt;</I>
#define <A HREF="#FLT_MANT_DIG"><B>FLT_MANT_DIG</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#FLT_MAX"><B>FLT_MAX</B></A> <I>&lt;float constant &gt;= 10^37&gt;</I>
#define <A HREF="#FLT_MAX_10_EXP"><B>FLT_MAX_10_EXP</B></A> <I>&lt;#if expression &gt;= 37&gt;</I>
#define <A HREF="#FLT_MAX_EXP"><B>FLT_MAX_EXP</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#FLT_MIN"><B>FLT_MIN</B></A> <I>&lt;float constant &lt;= 10^(-37)&gt;</I>
#define <A HREF="#FLT_MIN_10_EXP"><B>FLT_MIN_10_EXP</B></A> <I>&lt;#if expression &lt;= -37&gt;</I>
#define <A HREF="#FLT_MIN_EXP"><B>FLT_MIN_EXP</B></A> <I>&lt;#if expression&gt;</I>

#define <A HREF="#LDBL_DIG"><B>LDBL_DIG</B></A> <I>&lt;#if expression &gt;= 10&gt;</I>
#define <A HREF="#LDBL_EPSILON"><B>LDBL_EPSILON</B></A> <I>&lt;long double constant &lt;= 10^(-9)&gt;</I>
#define <A HREF="#LDBL_MANT_DIG"><B>LDBL_MANT_DIG</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#LDBL_MAX"><B>LDBL_MAX</B></A> <I>&lt;long double constant &gt;= 10^37&gt;</I>
#define <A HREF="#LDBL_MAX_10_EXP"><B>LDBL_MAX_10_EXP</B></A> <I>&lt;#if expression &gt;= 37&gt;</I>
#define <A HREF="#LDBL_MAX_EXP"><B>LDBL_MAX_EXP</B></A> <I>&lt;#if expression&gt;</I>
#define <A HREF="#LDBL_MIN"><B>LDBL_MIN</B></A> <I>&lt;long double constant &lt;= 10^(-37)&gt;</I>
#define <A HREF="#LDBL_MIN_10_EXP"><B>LDBL_MIN_10_EXP</B></A> <I>&lt;#if expression &lt;= -37&gt;</I>
#define <A HREF="#LDBL_MIN_EXP"><B>LDBL_MIN_EXP</B></A> <I>&lt;#if expression&gt;</I></PRE>

<H2><A NAME="DBL_DIG"></A><CODE>DBL_DIG</CODE></H2>

<PRE>#define <B>DBL_DIG</B> <I>&lt;#if expression &gt;= 10&gt;</I></PRE>

<P>The macro yields the precision in decimal digits for
type <I>double.</I></P>

<H2><A NAME="DBL_EPSILON"></A><CODE>DBL_EPSILON</CODE></H2>

<PRE>#define <B>DBL_EPSILON</B> <I>&lt;double constant &lt;= 10^(-9)&gt;</I></PRE>

<P>The macro yields the smallest <I>X</I> of type <I>double</I>
such that 1.0 + <I>X</I> != 1.0.</P>

<H2><A NAME="DBL_MANT_DIG"></A><CODE>DBL_MANT_DIG</CODE></H2>

<PRE>#define <B>DBL_MANT_DIG</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the number of mantissa digits, base
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>,
for type <I>double.</I></P>

<H2><A NAME="DBL_MAX"></A><CODE>DBL_MAX</CODE></H2>

<PRE>#define <B>DBL_MAX</B> <I>&lt;double constant &gt;= 10^37&gt;</I></PRE>

<P>The macro yields the largest finite representable value
of type <I>double.</I></P>

<H2><A NAME="DBL_MAX_10_EXP"></A><CODE>DBL_MAX_10_EXP</CODE></H2>

<PRE>#define <B>DBL_MAX_10_EXP</B> <I>&lt;#if expression &gt;= 37&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that
10^<I>X</I> is a finite representable value of type <I>double.</I></P>

<H2><A NAME="DBL_MAX_EXP"></A><CODE>DBL_MAX_EXP</CODE></H2>

<PRE>#define <B>DBL_MAX_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a finite representable value of type <I>double.</I></P>

<H2><A NAME="DBL_MIN"></A><CODE>DBL_MIN</CODE></H2>

<PRE>#define <B>DBL_MIN</B> <I>&lt;double constant &lt;= 10^(-37)&gt;</I></PRE>

<P>The macro yields the smallest normalized, finite representable
value of type <I>double.</I></P>

<H2><A NAME="DBL_MIN_10_EXP"></A><CODE>DBL_MIN_10_EXP</CODE></H2>

<PRE>#define <B>DBL_MIN_10_EXP</B> <I>&lt;#if expression &lt;= -37&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X</I> such that
10^<I>X</I> is a normalized, finite representable value
of type <I>double.</I></P>

<H2><A NAME="DBL_MIN_EXP"></A><CODE>DBL_MIN_EXP</CODE></H2>

<PRE>#define <B>DBL_MIN_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a normalized, finite representable value of type <I>double.</I></P>

<H2><A NAME="DECIMAL_DIG"></A><CODE>DECIMAL_DIG</CODE></H2>

<PRE>#define <B>DECIMAL_DIG</B> <I>&lt;#if expression &gt;= 10&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields the minimum number of decimal digits needed to represent
all the significant digits for type <I>long double.</I></P>

<H2><A NAME="FLT_DIG"></A><CODE>FLT_DIG</CODE></H2>

<PRE>#define <B>FLT_DIG</B> <I>&lt;#if expression &gt;= 6&gt;</I></PRE>

<P>The macro yields the precision in decimal digits
for type <I>float.</I></P>

<H2><A NAME="FLT_EPSILON"></A><CODE>FLT_EPSILON</CODE></H2>

<PRE>#define <B>FLT_EPSILON</B> <I>&lt;float constant &lt;= 10^(-5)&gt;</I></PRE>

<P>The macro yields the smallest <I>X</I> of type <I>float</I>
such that 1.0 + <I>X</I> != 1.0.</P>

<H2><A NAME="FLT_EVAL_METHOD"></A><CODE>FLT_EVAL_METHOD</CODE></H2>

<PRE>#define <B>FLT_EVAL_METHOD</B> <I>&lt;#if expression&gt;</I> <B>[added with C99]</B></PRE>

<P>The macro yields a value that describes the evaluation
mode for floating-point operations. The values are:</P>

<UL>
<LI>-1 if the mode is indeterminate</LI>

<LI>0 if no promotions occur</LI>

<LI>1 if <I>float</I> values promote to <I>double</I></LI>

<LI>2 if <I>float</I> and <I>double</I> values promote to <I>long double</I></LI>
</UL>

<P>An implementation can define additional negative values for this macro.</P>

<H2><A NAME="FLT_MANT_DIG"></A><CODE>FLT_MANT_DIG</CODE></H2>

<PRE>#define <B>FLT_MANT_DIG</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the number of mantissa digits, base
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>,
for type <I>float.</I></P>

<H2><A NAME="FLT_MAX"></A><CODE>FLT_MAX</CODE></H2>

<PRE>#define <B>FLT_MAX</B> <I>&lt;float constant &gt;= 10^37&gt;</I></PRE>

<P>The macro yields the largest finite representable value
of type <I>float.</I></P>

<H2><A NAME="FLT_MAX_10_EXP"></A><CODE>FLT_MAX_10_EXP</CODE></H2>

<PRE>#define <B>FLT_MAX_10_EXP</B> <I>&lt;#if expression &gt;= 37&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that 10^<I>X</I>
is a finite representable value of type <I>float.</I></P>

<H2><A NAME="FLT_MAX_EXP"></A><CODE>FLT_MAX_EXP</CODE></H2>

<PRE>#define <B>FLT_MAX_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a finite representable value of type <I>float.</I></P>

<H2><A NAME="FLT_MIN"></A><CODE>FLT_MIN</CODE></H2>

<PRE>#define <B>FLT_MIN</B> <I>&lt;float constant &lt;= 10^(-37)&gt;</I></PRE>

<P>The macro yields the smallest normalized, finite representable
value of type <I>float.</I></P>

<H2><A NAME="FLT_MIN_10_EXP"></A><CODE>FLT_MIN_10_EXP</CODE></H2>

<PRE>#define <B>FLT_MIN_10_EXP</B> <I>&lt;#if expression &lt;= -37&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X,</I> such that 10^<I>X</I>
is a normalized, finite representable value of type <I>float.</I></P>

<H2><A NAME="FLT_MIN_EXP"></A><CODE>FLT_MIN_EXP</CODE></H2>

<PRE>#define <B>FLT_MIN_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X,</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a normalized, finite representable value of type <I>float.</I></P>

<H2><A NAME="FLT_RADIX"></A><CODE>FLT_RADIX</CODE></H2>

<PRE>#define <B>FLT_RADIX</B> <I>&lt;#if expression &gt;= 2&gt;</I></PRE>

<P>The macro yields the radix of all floating-point representations.</P>

<H2><A NAME="FLT_ROUNDS"></A><CODE>FLT_ROUNDS</CODE></H2>

<PRE>#define <B>FLT_ROUNDS</B> <I>&lt;integer rvalue&gt;</I></PRE>

<P>The macro yields a value that describes the current rounding
mode for floating-point operations. Note that the target environment
can change the rounding mode while the program executes. How it does
so, however, is not specified. The values are:</P>

<UL>
<LI>-1 if the mode is indeterminate</LI>

<LI>0 if rounding is toward zero</LI>

<LI>1 if rounding is to nearest representable value</LI>

<LI>2 if rounding is toward positive infinity</LI>

<LI>3 if rounding is toward negative infinity</LI>
</UL>

<P>An implementation can define additional values for this macro.</P>

<H2><A NAME="LDBL_DIG"></A><CODE>LDBL_DIG</CODE></H2>

<PRE>#define <B>LDBL_DIG</B> <I>&lt;#if expression &gt;= 10&gt;</I></PRE>

<P>The macro yields the precision in decimal digits for type <I>long
double.</I></P>

<H2><A NAME="LDBL_EPSILON"></A><CODE>LDBL_EPSILON</CODE></H2>

<PRE>#define <B>LDBL_EPSILON</B> <I>&lt;long double constant &lt;= 10^(-9)&gt;</I></PRE>

<P>The macro yields the smallest <I>X</I> of type <I>long double</I>
such that 1.0 + <I>X</I> != 1.0.</P>

<H2><A NAME="LDBL_MANT_DIG"></A><CODE>LDBL_MANT_DIG</CODE></H2>

<PRE>#define <B>LDBL_MANT_DIG</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the number of mantissa digits, base
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>,
for type <I>long double.</I></P>

<H2><A NAME="LDBL_MAX"></A><CODE>LDBL_MAX</CODE></H2>

<PRE>#define <B>LDBL_MAX</B> <I>&lt;long double constant &gt;= 10^37&gt;</I></PRE>

<P>The macro yields the largest finite representable value of type
<I>long double.</I></P>

<H2><A NAME="LDBL_MAX_10_EXP"></A><CODE>LDBL_MAX_10_EXP</CODE></H2>

<PRE>#define <B>LDBL_MAX_10_EXP</B> <I>&lt;#if expression &gt;= 37&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that
10^<I>X</I> is a finite representable value of type <I>long double.</I></P>

<H2><A NAME="LDBL_MAX_EXP"></A><CODE>LDBL_MAX_EXP</CODE></H2>

<PRE>#define <B>LDBL_MAX_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the maximum integer <I>X,</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a finite representable value of type <I>long double.</I></P>

<H2><A NAME="LDBL_MIN"></A><CODE>LDBL_MIN</CODE></H2>

<PRE>#define <B>LDBL_MIN</B> <I>&lt;long double constant &lt;= 10^(-37)&gt;</I></PRE>

<P>The macro yields the smallest normalized, finite representable
value of type <I>long double.</I></P>

<H2><A NAME="LDBL_MIN_10_EXP"></A><CODE>LDBL_MIN_10_EXP</CODE></H2>

<PRE>#define <B>LDBL_MIN_10_EXP</B> <I>&lt;#if expression &lt;= -37&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X,</I> such that
10^<I>X</I> is a normalized, finite representable value
of type <I>long double.</I></P>

<H2><A NAME="LDBL_MIN_EXP"></A><CODE>LDBL_MIN_EXP</CODE></H2>

<PRE>#define <B>LDBL_MIN_EXP</B> <I>&lt;#if expression&gt;</I></PRE>

<P>The macro yields the minimum integer <I>X,</I> such that
<A HREF="#FLT_RADIX"><CODE>FLT_RADIX</CODE></A>^(<I>X</I> - 1)
is a normalized, finite representable value of type <I>long double.</I></P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
