<HTML><HEAD>
<TITLE>&lt;stack&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;stack&gt;"></A><CODE>&lt;stack&gt;</CODE></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;stack&gt;</CODE></B>
to define the template class <CODE>stack</CODE> and several supporting
templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Container&gt;
    class <B><A HREF="#stack">stack</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const stack&lt;Ty, Container&gt;&amp; left,
        const stack&lt;Ty, Container&gt;&amp; right);

template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#swap">swap</A></B>(stack&lt;Ty, Container&gt;&amp; left,
        stack&lt;Ty, Container&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B>

template&lt;class Ty, class Container, class Alloc&gt;
    struct <B><A HREF="#uses_allocator">uses_allocator</A></B>&lt;stack&lt;Ty, Container&gt;, alloc&gt;; <B>[added with C++11]</B>
}  // namespace std</PRE>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator!=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator==</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#stack"><CODE>stack</CODE></A>. The function returns
<CODE>left.<A HREF="#stack__c">c</A> == right.c</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#stack"><CODE>stack</CODE></A>. The function returns
<CODE>left.<A HREF="#stack__c">c</A> &lt; right.c</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;=</B>(const stack &lt;Ty, Container&gt;&amp; left,
        const stack &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="stack"></A><CODE>stack</CODE></H2>

<PRE>template&lt;class Ty,
    class Container = deque&lt;Ty&gt; &gt;
    class stack {
public:
    typedef Container <B><A HREF="#stack__container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#stack__value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#stack__size_type">size_type</A></B>;
    typedef typename Container::reference <B><A HREF="#stack__reference">reference</A></B>;
    typedef typename Container::const_reference <B><A HREF="#stack__const_reference">const_reference</A></B>;

    <B><A HREF="#stack__stack">stack</A></B>();
    explicit <B><A HREF="#stack__stack">stack</A></B>(const container_type&amp; cont);

    <B><A HREF="#stack__stack">stack</A></B>(stack&amp;&amp; right)
        noexcept(is_nothrow_move_constructible&lt;Container&gt;::value); <B>[added with C++11]</B>
    explicit <B><A HREF="#stack__stack">stack</A></B>(container_type&amp;&amp; cont); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        explicit <B><A HREF="#stack__stack">stack</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        explicit <B><A HREF="#stack__stack">stack</A></B>(const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        explicit <B><A HREF="#stack__stack">stack</A></B>(const stack&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>
    template&lt;class Allloc&gt;
        explicit <B><A HREF="#stack__stack">stack</A></B>(stack&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>

    stack <B><A HREF="#stack__operator2">operator=</A></B>(stack&amp;&amp; right)
        noexcept(is_nothrow_move_assignable&lt;Container&gt;::value); <B>[added with C++11]</B>
    void <B><A HREF="#stack__swap">swap</A></B>(stack&amp; right)
        noexcept(noexcept(swap(c, right.c))); <B>[added with C++11]</B>

    bool <B><A HREF="#stack__empty">empty</A></B>() const;
    size_type <B><A HREF="#stack__size">size</A></B>() const;

    reference <B><A HREF="#stack__top">top</A></B>();
    const_reference <B><A HREF="#stack__top">top</A></B>() const;
    void <B><A HREF="#stack__push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#stack__push">push</A></B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
    template&lt;class... Ty&gt;
        void <B><A HREF="#stack__emplace">emplace</A></B>(Ty&amp;&amp;... val); <B>[added with C++11]</B>
    void <B><A HREF="#stack__pop">pop</A></B>();

protected:
    Container <B><A HREF="#stack__c">c</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="stack__c"></A><CODE>c</CODE></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#stack__value_type">value_type</A></CODE>.</P>

<P>An object of class <CODE>Container</CODE> must supply
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE>,
<CODE><A HREF="list.html#list">list</A></CODE>, and
<CODE><A HREF="vector.html#vector">vector</A></CODE>
(all of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    typedef T1 <B>reference</B>;
    typedef T2 <B>const_reference</B>;

    <B>Container</B>();
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    value_type&amp; <B>back</B>();
    const value_type&amp; <B>back</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    template&lt;class... Ty&gt;
        void <B>emplace_back</B>(const Ty&amp;... val); <B>[added with C++11]</B>
    void <B>pop_back</B>();

    bool operator==(const Container&amp; cont) const;
    bool operator!=(const Container&amp; cont) const;
    bool operator&lt;(const Container&amp; cont) const;
    bool operator&gt;(const Container&amp; cont) const;
    bool operator&lt;=(const Container&amp; cont) const;
    bool operator&gt;=(const Container&amp; cont) const;</PRE>

<P>Here, <CODE>T0</CODE>, <CODE>T1</CODE>, and <CODE>T2</CODE> are unspecified
types that meet the stated requirements.</P>

<P>Moreover, beginning with <B>C++11</B>,
it must be possible to swap two <CODE>Container</CODE>
objects by calling the standard function <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="stack__const_reference"></A>stack::const_reference</CODE></H3>

<PRE>typedef typename Container::const_reference <B>const_reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::const_reference</CODE>.</P>

<H3><CODE><A NAME="stack__container_type"></A>stack::container_type</CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="stack__empty"></A>stack::empty</CODE></H3>

<H3><CODE><A NAME="stack__emplace"></A>stack::emplace</CODE></H3>

<PRE>template&lt;class... Ty&gt;
    void <B>emplace</B>(Ty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function executes <CODE>c.emplace_back(forward&lt;Ty&gt;(val)...)</CODE>.</P>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="stack__operator2"></A>stack::operator=</CODE></H3>

<PRE>stack&gt; <B>operator=</B>(stack&amp;&amp; right)
    noexcept(is_nothrow_move_assignable&lt;Container&gt;::value); <B>[added with C++11]</B></PRE>

<P>The operator moves <CODE>right</CODE> to <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="stack__pop"></A>stack::pop</CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="stack__push"></A>stack::push</CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);
void <B>push</B>(value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<P>The second member functions is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="stack__reference"></A>stack::reference</CODE></H3>

<PRE>typedef typename Container::reference <B>reference</B>;</PRE>

<P>The type is a synonym for <CODE>Container::reference</CODE>.</P>

<H3><CODE><A NAME="stack__size"></A>stack::size</CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="stack__size_type"></A>stack::size_type</CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="stack__stack"></A>stack::stack</CODE></H3>

<PRE><B>stack</B>();
explicit <B>stack</B>(const container_type&amp; cont);
<B>stack</B>(stack&amp;&amp; right)
    noexcept(is_nothrow_move_constructible&lt;Container&gt;::value); <B>[added with C++11]</B>
explicit <B>stack</B>(container_type&amp;&amp; cont); <B>[added with C++11]</B>

template&lt;class Allloc&gt;
    explicit <B>stack</B>(const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    explicit <B>stack</B>(const container_type&amp; cont, const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    explicit <B>stack</B>(const stack&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>
template&lt;class Allloc&gt;
    explicit <B>stack</B>(stack&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>The first constructor initializes the stored object with
<CODE><A HREF="#stack__c">c</A>()</CODE>, to specify an
empty initial controlled sequence.
The second constructor initializes the stored object with
<CODE><A HREF="#stack__c">c</A>(cont)</CODE>, to specify an
initial controlled sequence that is a copy of the sequence controlled
by <CODE>cont</CODE>.</P>

<P>The third constructor is a move constructor, and the fourth is the
same as the second but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The remaining group behave the same as earlier constructors, but
with an added allocator argument.
Unless
<CODE><A HREF="memory.html#uses_allocator">uses_allocator</A>&lt;Container, Alloc&gt;</CODE>
<A HREF="typetrait.html#holds_true">holds true</A>,
these constructors do not participate in overload resolution.</P>

<H3><CODE><A NAME="stack__swap"></A>stack::swap</CODE></H3>

<PRE>void <B>swap</B>(stack&amp; right)
    noexcept(noexcept(swap(c, right.c))); <B>[added with C++11]</B></PRE>

<P>The template function swaps <CODE>right</CODE> with <CODE>*this</CODE>,
using <CODE>std::swap</CODE>.</P>

<H3><CODE><A NAME="stack__top"></A>stack::top</CODE></H3>

<PRE>reference <B>top</B>();
const_reference <B>top</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="stack__value_type"></A>stack::value_type</CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<H2><CODE><A NAME="swap"></A>swap</CODE></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>swap</B>(stack&lt;Ty, Container&gt;&amp; left,
        stack&lt;Ty, Container&gt;&amp;)
            noexcept(noexcept(left.swap(right))); <B>[added with C++11]</B></PRE>

<P>The template function executes
<CODE>left.<A HREF="#stack__swap">swap</A>(right)</CODE>.</P>

<H2><CODE><A NAME="uses_allocator"></A>uses_allocator</CODE></H2>

<PRE>template&lt;class Ty, class Container, class Alloc&gt;
    struct <B>uses_allocator</B>&lt;stack&lt;Ty, Container&gt;, alloc&gt;; <B>[added with C++11]</B></PRE>

<P>The specialization
<A HREF="typetrait.html#holds_true">holds true</A> only if
<CODE><A HREF="memory.html#uses_allocator">uses_allocator</A>&lt;Container, Alloc&gt;</CODE>
holds true.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
