<HTML><HEAD>
<TITLE>&lt;set&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;set&gt;"></A><CODE>&lt;set&gt;</CODE></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;set&gt;</CODE></B> to define the
<A HREF="lib_cont.html#Containers">container</A>
template classes <CODE>set</CODE> and
<CODE>multiset</CODE>, and their supporting
templates.</P>

<PRE>namespace std {
template&lt;class Key, class Pr, class Alloc&gt;
    class <B><A HREF="#set">set</A></B>;
template&lt;class Key, class Pr, class Alloc&gt;
    class <B><A HREF="#multiset">multiset</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const set&lt;Key, Pr, Alloc&gt;&amp; left,
        const set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset&lt;Key, Pr, Alloc&gt;&amp; right);

template&lt;class Key, class Pr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(
        set&lt;Key, Pr, Alloc&gt;&amp; left,
        set&lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(
        multiset&lt;Key, Pr, Alloc&gt;&amp; left,
        multiset&lt;Key, Pr, Alloc&gt;&amp; right);
}  // namespace std</PRE>

<H2><A NAME="multiset"></A><CODE>multiset</CODE></H2>

<HR>
<P><B><CODE><A HREF="#multiset__allocator_type">allocator_type</A>
&middot; <A HREF="#multiset__begin">begin</A>
&middot; <A HREF="#multiset__cbegin">cbegin</A>
&middot; <A HREF="#multiset__cend">cend</A>
&middot; <A HREF="#multiset__clear">clear</A>
&middot; <A HREF="#multiset__const_iterator">const_iterator</A>
&middot; <A HREF="#multiset__const_pointer">const_pointer</A>
&middot; <A HREF="#multiset__const_reference">const_reference</A>
&middot; <A HREF="#multiset__const_reverse_iterator">const_reverse_iterator</A>
&middot; <A HREF="#multiset__count">count</A>
&middot; <A HREF="#multiset__crbegin">crbegin</A>
&middot; <A HREF="#multiset__crend">crend</A>
&middot; <A HREF="#multiset__difference_type">difference_type</A>
&middot; <A HREF="#multiset__emplace">emplace</A>
&middot; <A HREF="#multiset__emplace_hint">emplace_hint</A>
&middot; <A HREF="#multiset__empty">empty</A>
&middot; <A HREF="#multiset__end">end</A>
&middot; <A HREF="#multiset__equal_range">equal_range</A>
&middot; <A HREF="#multiset__erase">erase</A>
&middot; <A HREF="#multiset__find">find</A>
&middot; <A HREF="#multiset__get_allocator">get_allocator</A>
&middot; <A HREF="#multiset__insert">insert</A>
&middot; <A HREF="#multiset__iterator">iterator</A>
&middot; <A HREF="#multiset__key_comp">key_comp</A>
&middot; <A HREF="#multiset__key_compare">key_compare</A>
&middot; <A HREF="#multiset__key_type">key_type</A>
&middot; <A HREF="#multiset__lower_bound">lower_bound</A>
&middot; <A HREF="#multiset__max_size">max_size</A>
&middot; <A HREF="#multiset__multiset">multiset</A>
&middot; <A HREF="#multiset__operator2">operator=</A>
&middot; <A HREF="#multiset__pointer">pointer</A>
&middot; <A HREF="#multiset__rbegin">rbegin</A>
&middot; <A HREF="#multiset__reference">reference</A>
&middot; <A HREF="#multiset__rend">rend</A>
&middot; <A HREF="#multiset__reverse_iterator">reverse_iterator</A>
&middot; <A HREF="#multiset__size">size</A>
&middot; <A HREF="#multiset__size_type">size_type</A>
&middot; <A HREF="#multiset__swap">swap</A>
&middot; <A HREF="#multiset__upper_bound">upper_bound</A>
&middot; <A HREF="#multiset__value_comp">value_comp</A>
&middot; <A HREF="#multiset__value_compare">value_compare</A>
&middot; <A HREF="#multiset__value_type">value_type</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Key, class Pr = less&lt;Key&gt;,
    class Alloc = allocator&lt;Key&gt; &gt;
    class <B>multiset</B> {
public:
    typedef Key <B><A HREF="#multiset__key_type">key_type</A></B>;
    typedef Pr <B><A HREF="#multiset__key_compare">key_compare</A></B>;
    typedef Key <B><A HREF="#multiset__value_type">value_type</A></B>;
    typedef Pr <B><A HREF="#multiset__value_compare">value_compare</A></B>;
    typedef Alloc <B><A HREF="#multiset__allocator_type">allocator_type</A></B>;
    typedef typename Alloc::pointer <B><A HREF="#multiset__pointer">pointer</A></B>;
    typedef typename Alloc::const_pointer <B><A HREF="#multiset__const_pointer">const_pointer</A></B>;
    typedef typename Alloc::reference <B><A HREF="#multiset__reference">reference</A></B>;
    typedef typename Alloc::const_reference <B><A HREF="#multiset__const_reference">const_reference</A></B>;
    typedef typename Alloc::size_type <B><A HREF="#multiset__size_type">size_type</A></B>;
    typedef typename Alloc::difference_type <B><A HREF="#multiset__difference_type">difference_type</A></B>;

    typedef T0 <B><A HREF="#multiset__iterator">iterator</A></B>;
    typedef T1 <B><A HREF="#multiset__const_iterator">const_iterator</A></B>;
    typedef reverse_iterator&lt;const_iterator&gt;
        <B><A HREF="#multiset__const_reverse_iterator">const_reverse_iterator</A></B>;
    typedef reverse_iterator&lt;iterator&gt; <B><A HREF="#multiset__reverse_iterator">reverse_iterator</A></B>;

    <B><A HREF="#multiset__multiset">multiset</A></B>();
    explicit <B><A HREF="#multiset__multiset">multiset</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>
    explicit <B><A HREF="#multiset__multiset">multiset</A></B>(const Pr&amp; pred);
    <B><A HREF="#multiset__multiset">multiset</A></B>(const Pr&amp; pred, const Alloc&amp; al);

    <B><A HREF="#multiset__multiset">multiset</A></B>(const multiset&amp; right);
    <B><A HREF="#multiset__multiset">multiset</A></B>(const multiset&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#multiset__multiset">multiset</A></B>(multiset&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#multiset__multiset">multiset</A></B>(multiset&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>

    template&lt;class InIt&gt;
        <B><A HREF="#multiset__multiset">multiset</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#multiset__multiset">multiset</A></B>(InIt first, InIt last,
            const Pr&amp; pred);
    template&lt;class InIt&gt;
        <B><A HREF="#multiset__multiset">multiset</A></B>(InIt first, InIt last,
        const Pr&amp; pred, const Alloc&amp; al);

    <B><A HREF="#multiset__multiset">multiset</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#multiset__multiset">multiset</A></B>(initializer_list&lt;Ty&gt; init,
        const Pr&amp; pred); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#multiset__multiset">multiset</A></B>(initializer_list&lt;Ty&gt; init,
        const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#multiset__multiset">multiset</A></B>(multiset&amp;&amp; right); <B>[added with C++11]</B>

    multiset&amp; <B><A HREF="#multiset__operator2">operator=</A></B>(const multiset&amp; right);
    multiset&amp; <B><A HREF="#multiset__operator2">operator=</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    multiset&amp; <B><A HREF="#multiset__operator2">operator=</A></B>(multiset&amp;&amp; right); <B>[added with C++11]</B>

    iterator <B><A HREF="#multiset__begin">begin</A></B>() noexcept;
    const_iterator <B><A HREF="#multiset__begin">begin</A></B>() const noexcept;
    iterator <B><A HREF="#multiset__end">end</A></B>() noexcept;
    const_iterator <B><A HREF="#multiset__end">end</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#multiset__rbegin">rbegin</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#multiset__rbegin">rbegin</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#multiset__rend">rend</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#multiset__rend">rend</A></B>() const noexcept;

    const_iterator <B><A HREF="#multiset__cbegin">cbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_iterator <B><A HREF="#multiset__cend">cend</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#multiset__crbegin">crbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#multiset__crend">crend</A></B>() const noexcept; <B>[added with C++11]</B>

    size_type <B><A HREF="#multiset__max_size">max_size</A></B>() const noexcept;
    bool <B><A HREF="#multiset__empty">empty</A></B>() const noexcept;
    Alloc <B><A HREF="#multiset__get_allocator">get_allocator</A></B>() const noexcept;

    iterator <B><A HREF="#multiset__insert">insert</A></B>(const value_type&amp; val);
    iterator <B><A HREF="#multiset__insert">insert</A></B>(const_iterator where, const value_type&amp; val);
    template&lt;class InIt&gt;
        void <B><A HREF="#multiset__insert">insert</A></B>(InIt first, InIt last);
    void <B><A HREF="#multiset__insert">insert</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    iterator <B><A HREF="#multiset__insert">insert</A></B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
    iterator <B><A HREF="#multiset__insert">insert</A></B>(const_iterator where, value_type&amp;&amp; val); <B>[added with C++11]</B>

    template&lt;class... Valty&gt;
        pair&lt;iterator, bool&gt; <B><A HREF="#multiset__emplace">emplace</A></B>(Valty&amp;&amp;... val); <B>[added with C++11]</B>
    template&lt;class... Valty&gt;
        iterator <B><A HREF="#multiset__emplace_hint">emplace_hint</A></B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B>

    iterator <B><A HREF="#multiset__erase">erase</A></B>(const_iterator where);
    iterator <B><A HREF="#multiset__erase">erase</A></B>(const_iterator first, const_iterator last);
    size_type <B><A HREF="#multiset__erase">erase</A></B>(const Key&amp; keyval);
    void <B><A HREF="#multiset__clear">clear</A></B>() noexcept;

    void <B><A HREF="#multiset__swap">swap</A></B>(multiset&amp; right);

    key_compare <B><A HREF="#multiset__key_comp">key_comp</A></B>() const;
    value_compare <B><A HREF="#multiset__value_comp">value_comp</A></B>() const;

    iterator <B><A HREF="#multiset__find">find</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#multiset__find">find</A></B>(const Key&amp; keyval) const;

    size_type <B><A HREF="#multiset__count">count</A></B>(const Key&amp; keyval) const;

    iterator <B><A HREF="#multiset__lower_bound">lower_bound</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#multiset__lower_bound">lower_bound</A></B>(const Key&amp; keyval) const;

    iterator <B><A HREF="#multiset__upper_bound">upper_bound</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#multiset__upper_bound">upper_bound</A></B>(const Key&amp; keyval) const;

    pair&lt;iterator, iterator&gt; <B><A HREF="#multiset__equal_range">equal_range</A></B>(const Key&amp; keyval);
    pair&lt;const_iterator, const_iterator&gt;
        <B><A HREF="#multiset__equal_range">equal_range</A></B>(const Key&amp; keyval) const;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type
<CODE>const Key</CODE>.
The sequence is
<A HREF="lib_stl.html#sequence_ordering">ordered by</A> the predicate
<CODE>Pr</CODE>.
Each element serves as both a <B>sort key</B> and a <B>value</B>.
The sequence is represented in a way that permits lookup, insertion,
and removal of an arbitrary element with a number of operations
proportional to the logarithm of the number of elements
in the sequence (logarithmic time). Moreover, inserting an element
invalidates no iterators, and removing an element
invalidates only those iterators which point at the removed element.</P>

<P>The object orders the sequence it controls by calling a
stored <B>function object</B> of type <CODE>Pr</CODE>. You access
this stored object by calling the member function
<CODE><A HREF="#multiset__key_comp">key_comp</A>()</CODE>.
Such a function object must impose a
<A HREF="lib_stl.html#strict_weak_ordering">strict weak ordering</A>
on sort keys of type <CODE>Key</CODE>.
For any element <CODE>X</CODE> that precedes
<CODE>Y</CODE> in the sequence,
<CODE>key_comp()(Y, X)</CODE> is false. (For the default function object
<CODE><A HREF="functio2.html#less">less</A>&lt;Key&gt;</CODE>,
sort keys never decrease in value.)
Unlike template class <CODE><A HREF="#set">set</A></CODE>,
an object of template class <CODE>multiset</CODE> does not ensure that
<CODE>key_comp()(X, Y)</CODE> is true.
(Keys need not be unique.)</P>

<P>The object allocates and frees storage for the sequence it controls
through a stored <A HREF="memory.html#allocator_object">allocator object</A>
of class <CODE>Alloc</CODE>. Such an allocator object must have
the same external interface as an object of template class
<A HREF="memory.html#allocator"><CODE>allocator</CODE></A>.</P>

<P>Inserting and erasing elements preserves the order of
elements with equivalent ordering.</P>

<H3><CODE><A NAME="multiset__allocator_type"></A>multiset::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><CODE><A NAME="multiset__begin"></A>multiset::begin</CODE></H3>

<PRE>iterator <B>begin</B>() noexcept;
const_iterator <B>begin</B>() const noexcept;</PRE>

<P>The member function returns a bidirectional iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P>

<H3><CODE><A NAME="multiset__cbegin"></A>multiset::cbegin</CODE></H3>

<PRE>const_iterator <B>cbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a bidirectional iterator that points at the
first element of the sequence (or just beyond the end of an empty sequence).</P>

<H3><CODE><A NAME="multiset__cend"></A>multiset::cend</CODE></H3>

<PRE>const_reference <B>cend</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a bidirectional iterator that points just
beyond the end of the sequence.</P>

<H3><CODE><A NAME="multiset__clear"></A>multiset::clear</CODE></H3>

<PRE>void <B>clear</B>() noexcept;</PRE>

<P>The member function calls
<CODE><A HREF="#multiset__erase">erase</A>(
<A HREF="#multiset__begin">begin</A>(),
<A HREF="#multiset__end">end</A>())</CODE>.</P>

<H3><CODE><A NAME="multiset__const_iterator"></A>multiset::const_iterator</CODE></H3>

<PRE>typedef T1 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
bidirectional iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="multiset__const_pointer"></A>multiset::const_pointer</CODE></H3>

<PRE>typedef typename Alloc::const_pointer <B>const_pointer</B>;</PRE>

<P>The type describes an object that can serve as a constant pointer
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__const_reference"></A>multiset::const_reference</CODE></H3>

<PRE>typedef typename Alloc::const_reference <B>const_reference</B>;</PRE>

<P>The type describes an object that can serve as a constant reference
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__const_reverse_iterator"></A>multiset::const_reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;const_iterator&gt;
    <B>const_reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant reverse
bidirectional iterator for the controlled sequence.</P>

<H3><CODE><A NAME="multiset__count"></A>multiset::count</CODE></H3>

<PRE>size_type <B>count</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns the number of elements
in the range
<CODE>[<A HREF="#multiset__lower_bound">lower_bound</A>(keyval),
<A HREF="#multiset__upper_bound">upper_bound</A>(keyval)).</CODE></P>


<H3><CODE><A NAME="multiset__crbegin"></A>multiset::crbegin</CODE></H3>

<PRE>const_reverse_iterator <B>crbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points just beyond
the end of the controlled sequence. Hence, it designates the beginning
of the reverse sequence.</P>

<H3><CODE><A NAME="multiset__crend"></A>multiset::crend</CODE></H3>

<PRE>const_reverse_iterator <B>crend</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points at the first
element of the sequence (or just beyond the end of an empty sequence)). Hence,
it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="multiset__difference_type"></A>multiset::difference_type</CODE></H3>

<PRE>typedef typename Alloc::difference_type <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence.</P>

<H3><CODE><A NAME="multiset__emplace"></A>multiset::emplace</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    pair&lt;iterator, bool&gt; <B>emplace</B>(Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#multiset__insert">insert</A>(value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<H3><CODE><A NAME="multiset__emplace_hint"></A>multiset::emplace_hint</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    iterator <B>emplace_hint</B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#multiset__insert">insert</A>(where, value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<H3><CODE><A NAME="multiset__empty"></A>multiset::empty</CODE></H3>

<PRE>bool <B>empty</B>() const noexcept;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="multiset__end"></A>multiset::end</CODE></H3>

<PRE>iterator <B>end</B>() noexcept;
const_iterator <B>end</B>() const noexcept;</PRE>

<P>The member function returns a bidirectional iterator that points
just beyond the end of the sequence.</P>

<H3><CODE><A NAME="multiset__equal_range"></A>multiset::equal_range</CODE></H3>

<PRE>pair&lt;iterator, iterator&gt; <B>equal_range</B>(const Key&amp; keyval);
pair&lt;const_iterator, const_iterator&gt;
    <B>equal_range</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns a pair of iterators <CODE>X</CODE>
such that <CODE>X.<A HREF="utility.html#pair__first">first</A> ==
<A HREF="#multiset__lower_bound">lower_bound</A>(keyval)</CODE>
and <CODE>X.<A HREF="utility.html#pair__second">second</A> ==
<A HREF="#multiset__upper_bound">upper_bound</A>(keyval)</CODE>.</P>


<H3><CODE><A NAME="multiset__erase"></A>multiset::erase</CODE></H3>

<PRE>iterator <B>erase</B>(const_iterator where);
iterator <B>erase</B>(const_iterator first, const_iterator last);
size_type <B>erase</B>(const Key&amp; keyval);</PRE>

<P>The first member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>.
The second member function removes the elements
in the range <CODE>[first, last)</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#multiset__end">end</A>()</CODE> if no such element exists.</P>

<P>The third member removes
the elements with sort keys in the range
<CODE>[<A HREF="#multiset__lower_bound">lower_bound</A>(keyval),
<A HREF="#multiset__upper_bound">upper_bound</A>(keyval)).</CODE>
It returns the number of elements it removes.</P>

<P>The member functions never throw an exception,
nor do they alter the order of any remaining elements.</P>

<P>In this
implementation, the first two
member functions return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#multiset__end">end</A>()</CODE> if no such element exists.</P>

<H3><CODE><A NAME="multiset__find"></A>multiset::find</CODE></H3>

<PRE>iterator <B>find</B>(const Key&amp; keyval);
const_iterator <B>find</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates
the earliest element in the controlled sequence whose sort key has
<A HREF="lib_stl.html#equivalent_ordering">equivalent ordering</A>
to <CODE>keyval</CODE>. If no such element exists,
the function returns
<CODE><A HREF="#multiset__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="multiset__get_allocator"></A>multiset::get_allocator</CODE></H3>

<PRE>Alloc <B>get_allocator</B>() const noexcept;</PRE>

<P>The member function returns the stored
<A HREF="memory.html#allocator_object">allocator object</A>.</P>

<H3><CODE><A NAME="multiset__insert"></A>multiset::insert</CODE></H3>

<PRE>iterator <B>insert</B>(const value_type&amp; val);
iterator <B>insert</B>(const_iterator where, const value_type&amp; val);
template&lt;class InIt&gt;
    void <B>insert</B>(InIt first, InIt last);
void <B>insert</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
iterator <B>insert</B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
iterator <B>insert</B>(const_iterator where, value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member function inserts the element <CODE>val</CODE>
in the controlled sequence, then returns
the iterator that designates the inserted element.
Beginning with <B>C++11</B>,
insertion occurs at the end of a sequence of elements with
<A HREF="lib_stl.html#equivalent_ordering">equivalent ordering</A>.</P>

<P>The second member function returns <CODE>insert(val)</CODE>,
using <CODE>where</CODE> as a starting place within the controlled
sequence to search for the insertion point. (Insertion can occur
in amortized constant time, instead of logarithmic time, if the
insertion point immediately precedes or follows <CODE>where</CODE>.)
Beginning with <B>C++11</B>,
insertion occurs at the point nearest the position before
<CODE>where</CODE> in a sequence of elements with
equivalent ordering.</P>

<P>The third member function
inserts the sequence of element values,
for each <CODE>it</CODE> in the range <CODE>[first, last)</CODE>,
by calling <CODE>insert(*where)</CODE>.
Beginning with <B>C++11</B>,
insertion of each element occurs at the end of a sequence of elements with
equivalent ordering.</P>

<P>The fourth member function inserts the sequence
specified by an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The last two member functions behave the same as the first two
but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>If an exception is thrown during the
insertion of a single element, the container is left unaltered
and the exception is rethrown.
If an exception is thrown during the
insertion of multiple elements, the container is left in a stable
but unspecified state and the exception is rethrown.</P>

<P>The member functions never alter the order of any preexisting elements.</P>

<H3><CODE><A NAME="multiset__iterator"></A>multiset::iterator</CODE></H3>

<PRE>typedef T0 <B>iterator</B>;</PRE>

<P>The type describes an object that can serve as a bidirectional
iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T0</CODE>.</P>

<H3><CODE><A NAME="multiset__key_comp"></A>multiset::key_comp</CODE></H3>

<PRE>key_compare <B>key_comp</B>() const;</PRE>

<P>The member function returns the stored function object that
determines the order of elements in the controlled sequence.
The stored object defines the member function:</P>

<PRE>bool operator(const Key&amp; left, const Key&amp; right);</PRE>

<P>which returns true if <CODE>left</CODE> strictly
precedes <CODE>right</CODE> in the sort order.</P>

<H3><CODE><A NAME="multiset__key_compare"></A>multiset::key_compare</CODE></H3>

<PRE>typedef Pr <B>key_compare</B>;</PRE>

<P>The type describes a function object that can compare two
sort keys to determine the relative order of two
elements in the controlled sequence.</P>

<H3><CODE><A NAME="multiset__key_type"></A>multiset::key_type</CODE></H3>

<PRE>typedef Key <B>key_type</B>;</PRE>

<P>The type describes the sort key object which constitutes each
element of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__lower_bound"></A>multiset::lower_bound</CODE></H3>

<PRE>iterator <B>lower_bound</B>(const Key&amp; keyval);
const_iterator <B>lower_bound</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates the
earliest element <CODE>X</CODE> in the controlled sequence for which
<CODE><A HREF="#multiset__key_comp">key_comp</A>()(X, keyval)</CODE> is
false. If no such element exists, the function returns
<CODE><A HREF="#multiset__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="multiset__multiset"></A>multiset::multiset</CODE></H3>

<PRE><B>multiset</B>();
explicit <B>multiset</B>(const Alloc&amp; al); <B>[added with C++11]</B>
explicit <B>multiset</B>(const Pr&amp; pred);
<B>multiset</B>(const Pr&amp; pred, const Alloc&amp; al);

<B>multiset</B>(const multiset&amp; right);
<B>multiset</B>(const multiset&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>multiset</B>(multiset&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
<B>multiset</B>(multiset&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>

template&lt;class InIt&gt;
    <B>multiset</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>multiset</B>(InIt first, InIt last,
        const Pr&amp; pred);
template&lt;class InIt&gt;
    <B>multiset</B>(InIt first, InIt last,
        const Pr&amp; pred, const Alloc&amp; al);

<B>multiset</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
<B>multiset</B>(initializer_list&lt;Ty&gt; init,
    const Pr&amp; pred); <B>[added with C++11]</B>&nbsp;
<B>multiset</B>(initializer_list&lt;Ty&gt; init,
    const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>All constructors store an
<A HREF="memory.html#allocator_object">allocator object</A> and
initialize the controlled sequence. The allocator object is the argument
<CODE>al</CODE>, if present. Otherwise, for the copy and move constructors, it is
<CODE>right.<A HREF="#multiset__get_allocator">get_allocator</A>()</CODE>.
Otherwise, it is <CODE>Alloc()</CODE>.</P>

<P>All constructors also store a function object that can later
be returned by calling
<CODE><A HREF="#multiset__key_comp">key_comp</A>()</CODE>.
The function object is the argument <CODE>pred</CODE>, if present.
For the copy and move constructors, it is
<CODE>right.<A HREF="#multiset__key_comp">key_comp</A>()</CODE>).
Otherwise, it is <CODE>Pr()</CODE>.</P>

<P>The first four constructors specify an
empty initial controlled sequence.</P>

<P>The next four constructors specify
a copy of the sequence controlled by <CODE>right</CODE>.
The last two of these constructors are the same as the first two, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The next three constructors specify the sequence of element values
<CODE>[first, last)</CODE>.</P>

<P>The last three constructors specify the initial controlled sequence
with an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<H3><CODE><A NAME="multiset__max_size"></A>multiset::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const noexcept;</PRE>

<P>The member function returns the length of the longest sequence that
the object can control.</P>

<H3><CODE><A NAME="multiset__operator2"></A>multiset::operator=</CODE></H3>

<PRE>multiset&amp; <B>operator=</B>(const multiset&amp; right);
multiset&amp; <B>operator=</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
multiset&amp; <B>operator=</B>(multiset&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first member operator replaces the controlled sequence
with a copy of the sequence controlled by <CODE>right</CODE>.</P>

<P>The second member operator replaces the controlled sequence
from an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The third member operator is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="multiset__pointer"></A>multiset::pointer</CODE></H3>

<PRE>typedef typename Alloc::pointer <B>pointer</B>;</PRE>

<P>The type describes an object that can serve as a pointer to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__rbegin"></A>multiset::rbegin</CODE></H3>

<PRE>reverse_iterator <B>rbegin</B>() noexcept;
const_reverse_iterator <B>rbegin</B>() const noexcept;</PRE>

<P>The member function returns a reverse bidirectional
iterator that points just
beyond the end of the controlled sequence. Hence, it designates the
beginning of the reverse sequence.</P>

<H3><CODE><A NAME="multiset__reference"></A>multiset::reference</CODE></H3>

<PRE>typedef typename Alloc::reference <B>reference</B>;</PRE>

<P>The type describes an object that can serve as a reference to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__rend"></A>multiset::rend</CODE></H3>

<PRE>reverse_iterator <B>rend</B>() noexcept;
const_reverse_iterator <B>rend</B>() const noexcept;</PRE>

<P>The member function returns a reverse bidirectional
iterator that points at the
first element of the sequence (or just beyond the end of an empty
sequence). Hence, it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="multiset__reverse_iterator"></A>multiset::reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;iterator&gt; <B>reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a reverse
bidirectional iterator for the controlled sequence.</P>

<H3><CODE><A NAME="multiset__size"></A>multiset::size</CODE></H3>

<PRE>size_type <B>size</B>() const noexcept;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="multiset__size_type"></A>multiset::size_type</CODE></H3>

<PRE>typedef typename Alloc::size_type <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence.</P>

<H3><CODE><A NAME="multiset__swap"></A>multiset::swap</CODE></H3>

<PRE>void <B>swap</B>(multiset&amp; right);</PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. If
<CODE><A HREF="#multiset__get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time,
it throws an exception only as a result of copying the stored
function object of type <CODE>Pr</CODE>, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.
Otherwise, it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P>

<H3><CODE><A NAME="multiset__upper_bound"></A>multiset::upper_bound</CODE></H3>

<PRE>iterator <B>upper_bound</B>(const Key&amp; keyval);
const_iterator <B>upper_bound</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates the
earliest element <CODE>X</CODE> in the controlled sequence for which
<CODE><A HREF="#multiset__key_comp">key_comp</A>()(keyval, X)</CODE> is
true. If no such element exists, the function returns
<CODE><A HREF="#multiset__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="multiset__value_comp"></A>multiset::value_comp</CODE></H3>

<PRE>value_compare <B>value_comp</B>() const;</PRE>

<P>The member function returns a function object that
determines the order of elements in the controlled sequence.</P>

<H3><CODE><A NAME="multiset__value_compare"></A>multiset::value_compare</CODE></H3>

<PRE>typedef Pr <B>value_compare</B>;</PRE>

<P>The type describes a function object that can compare two
elements as sort keys to determine their relative order
in the controlled sequence.</P>

<H3><CODE><A NAME="multiset__value_type"></A>multiset::value_type</CODE></H3>

<PRE>typedef Key <B>value_type</B>;</PRE>

<P>The type describes an element of the controlled sequence.</P>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator!=</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator!=</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator==</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator==</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The first template function overloads <CODE>operator==</CODE>
to compare two objects of template class
<A HREF="#set"><CODE>set</CODE></A>.
The second template function overloads <CODE>operator==</CODE>
to compare two objects of template class
<A HREF="#multiset"><CODE>multiset</CODE></A>.
Both functions return
<CODE>left.<A HREF="#multiset__size">size</A>() == right.size() &amp;&amp;
<A HREF="algorith.html#equal">equal</A>(left.
<A HREF="#multiset__begin">begin</A>(), left.
<A HREF="#multiset__end">end</A>(), right.begin())</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The first template function overloads <CODE>operator&lt;</CODE>
to compare two objects of template class
<A HREF="#set"><CODE>set</CODE></A>.
The second template function overloads <CODE>operator&lt;</CODE>
to compare two objects of template class
<A HREF="#multiset"><CODE>multiset</CODE></A>.
Both functions return
<CODE><A HREF="algorith.html#lexicographical_compare">lexicographical_compare</A>(left.
<A HREF="#multiset__begin">begin</A>(), left.
<A HREF="#multiset__end">end</A>(), right.begin(), right.end(),
left.<A HREF="#multiset__value_comp">value_comp</A>())</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const set &lt;Key, Pr, Alloc&gt;&amp; left,
        const set &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        const multiset &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="set"></A><CODE>set</CODE></H2>

<HR>
<P><B><CODE><A HREF="#set__allocator_type">allocator_type</A>
&middot; <A HREF="#set__begin">begin</A>
&middot; <A HREF="#set__cbegin">cbegin</A>
&middot; <A HREF="#set__cend">cend</A>
&middot; <A HREF="#set__clear">clear</A>
&middot; <A HREF="#set__const_iterator">const_iterator</A>
&middot; <A HREF="#set__const_pointer">const_pointer</A>
&middot; <A HREF="#set__const_reference">const_reference</A>
&middot; <A HREF="#set__const_reverse_iterator">const_reverse_iterator</A>
&middot; <A HREF="#set__count">count</A>
&middot; <A HREF="#set__crbegin">crbegin</A>
&middot; <A HREF="#set__crend">crend</A>
&middot; <A HREF="#set__difference_type">difference_type</A>
&middot; <A HREF="#set__emplace">emplace</A>
&middot; <A HREF="#set__emplace_hint">emplace_hint</A>
&middot; <A HREF="#set__empty">empty</A>
&middot; <A HREF="#set__end">end</A>
&middot; <A HREF="#set__equal_range">equal_range</A>
&middot; <A HREF="#set__erase">erase</A>
&middot; <A HREF="#set__find">find</A>
&middot; <A HREF="#set__get_allocator">get_allocator</A>
&middot; <A HREF="#set__insert">insert</A>
&middot; <A HREF="#set__iterator">iterator</A>
&middot; <A HREF="#set__key_comp">key_comp</A>
&middot; <A HREF="#set__key_compare">key_compare</A>
&middot; <A HREF="#set__key_type">key_type</A>
&middot; <A HREF="#set__lower_bound">lower_bound</A>
&middot; <A HREF="#set__max_size">max_size</A>
&middot; <A HREF="#set__operator2">operator=</A>
&middot; <A HREF="#set__pointer">pointer</A>
&middot; <A HREF="#set__rbegin">rbegin</A>
&middot; <A HREF="#set__reference">reference</A>
&middot; <A HREF="#set__rend">rend</A>
&middot; <A HREF="#set__reverse_iterator">reverse_iterator</A>
&middot; <A HREF="#set__set">set</A>
&middot; <A HREF="#set__size">size</A>
&middot; <A HREF="#set__size_type">size_type</A>
&middot; <A HREF="#set__swap">swap</A>
&middot; <A HREF="#set__upper_bound">upper_bound</A>
&middot; <A HREF="#set__value_comp">value_comp</A>
&middot; <A HREF="#set__value_compare">value_compare</A>
&middot; <A HREF="#set__value_type">value_type</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Key, class Pr = less&lt;Key&gt;,
    class Alloc = allocator&lt;Key&gt; &gt;
    class <B>set</B> {
public:
    typedef Key <B><A HREF="#set__key_type">key_type</A></B>;
    typedef Pr <B><A HREF="#set__key_compare">key_compare</A></B>;
    typedef Key <B><A HREF="#set__value_type">value_type</A></B>;
    typedef Pr <B><A HREF="#set__value_compare">value_compare</A></B>;
    typedef Alloc <B><A HREF="#set__allocator_type">allocator_type</A></B>;
    typedef typename Alloc::pointer <B><A HREF="#set__pointer">pointer</A></B>;
    typedef typename Alloc::const_pointer <B><A HREF="#set__const_pointer">const_pointer</A></B>;
    typedef typename Alloc::reference <B><A HREF="#set__reference">reference</A></B>;
    typedef typename Alloc::const_reference <B><A HREF="#set__const_reference">const_reference</A></B>;
    typedef typename Alloc::size_type <B><A HREF="#set__size_type">size_type</A></B>;
    typedef typename Alloc::difference_type <B><A HREF="#set__difference_type">difference_type</A></B>;

    typedef T0 <B><A HREF="#set__iterator">iterator</A></B>;
    typedef T1 <B><A HREF="#set__const_iterator">const_iterator</A></B>;
    typedef reverse_iterator&lt;const_iterator&gt;
        <B><A HREF="#set__const_reverse_iterator">const_reverse_iterator</A></B>;
    typedef reverse_iterator&lt;iterator&gt; <B><A HREF="#set__reverse_iterator">reverse_iterator</A></B>;

    <B><A HREF="#set__set">set</A></B>();
    explicit <B><A HREF="#set__set">set</A></B>(const Alloc&amp; al); <B>[added with C++11]</B>
    explicit <B><A HREF="#set__set">set</A></B>(const Pr&amp; pred);
    <B><A HREF="#set__set">set</A></B>(const Pr&amp; pred, const Alloc&amp; al);

    <B><A HREF="#set__set">set</A></B>(const set&amp; right);
    <B><A HREF="#set__set">set</A></B>(const set&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#set__set">set</A></B>(set&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#set__set">set</A></B>(set&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>

    template&lt;class InIt&gt;
        <B><A HREF="#set__set">set</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#set__set">set</A></B>(InIt first, InIt last,
            const Pr&amp; pred);
    template&lt;class InIt&gt;
        <B><A HREF="#set__set">set</A></B>(InIt first, InIt last,
        const Pr&amp; pred, const Alloc&amp; al);

    <B><A HREF="#set__set">set</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#set__set">set</A></B>(initializer_list&lt;Ty&gt; init,
        const Pr&amp; pred); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#set__set">set</A></B>(initializer_list&lt;Ty&gt; init,
        const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#set__set">set</A></B>(set&amp;&amp; right); <B>[added with C++11]</B>

    set&amp; <B><A HREF="#set__operator2">operator=</A></B>(const set&amp; right);
    set&amp; <B><A HREF="#set__operator2">operator=</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    set&amp; <B><A HREF="#set__operator2">operator=</A></B>(set&amp;&amp; right); <B>[added with C++11]</B>

    iterator <B><A HREF="#set__begin">begin</A></B>() noexcept;
    const_iterator <B><A HREF="#set__begin">begin</A></B>() const noexcept;
    iterator <B><A HREF="#set__end">end</A></B>() noexcept;
    const_iterator <B><A HREF="#set__end">end</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#set__rbegin">rbegin</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#set__rbegin">rbegin</A></B>() const noexcept;
    reverse_iterator <B><A HREF="#set__rend">rend</A></B>() noexcept;
    const_reverse_iterator <B><A HREF="#set__rend">rend</A></B>() const noexcept;

    const_iterator <B><A HREF="#set__cbegin">cbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_iterator <B><A HREF="#set__cend">cend</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#set__crbegin">crbegin</A></B>() const noexcept; <B>[added with C++11]</B>
    const_reverse_iterator <B><A HREF="#set__crend">crend</A></B>() const noexcept; <B>[added with C++11]</B>

    size_type <B><A HREF="#set__max_size">max_size</A></B>() const noexcept;
    bool <B><A HREF="#set__empty">empty</A></B>() const noexcept;
    Alloc <B><A HREF="#set__get_allocator">get_allocator</A></B>() const noexcept;

    pair&lt;iterator, bool&gt; <B><A HREF="#set__insert">insert</A></B>(const value_type&amp; val);
    iterator <B><A HREF="#set__insert">insert</A></B>(const_iterator where, const value_type&amp; val);
    template&lt;class InIt&gt;
        void <B><A HREF="#set__insert">insert</A></B>(InIt first, InIt last);
    void <B><A HREF="#set__insert">insert</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    pair&lt;iterator, bool&gt; <B><A HREF="#set__insert">insert</A></B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
    iterator <B><A HREF="#set__insert">insert</A></B>(const_iterator where, value_type&amp;&amp; val); <B>[added with C++11]</B>

    template&lt;class... Valty&gt;
        pair&lt;iterator, bool&gt; <B><A HREF="#set__emplace">emplace</A></B>(Valty&amp;&amp;... val); <B>[added with C++11]</B>
    template&lt;class... Valty&gt;
        iterator <B><A HREF="#set__emplace_hint">emplace_hint</A></B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B>

    iterator <B><A HREF="#set__erase">erase</A></B>(const_iterator where);
    iterator <B><A HREF="#set__erase">erase</A></B>(const_iterator first, const_iterator last);
    size_type <B><A HREF="#set__erase">erase</A></B>(const Key&amp; keyval);
    void <B><A HREF="#set__clear">clear</A></B>() noexcept;

    void <B><A HREF="#set__swap">swap</A></B>(set&amp; right);

    key_compare <B><A HREF="#set__key_comp">key_comp</A></B>() const;
    value_compare <B><A HREF="#set__value_comp">value_comp</A></B>() const;

    iterator <B><A HREF="#set__find">find</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#set__find">find</A></B>(const Key&amp; keyval) const;

    size_type <B><A HREF="#set__count">count</A></B>(const Key&amp; keyval) const;

    iterator <B><A HREF="#set__lower_bound">lower_bound</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#set__lower_bound">lower_bound</A></B>(const Key&amp; keyval) const;

    iterator <B><A HREF="#set__upper_bound">upper_bound</A></B>(const Key&amp; keyval);
    const_iterator <B><A HREF="#set__upper_bound">upper_bound</A></B>(const Key&amp; keyval) const;

    pair&lt;iterator, iterator&gt; <B><A HREF="#set__equal_range">equal_range</A></B>(const Key&amp; keyval);
    pair&lt;const_iterator, const_iterator&gt;
        <B><A HREF="#set__equal_range">equal_range</A></B>(const Key&amp; keyval) const;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type <CODE>const Key</CODE>.
The sequence is
<A HREF="lib_stl.html#sequence_ordering">ordered by</A> the predicate
<CODE>Pr</CODE>.
Each element serves as both a <B>sort key</B> and a <B>value</B>.
The sequence is represented in a way that permits lookup, insertion,
and removal of an arbitrary element with a number of operations
proportional to the logarithm of the number of elements
in the sequence (logarithmic time). Moreover, inserting an element
invalidates no iterators, and removing an element
invalidates only those iterators which point at the removed element.</P>

<P>The object orders the sequence it controls by calling a
stored <B>function object</B> of type <CODE>Pr</CODE>. You access
this stored object by calling the member function
<CODE><A HREF="#set__key_comp">key_comp</A>()</CODE>.
Such a function object must impose a
<A HREF="lib_stl.html#strict_weak_ordering">strict weak ordering</A>
on sort keys of type <CODE>Key</CODE>.
For any element <CODE>X</CODE> that precedes
<CODE>Y</CODE> in the sequence,
<CODE>key_comp()(Y, X)</CODE> is false. (For the default function object
<CODE><A HREF="functio2.html#less">less</A>&lt;Key&gt;</CODE>,
sort keys never decrease in value.)
Unlike template class <CODE><A HREF="#multiset">multiset</A></CODE>,
an object of template class <CODE>set</CODE> ensures that
<CODE>key_comp()(X, Y)</CODE> is true.
(Each key is unique.)</P>

<P>The object allocates and frees storage for the sequence it controls
through a stored <A HREF="memory.html#allocator_object">allocator object</A>
of class <CODE>Alloc</CODE>. Such an allocator object must have
the same external interface as an object of template class
<A HREF="memory.html#allocator"><CODE>allocator</CODE></A>.</P>

<H3><CODE><A NAME="set__allocator_type"></A>set::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><CODE><A NAME="set__begin"></A>set::begin</CODE></H3>

<PRE>iterator <B>begin</B>() noexcept;
const_iterator <B>begin</B>() const noexcept;</PRE>

<P>The member function returns a bidirectional iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P>

<H3><CODE><A NAME="set__cbegin"></A>set::cbegin</CODE></H3>

<PRE>const_iterator <B>cbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a bidirectional iterator that points at the
first element of the sequence (or just beyond the end of an empty sequence).</P>

<H3><CODE><A NAME="set__cend"></A>set::cend</CODE></H3>

<PRE>const_reference <B>cend</B>() const; <B>[added with C++11]</B></PRE> noexcept

<P>The member functions return a bidirectional iterator that points just
beyond the end of the sequence.</P>

<H3><CODE><A NAME="set__clear"></A>set::clear</CODE></H3>

<PRE>void <B>clear</B>() noexcept;</PRE>

<P>The member function calls
<CODE><A HREF="#set__erase">erase</A>(
<A HREF="#set__begin">begin</A>(),
<A HREF="#set__end">end</A>())</CODE>.</P>

<H3><CODE><A NAME="set__const_iterator"></A>set::const_iterator</CODE></H3>

<PRE>typedef T1 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
bidirectional iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="set__const_pointer"></A>set::const_pointer</CODE></H3>

<PRE>typedef typename Alloc::const_pointer <B>const_pointer</B>;</PRE>

<P>The type describes an object that can serve as a constant pointer
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="set__const_reference"></A>set::const_reference</CODE></H3>

<PRE>typedef typename Alloc::const_reference <B>const_reference</B>;</PRE>

<P>The type describes an object that can serve as a constant reference
to an element of the controlled sequence.</P>

<H3><CODE><A NAME="set__const_reverse_iterator"></A>set::const_reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;const_iterator&gt;
    <B>const_reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant reverse
bidirectional iterator for the controlled sequence.</P>

<H3><CODE><A NAME="set__count"></A>set::count</CODE></H3>

<PRE>size_type <B>count</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns the number of elements
in the range
<CODE>[<A HREF="#set__lower_bound">lower_bound</A>(keyval),
<A HREF="#set__upper_bound">upper_bound</A>(keyval)).</CODE></P>


<H3><CODE><A NAME="set__crbegin"></A>set::crbegin</CODE></H3>

<PRE>const_reverse_iterator <B>crbegin</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points just beyond
the end of the controlled sequence. Hence, it designates the beginning
of the reverse sequence.</P>

<H3><CODE><A NAME="set__crend"></A>set::crend</CODE></H3>

<PRE>const_reverse_iterator <B>crend</B>() const noexcept; <B>[added with C++11]</B></PRE>

<P>The member functions return a reverse iterator that points at the first
element of the sequence (or just beyond the end of an empty sequence)). Hence,
it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="set__difference_type"></A>set::difference_type</CODE></H3>

<PRE>typedef typename Alloc::difference_type <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence.</P>

<H3><CODE><A NAME="set__emplace"></A>set::emplace</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    pair&lt;iterator, bool&gt; <B>emplace</B>(Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#set__insert">insert</A>(value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<H3><CODE><A NAME="set__emplace_hint"></A>set::emplace_hint</CODE></H3>

<PRE>template&lt;class... Valty&gt;
    iterator <B>emplace_hint</B>(const_iterator where, Valty&amp;&amp;... val); <B>[added with C++11]</B></PRE>

<P>The member function effectively returns
<CODE><A HREF="#set__insert">insert</A>(where, value_type(forward&lt;Valty&gt;(val)...))</CODE>,
except that the element value is constructed in place.</P>

<H3><CODE><A NAME="set__empty"></A>set::empty</CODE></H3>

<PRE>bool <B>empty</B>() const noexcept;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="set__end"></A>set::end</CODE></H3>

<PRE>iterator <B>end</B>() noexcept;
const_iterator <B>end</B>() const noexcept;</PRE>

<P>The member function returns a bidirectional iterator that points
just beyond the end of the sequence.</P>

<H3><CODE><A NAME="set__equal_range"></A>set::equal_range</CODE></H3>

<PRE>pair&lt;iterator, iterator&gt; <B>equal_range</B>(const Key&amp; keyval);
pair&lt;const_iterator, const_iterator&gt;
    <B>equal_range</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns a pair of iterators <CODE>X</CODE>
such that <CODE>X.<A HREF="utility.html#pair__first">first</A> ==
<A HREF="#set__lower_bound">lower_bound</A>(keyval)</CODE>
and <CODE>X.<A HREF="utility.html#pair__second">second</A> ==
<A HREF="#set__upper_bound">upper_bound</A>(keyval)</CODE>.</P>


<H3><CODE><A NAME="set__erase"></A>set::erase</CODE></H3>

<PRE>iterator <B>erase</B>(const_iterator where);
iterator <B>erase</B>(const_iterator first, const_iterator last);
size_type <B>erase</B>(const Key&amp; keyval);</PRE>

<P>The first member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>.
The second member function removes the elements
in the range <CODE>[first, last)</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#set__end">end</A>()</CODE> if no such element exists.</P>

<P>The third member removes
the elements with sort keys in the range
<CODE>[<A HREF="#set__lower_bound">lower_bound</A>(keyval),
<A HREF="#set__upper_bound">upper_bound</A>(keyval)).</CODE>
It returns the number of elements it removes.</P>

<P>The member functions never throw an exception.</P>

<P>In this
implementation, the first two
member functions return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#set__end">end</A>()</CODE> if no such element exists.</P>

<H3><CODE><A NAME="set__find"></A>set::find</CODE></H3>

<PRE>iterator <B>find</B>(const Key&amp; keyval);
const_iterator <B>find</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates
the element in the controlled sequence whose sort key has
<A HREF="lib_stl.html#equivalent_ordering">equivalent ordering</A>
to <CODE>keyval</CODE>. If no such element exists,
the function returns
<CODE><A HREF="#set__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="set__get_allocator"></A>set::get_allocator</CODE></H3>

<PRE>Alloc <B>get_allocator</B>() const noexcept;</PRE>

<P>The member function returns the stored
<A HREF="memory.html#allocator_object">allocator object</A>.</P>

<H3><CODE><A NAME="set__insert"></A>set::insert</CODE></H3>

<PRE>pair&lt;iterator, bool&gt; <B>insert</B>(const value_type&amp; val);
iterator <B>insert</B>(const_iterator where, const value_type&amp; val);
template&lt;class InIt&gt;
    void <B>insert</B>(InIt first, InIt last);
void <B>insert</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
pair&lt;iterator, bool&gt; <B>insert</B>(value_type&amp;&amp; val); <B>[added with C++11]</B>
iterator <B>insert</B>(const_iterator where, value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member function determines whether an element <CODE>X</CODE>
exists in the sequence whose key has
<A HREF="lib_stl.html#equivalent_ordering">equivalent ordering</A>
to that of <CODE>val</CODE>. If not, it creates such
an element <CODE>X</CODE> and initializes it with <CODE>val</CODE>.
The function then determines the iterator <CODE>where</CODE> that
designates <CODE>X</CODE>. If an insertion occurred, the function
returns <CODE><A HREF="utility.html#pair">pair</A>(where, true)</CODE>.
Otherwise, it returns <CODE>pair(where, false)</CODE>.</P>

<P>The second member function returns <CODE>insert(val).first</CODE>,
using <CODE>where</CODE> as a starting place within the controlled
sequence to search for the insertion point. (Insertion can occur
in amortized constant time, instead of logarithmic time, if the
insertion point immediately precedes or follows <CODE>where</CODE>.)</P>

<P>The third member function
inserts the sequence of element values,
for each <CODE>where</CODE> in the range <CODE>[first, last)</CODE>,
by calling <CODE>insert(*where)</CODE>.</P>

<P>The fourth member function inserts the sequence
specified by an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The last two member functions behave the same as the first two
but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>If an exception is thrown during the
insertion of a single element, the container is left unaltered
and the exception is rethrown.
If an exception is thrown during the
insertion of multiple elements, the container is left in a stable
but unspecified state and the exception is rethrown.</P>

<H3><CODE><A NAME="set__iterator"></A>set::iterator</CODE></H3>

<PRE>typedef T0 <B>iterator</B>;</PRE>

<P>The type describes an object that can serve as a bidirectional
iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T0</CODE>.</P>

<H3><CODE><A NAME="set__key_comp"></A>set::key_comp</CODE></H3>

<PRE>key_compare <B>key_comp</B>() const;</PRE>

<P>The member function returns the stored function object that
determines the order of elements in the controlled sequence.
The stored object defines the member function:</P>

<PRE>bool operator(const Key&amp; left, const Key&amp; right);</PRE>

<P>which returns true if <CODE>left</CODE> strictly
precedes <CODE>right</CODE> in the sort order.</P>

<H3><CODE><A NAME="set__key_compare"></A>set::key_compare</CODE></H3>

<PRE>typedef Pr <B>key_compare</B>;</PRE>

<P>The type describes a function object that can compare two
sort keys to determine the relative order of two
elements in the controlled sequence.</P>

<H3><CODE><A NAME="set__key_type"></A>set::key_type</CODE></H3>

<PRE>typedef Key <B>key_type</B>;</PRE>

<P>The type describes the sort key object which constitutes each
element of the controlled sequence.</P>

<H3><CODE><A NAME="set__lower_bound"></A>set::lower_bound</CODE></H3>

<PRE>iterator <B>lower_bound</B>(const Key&amp; keyval);
const_iterator <B>lower_bound</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates the
earliest element <CODE>X</CODE> in the controlled sequence for which
<CODE><A HREF="#set__key_comp">key_comp</A>()(X, keyval)</CODE> is
false. If no such element exists, the function returns
<CODE><A HREF="#set__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="set__max_size"></A>set::max_size</CODE></H3>

<PRE>size_type <B>max_size</B>() const noexcept;</PRE>

<P>The member function returns the length of the longest sequence that
the object can control.</P>

<H3><CODE><A NAME="set__operator2"></A>set::operator=</CODE></H3>

<PRE>set&amp; <B>operator=</B>(const set&amp; right);
set&amp; <B>operator=</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
set&amp; <B>operator=</B>(set&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first member operator replaces the controlled sequence
with a copy of the sequence controlled by <CODE>right</CODE>.</P>

<P>The second member operator replaces the controlled sequence
from an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The third member operator is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><CODE><A NAME="set__pointer"></A>set::pointer</CODE></H3>

<PRE>typedef typename Alloc::pointer <B>pointer</B>;</PRE>

<P>The type describes an object that can serve as a pointer to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="set__rbegin"></A>set::rbegin</CODE></H3>

<PRE>reverse_iterator <B>rbegin</B>() noexcept;
const_reverse_iterator <B>rbegin</B>() const noexcept;</PRE>

<P>The member function returns a reverse bidirectional
iterator that points just
beyond the end of the controlled sequence. Hence, it designates the
beginning of the reverse sequence.</P>

<H3><CODE><A NAME="set__reference"></A>set::reference</CODE></H3>

<PRE>typedef typename Alloc::const_reference <B>const_reference</B>;</PRE>

<P>The type describes an object that can serve as a reference to an
element of the controlled sequence.</P>

<H3><CODE><A NAME="set__rend"></A>set::rend</CODE></H3>

<PRE>reverse_iterator <B>rend</B>() noexcept;
const_reverse_iterator <B>rend</B>() const noexcept;</PRE>

<P>The member function returns a reverse bidirectional
iterator that points at the
first element of the sequence (or just beyond the end of an empty
sequence). Hence, it designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="set__reverse_iterator"></A>set::reverse_iterator</CODE></H3>

<PRE>typedef reverse_iterator&lt;iterator&gt; <B>reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a reverse
bidirectional iterator for the controlled sequence.</P>

<H3><CODE><A NAME="set__set"></A>set::set</CODE></H3>

<PRE><B>set</B>();
explicit <B>set</B>(const Alloc&amp; al); <B>[added with C++11]</B>
explicit <B>set</B>(const Pr&amp; pred);
<B>set</B>(const Pr&amp; pred, const Alloc&amp; al);

<B>set</B>(const set&amp; right);
<B>set</B>(const set&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>&nbsp;
<B>set</B>(set&amp;&amp; right); <B>[added with C++11]</B>&nbsp;
<B>set</B>(set&amp;&amp; right, const Alloc&amp; al); <B>[added with C++11]</B>

template&lt;class InIt&gt;
    <B>set</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>set</B>(InIt first, InIt last,
        const Pr&amp; pred);
template&lt;class InIt&gt;
    <B>set</B>(InIt first, InIt last,
        const Pr&amp; pred, const Alloc&amp; al);

<B>set</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>&nbsp;
<B>set</B>(initializer_list&lt;Ty&gt; init,
    const Pr&amp; pred); <B>[added with C++11]</B>&nbsp;
<B>set</B>(initializer_list&lt;Ty&gt; init,
    const Pr&amp; pred, const Alloc&amp; al); <B>[added with C++11]</B></PRE>

<P>All constructors store an
<A HREF="memory.html#allocator_object">allocator object</A> and
initialize the controlled sequence. The allocator object is the argument
<CODE>al</CODE>, if present. Otherwise, for the copy and move constructors, it is
<CODE>right.<A HREF="#set__get_allocator">get_allocator</A>()</CODE>.
Otherwise, it is <CODE>Alloc()</CODE>.</P>

<P>All constructors also store a function object that can later
be returned by calling
<CODE><A HREF="#set__key_comp">key_comp</A>()</CODE>.
The function object is the argument <CODE>pred</CODE>, if present.
For the copy and move constructors, it is
<CODE>right.<A HREF="#set__key_comp">key_comp</A>()</CODE>).
Otherwise, it is <CODE>Pr()</CODE>.</P>

<P>The first four constructors specify an
empty initial controlled sequence.</P>

<P>The next four constructors specify
a copy of the sequence controlled by <CODE>right</CODE>.
The last two of these constructors are the same as the first two, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The next three constructors specify the sequence of element values
<CODE>[first, last)</CODE>.</P>

<P>The last three constructors specify the initial controlled sequence
with an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<H3><CODE><A NAME="set__size"></A>set::size</CODE></H3>

<PRE>size_type <B>size</B>() const noexcept;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="set__size_type"></A>set::size_type</CODE></H3>

<PRE>typedef typename Alloc::size_type <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence.</P>

<H3><CODE><A NAME="set__swap"></A>set::swap</CODE></H3>

<PRE>void <B>swap</B>(set&amp; right);</PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. If
<CODE><A HREF="#set__get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time,
it throws an exception only as a result of copying the stored
function object of type <CODE>Pr</CODE>, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.
Otherwise, it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P>

<H3><CODE><A NAME="set__upper_bound"></A>set::upper_bound</CODE></H3>

<PRE>iterator <B>upper_bound</B>(const Key&amp; keyval);
const_iterator <B>upper_bound</B>(const Key&amp; keyval) const;</PRE>

<P>The member function returns an iterator that designates the
earliest element <CODE>X</CODE> in the controlled sequence for which
<CODE><A HREF="#set__key_comp">key_comp</A>()(keyval, X)</CODE> is
true. If no such element exists, the function returns
<CODE><A HREF="#set__end">end</A>()</CODE>.</P>


<H3><CODE><A NAME="set__value_comp"></A>set::value_comp</CODE></H3>

<PRE>value_compare <B>value_comp</B>() const;</PRE>

<P>The member function returns a function object that
determines the order of elements in the controlled sequence.</P>

<H3><CODE><A NAME="set__value_compare"></A>set::value_compare</CODE></H3>

<PRE>typedef Pr <B>value_compare</B>;</PRE>

<P>The type describes a function object that can compare two
elements as sort keys to determine their relative order
in the controlled sequence.</P>

<H3><CODE><A NAME="set__value_type"></A>set::value_type</CODE></H3>

<PRE>typedef Key <B>value_type</B>;</PRE>

<P>The type describes an element of the controlled sequence.</P>

<H2><A NAME="swap"></A><CODE>swap</CODE></H2>

<PRE>template&lt;class Key, class Pr, class Alloc&gt;
    void <B>swap</B>(
        multiset &lt;Key, Pr, Alloc&gt;&amp; left,
        multiset &lt;Key, Pr, Alloc&gt;&amp; right);
template&lt;class Key, class Pr, class Alloc&gt;
    void <B>swap</B>(
        set &lt;Key, Pr, Alloc&gt;&amp; left,
        set &lt;Key, Pr, Alloc&gt;&amp; right);</PRE>

<P>The template function executes
<CODE>left.swap(right)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
