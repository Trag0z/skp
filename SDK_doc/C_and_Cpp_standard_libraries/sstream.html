<HTML><HEAD>
<TITLE>&lt;sstream&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;sstream&gt;"></A><CODE>&lt;sstream&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#basic_istringstream">basic_istringstream</A>
&middot; <A HREF="#basic_ostringstream">basic_ostringstream</A>
&middot; <A HREF="#basic_stringbuf">basic_stringbuf</A>
&middot; <A HREF="#basic_stringstream">basic_stringstream</A>
&middot; <A HREF="#istringstream">istringstream</A>
&middot; <A HREF="#ostringstream">ostringstream</A>
&middot; <A HREF="#stringbuf">stringbuf</A>
&middot; <A HREF="#stringstream">stringstream</A>
&middot; <A HREF="#wistringstream">wistringstream</A>
&middot; <A HREF="#wostringstream">wostringstream</A>
&middot; <A HREF="#wstringbuf">wstringbuf</A>
&middot; <A HREF="#wstringstream">wstringstream</A>
&middot; <A HREF="#swap">swap</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="lib_cpp.html#iostreams">iostreams</A>
standard header <B><CODE>&lt;sstream&gt;</CODE></B>
to define several template classes that support
iostreams operations on
sequences stored in an allocated array object.
Such sequences are easily converted to and from objects of
template class
<CODE><A HREF="string2.html#basic_string">basic_string</A></CODE>.</P>

<PRE>namespace std {
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_stringbuf">basic_stringbuf</A></B>;
typedef basic_stringbuf&lt;char&gt; <B><A HREF="#stringbuf">stringbuf</A></B>;
typedef basic_stringbuf&lt;wchar_t&gt; <B><A HREF="#wstringbuf">wstringbuf</A></B>;

template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_istringstream">basic_istringstream</A></B>;
typedef basic_istringstream&lt;char&gt; <B><A HREF="#istringstream">istringstream</A></B>;
typedef basic_istringstream&lt;wchar_t&gt; <B><A HREF="#wistringstream">wistringstream</A></B>;

template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_ostringstream">basic_ostringstream</A></B>;
typedef basic_ostringstream&lt;char&gt; <B><A HREF="#ostringstream">ostringstream</A></B>;
typedef basic_ostringstream&lt;wchar_t&gt; <B><A HREF="#wostringstream">wostringstream</A></B>;

template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_stringstream">basic_stringstream</A></B>;
typedef basic_stringstream&lt;char&gt; <B><A HREF="#stringstream">stringstream</A></B>;
typedef basic_stringstream&lt;wchar_t&gt; <B><A HREF="#wstringstream">wstringstream</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(basic_stringbuf&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_stringbuf&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(basic_istringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_istringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(basic_ostringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_ostringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(basic_stringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_stringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
}  // namespace std</PRE>

<H2><A NAME="basic_istringstream"></A><CODE>basic_istringstream</CODE></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_istringstream</B>
        : public basic_istream&lt;Elem, Tr&gt; {
public:
    typedef Alloc <B><A HREF="#basic_istringstream__allocator_type">allocator_type</A></B>;

    explicit <B><A HREF="#basic_istringstream__basic_istringstream">basic_istringstream</A></B>(
        ios_base::openmode mode = ios_base::in);
    explicit <B><A HREF="#basic_istringstream__basic_istringstream">basic_istringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode = ios_base::in);
    <B><A HREF="#basic_istringstream__basic_istringstream">basic_istringstream</A></B>(basic_istringstream&amp;&amp; right); <B>[added with C++11]</B>

    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_istringstream__rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_istringstream__str">str</A></B>();
    void <B><A HREF="#basic_istringstream__str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);

    basic_istringstream&amp; <B><A HREF="#basic_istringstream__operator2">operator=</A></B>(basic_istringstream&amp;&amp; right); <B>[added with C++11]</B>
    void <B><A HREF="#basic_istringstream__swap">swap</A></B>(basic_istringstream&amp; right); <B>[added with C++11]</B>
    };</PRE>

<P>The template class describes an object that controls
extraction of elements and encoded objects from a
<A HREF="streambu.html#stream_buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_istringstream__allocator_type"></A><CODE>basic_istringstream::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_istringstream__basic_istringstream"></A><CODE>basic_istringstream::basic_istringstream</CODE></H3>

<PRE>explicit <B>basic_istringstream</B>(
    ios_base::openmode mode = ios_base::in);
explicit <B>basic_istringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode = ios_base::in);
<B>basic_istringstream</B>(basic_istringstream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="istream.html#basic_istream__basic_istream">basic_istream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode | ios_base::in)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_istream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode | ios_base::in)</CODE>.</P>

<P>The third constructor initializes the object with the contents of
<CODE>right</CODE>, treated as an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="basic_istringstream__operator2"></A><CODE>basic_istringstream::operator=</CODE></H3>

<PRE>basic_istringstream&amp; <B>operator=</B>(basic_istringstream&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The member operator replaces the contents of the object with the contents of
<CODE>right</CODE>, treated as an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="basic_istringstream__rdbuf"></A><CODE>basic_istringstream::rdbuf</CODE></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_istringstream__str"></A><CODE>basic_istringstream::str</CODE></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_istringstream__rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf__str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H3><A NAME="basic_istringstream__swap"></A><CODE>basic_istringstream::swap</CODE></H3>

<PRE>void <B>swap</B>(basic_istringstream&amp; right); <B>[added with C++11]</B></PRE>

<P>The member function exchanges the contents of the object with the contents of
<CODE>right</CODE>.</P>

<H2><A NAME="basic_ostringstream"></A><CODE>basic_ostringstream</CODE></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_ostringstream</B>
        : public basic_ostream&lt;Elem, Tr&gt; {
public:
    typedef Alloc <B><A HREF="#basic_ostringstream__allocator_type">allocator_type</A></B>;

    explicit <B><A HREF="#basic_ostringstream__basic_ostringstream">basic_ostringstream</A></B>(
        ios_base::openmode mode = ios_base::out);
    explicit <B><A HREF="#basic_ostringstream__basic_ostringstream">basic_ostringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode = ios_base::out);
    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_ostringstream__rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_ostringstream__str">str</A></B>();
    void <B><A HREF="#basic_ostringstream__str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
    };</PRE>

<P>The template class describes an object that controls
insertion of elements and encoded objects into a
<A HREF="streambu.html#stream_buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_ostringstream__allocator_type"></A><CODE>basic_ostringstream::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_ostringstream__basic_ostringstream"></A><CODE>basic_ostringstream::basic_ostringstream</CODE></H3>

<PRE>explicit <B>basic_ostringstream</B>(
    ios_base::openmode mode = ios_base::out);
explicit <B>basic_ostringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode = ios_base::out);</PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="ostream.html#basic_ostream__basic_ostream">basic_ostream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode | ios_base::out)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_ostream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode | ios_base::out)</CODE>.</P>

<H3><A NAME="basic_ostringstream__rdbuf"></A><CODE>basic_ostringstream::rdbuf</CODE></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_ostringstream__str"></A><CODE>basic_ostringstream::str</CODE></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_ostringstream__rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf__str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H2><A NAME="basic_stringbuf"></A><CODE>basic_stringbuf</CODE></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_stringbuf</B>
        : public basic_streambuf&lt;Elem, Tr&gt; {
public:
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::char_type
        <B><A HREF="#basic_stringbuf__char_type">char_type</A></B>;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::traits_type
        <B><A HREF="#basic_stringbuf__traits_type">traits_type</A></B>;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::int_type
        <B><A HREF="#basic_stringbuf__int_type">int_type</A></B>;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::pos_type
        <B><A HREF="#basic_stringbuf__pos_type">pos_type</A></B>;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::off_type
        <B><A HREF="#basic_stringbuf__off_type">off_type</A></B>;
    typedef Alloc <B><A HREF="#basic_stringbuf__allocator_type">allocator_type</A></B>;

    <B><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A></B>(ios_base::openmode mode =
        ios_base::in | ios_base::out);
    <B><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    <B><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A></B>(basic_stringbuf&amp;&amp; right); <B>[added with C++11]</B>

    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_stringbuf__str">str</A></B>() const;
    void <B><A HREF="#basic_stringbuf__str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);

    basic_stringbuf&amp; <B><A HREF="#basic_stringbuf__operator2">operator=</A></B>(basic_stringbuf&amp;&amp; right); <B>[added with C++11]</B>
    void <B><A HREF="#basic_stringbuf__swap">swap</A></B>(basic_stringbuf&amp; right); <B>[added with C++11]</B>

protected:
    virtual pos_type <B><A HREF="#basic_stringbuf__seekoff">seekoff</A></B>(off_type off,
        ios_base::seekdir way,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    virtual pos_type <B><A HREF="#basic_stringbuf__seekpos">seekpos</A></B>(pos_type sp,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    virtual int_type <B><A HREF="#basic_stringbuf__underflow">underflow</A></B>();
    virtual int_type <B><A HREF="#basic_stringbuf__pbackfail">pbackfail</A></B>(int_type meta =
        traits_type::eof());
    virtual int_type <B><A HREF="#basic_stringbuf__overflow">overflow</A></B>(int_type meta =
        traits_type::eof());
    };</PRE>

<P>The template class
describes a <B><A HREF="streambu.html#stream_buffer">stream buffer</A></B> that controls
the transmission of elements
of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined by the
class <CODE>Tr</CODE>,
to and from a sequence of elements
stored in an array object. The object is allocated, extended, and
freed as necessary to accommodate changes in the sequence.</P>

<P>An object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>
stores a copy of the
<CODE>ios_base::<A HREF="ios.html#ios_base__openmode">openmode</A></CODE>
argument from its constructor as its
<B><A NAME="stringbuf_mode"></A>stringbuf mode</B> <CODE>mode</CODE>:</P>

<UL>
<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__in">in</A></CODE> is nonzero,
the <A HREF="streambu.html#input_buffer">input buffer</A>
is accessible.</LI>

<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__out">out</A></CODE> is nonzero,
the <A HREF="streambu.html#output_buffer">output buffer</A>
is accessible.</LI>

<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__ate">ate</A></CODE> is nonzero,
the stream position is set to the end of the stream when the stream
is first constructed.</LI>

<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__app">app</A></CODE> is nonzero,
the stream position is set to the end of the stream before each
insertion.</LI>
</UL>

<H3><A NAME="basic_stringbuf__allocator_type"></A><CODE>basic_stringbuf::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_stringbuf__basic_stringbuf"></A><CODE>basic_stringbuf::basic_stringbuf</CODE></H3>

<PRE><B>basic_stringbuf</B>(ios_base::openmode mode =
    ios_base::in | ios_base::out);
<B>basic_stringbuf</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);
<B>basic_stringbuf</B>(basic_stringbuf&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The first constructor stores a null pointer in all the pointers
controlling the
<A HREF="streambu.html#input_buffer">input buffer</A> and the
<A HREF="streambu.html#output_buffer">output buffer</A>. It
also stores <CODE>mode</CODE> as the
<A HREF="#stringbuf_mode">stringbuf mode</A>.</P>

<P>The second constructor allocates a copy of the sequence controlled
by the string object <CODE>str</CODE>.
If <CODE>mode &amp; ios_base::in</CODE> is nonzero,
it sets the input buffer to begin reading
at the start of the sequence.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
it sets the output buffer to begin
writing at the start of the sequence.
It also stores <CODE>mode</CODE> as the
<A HREF="#stringbuf_mode">stringbuf mode</A>.</P>

<P>The third constructor initializes the object with the contents of
<CODE>right</CODE>, treated as an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="basic_stringbuf__char_type"></A><CODE>basic_stringbuf::char_type</CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="basic_stringbuf__int_type"></A><CODE>basic_stringbuf::int_type</CODE></H3>

<PRE>typedef typename traits_type::int_type <B>int_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits__int_type">int_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf__off_type"></A><CODE>basic_stringbuf::off_type</CODE></H3>

<PRE>typedef typename traits_type::off_type <B>off_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits__off_type">off_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf__operator2"></A><CODE>basic_stringbuf::operator=</CODE></H3>

<PRE>basic_stringbuf&amp; <B>operator=</B>(basic_stringbuf&amp;&amp; right); <B>[added with C++11]</B></PRE>

<P>The member operator replaces the contents of the object with the contents of
<CODE>right</CODE>, treated as an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="basic_stringbuf__overflow"></A><CODE>basic_stringbuf::overflow</CODE></H3>

<PRE>virtual int_type <B>overflow</B>(int_type meta =
    traits_type::eof());</PRE>

<P>If <CODE>meta</CODE> does not compare equal to
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>,
the protected virtual member function endeavors to insert the element
<CODE>traits_type::<A HREF="string2.html#char_traits__to_char_type">to_char_type</A>(meta)</CODE>
into the
<A HREF="streambu.html#output_buffer">output buffer</A>.
It can do so in various ways:</P>

<UL>
<LI>If a <A HREF="streambu.html#write_position">write position</A>
is available, it can store the element into the write position
and increment the next pointer for the output buffer.</LI>

<LI>It can make a write position available by allocating
new or additional storage for the output buffer. (Extending the
output buffer this way also extends any associated
<A HREF="streambu.html#input_buffer">input buffer</A>.)</LI>
</UL>

<P>If the function cannot succeed, it returns <CODE>traits_type::eof()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits__not_eof">not_eof</A>(meta)</CODE>.</P>

<H3><A NAME="basic_stringbuf__pbackfail"></A><CODE>basic_stringbuf::pbackfail</CODE></H3>

<PRE>virtual int_type <B>pbackfail</B>(int_type meta =
    traits_type::eof());</PRE>

<P>The protected virtual member function endeavors to put back an element
into the
<A HREF="streambu.html#input_buffer">input buffer</A>,
then make it the current element (pointed to
by the next pointer).
If <CODE>meta</CODE> compares equal to
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>,
the element to push back is effectively the one already in the stream
before the current element. Otherwise, that element is replaced by
<CODE>byte =
traits_type::<A HREF="string2.html#char_traits__to_char_type">to_char_type</A>(meta)</CODE>.
The function can put back an element in various ways:</P>

<UL>
<LI>If a <A HREF="streambu.html#putback_position">putback position</A>
is available, and the element stored there compares equal to <CODE>byte</CODE>,
it can simply decrement the next pointer for the input buffer.</LI>

<LI>If a putback position is available,
and if the <A HREF="#stringbuf_mode">stringbuf mode</A> permits
the sequence to be altered (<CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__out">out</A></CODE> is nonzero),
it can store <CODE>byte</CODE> into the putback position and decrement the
next pointer for the input buffer.</LI>
</UL>

<P>If the function cannot succeed, it returns
<CODE>traits_type::eof()</CODE>. Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits__not_eof">not_eof</A>(meta)</CODE>.</P>

<H3><A NAME="basic_stringbuf__pos_type"></A><CODE>basic_stringbuf::pos_type</CODE></H3>

<PRE>typedef typename traits_type::pos_type <B>pos_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits__pos_type">pos_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf__seekoff"></A><CODE>basic_stringbuf::seekoff</CODE></H3>

<PRE>virtual pos_type <B>seekoff</B>(off_type off,
    ios_base::seekdir way,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);</PRE>

<P>The protected virtual member function endeavors to alter the current
positions for the controlled streams. For an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>,
a stream position consists
purely of a stream offset. Offset zero designates the first element
of the controlled sequence.</P>

<P>The new position is determined as follows:</P>

<UL>
<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base__beg">beg</A></CODE>,
the new position is the beginning of the stream plus <CODE>off</CODE>.</LI>

<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base__cur">cur</A></CODE>,
the new position is the current stream position plus <CODE>off</CODE>.</LI>

<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base__end">end</A></CODE>,
the new position is the end of the stream plus <CODE>off</CODE>.</LI>
</UL>

<P>If
<CODE>mode &amp; ios_base::in</CODE> is nonzero,
the function alters the next position to read in the
<A HREF="streambu.html#input_buffer">input buffer</A>.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
the function alters the next position to write in the
<A HREF="streambu.html#output_buffer">output buffer</A>.
For a stream to be affected, its buffer must exist.
For a positioning operation to succeed, the resulting
stream position must be zero or lie within the controlled sequence.
If the function affects both stream positions, <CODE>way</CODE>
must be <CODE>ios_base::beg</CODE> or <CODE>ios_base::end</CODE>
and both streams are positioned at the same element.
Otherwise (or if neither position is affected) the positioning
operation fails.</P>

<P>If the function succeeds in altering either or both of the stream positions,
it returns the resultant stream position.
Otherwise, it fails and returns an invalid stream position.</P>

<H3><A NAME="basic_stringbuf__seekpos"></A><CODE>basic_stringbuf::seekpos</CODE></H3>

<PRE>virtual pos_type <B>seekpos</B>(pos_type sp,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);</PRE>

<P>The protected virtual member function endeavors to alter the current
positions for the controlled streams. For an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>,
a stream position consists
purely of a stream offset. Offset zero designates the first element
of the controlled sequence. The new position is determined
by <CODE>sp</CODE>.</P>

<P>If
<CODE>mode &amp; ios_base::in</CODE> is nonzero,
the function alters the next position to read in the
<A HREF="streambu.html#input_buffer">input buffer</A>.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
the function alters the next position to write in the
<A HREF="streambu.html#output_buffer">output buffer</A>.
For a stream to be affected, its buffer must exist.
For a positioning operation to succeed, the resulting
stream position must lie within the controlled sequence.
Otherwise (or if neither position is affected) the positioning
operation fails.</P>

<P>If the function succeeds in altering either or both of the stream positions,
it returns the resultant stream position.
Otherwise, it fails and returns an invalid stream position.</P>

<H3><A NAME="basic_stringbuf__str"></A><CODE>basic_stringbuf::str</CODE></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns an object of class
<CODE><A HREF="string2.html#basic_string">basic_string</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
whose controlled sequence is a copy of the sequence controlled
by <CODE>*this</CODE>. The sequence copied depends on the stored
<A HREF="#stringbuf_mode">stringbuf mode</A> <CODE>mode</CODE>:</P>

<UL>
<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__out">out</A></CODE> is nonzero
and an <A HREF="streambu.html#output_buffer">output buffer</A> exists,
the sequence is the entire output buffer
(<CODE><A HREF="streambu.html#basic_streambuf__epptr">epptr</A>() -
<A HREF="streambu.html#basic_streambuf__pbase">pbase</A>()</CODE>
elements beginning with <CODE>pbase()</CODE>).</LI>

<LI>Otherwise, if <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base__in">in</A></CODE> is nonzero
and an <A HREF="streambu.html#input_buffer">input buffer</A> exists,
the sequence is the entire input buffer
(<CODE><A HREF="streambu.html#basic_streambuf__egptr">egptr</A>() -
<A HREF="streambu.html#basic_streambuf__eback">eback</A>()</CODE>
elements beginning with <CODE>eback()</CODE>).</LI>

<LI>Otherwise, the copied sequence is empty.</LI>
</UL>

<P>The second member function deallocates any sequence currently
controlled by <CODE>*this</CODE>. It then
allocates a copy of the sequence controlled
by <CODE>newstr</CODE>. If <CODE>mode &amp; ios_base::in</CODE> is nonzero,
it sets the input buffer to begin reading
at the beginning of the sequence.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
it sets the output buffer to begin
writing at the beginning of the sequence.</P>

<H3><A NAME="basic_stringbuf__swap"></A><CODE>basic_stringbuf::swap</CODE></H3>

<PRE>void <B>swap</B>(basic_stringbuf&amp; right); <B>[added with C++11]</B></PRE>

<P>The member function exchanges the contents of the object with the contents of
<CODE>right</CODE>.</P>

<H3><A NAME="basic_stringbuf__traits_type"></A><CODE>basic_stringbuf::traits_type</CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H3><A NAME="basic_stringbuf__underflow"></A><CODE>basic_stringbuf::underflow</CODE></H3>

<PRE>virtual int_type <B>underflow</B>();</PRE>

<P>The protected virtual member function endeavors to extract the current
element <CODE>byte</CODE> from the
<A HREF="streambu.html#input_buffer">input buffer</A>,
then advance the current stream position, and return the element as
<CODE>traits_type::<A HREF="string2.html#char_traits__to_int_type">to_int_type</A>(byte)</CODE>.
It can do so in only one way:
If a <A HREF="streambu.html#read_position">read position</A>
is available, it takes <CODE>byte</CODE> as the element stored
in the read position and advances the next pointer for the input buffer.</P>

<P>If the function cannot succeed, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits__eof">eof</A>()</CODE>. Otherwise,
it returns the current element in the input stream,
converted as described above.</P>

<H2><A NAME="basic_stringstream"></A><CODE>basic_stringstream</CODE></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_stringstream</B>
        : public basic_iostream&lt;Elem, Tr&gt; {
public:
    typedef Alloc <B><A HREF="#basic_stringstream__allocator_type">allocator_type</A></B>;
    explicit <B><A HREF="#basic_stringstream__basic_stringstream">basic_stringstream</A></B>(
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    explicit <B><A HREF="#basic_stringstream__basic_stringstream">basic_stringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_stringstream__rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_stringstream__str">str</A></B>();
    void <B><A HREF="#basic_stringstream__str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
    };</PRE>

<P>The template class describes an object that controls
insertion and extraction of elements and encoded objects using a
<A HREF="streambu.html#stream_buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character_traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_stringstream__allocator_type"></A><CODE>basic_stringstream::allocator_type</CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_stringstream__basic_stringstream"></A><CODE>basic_stringstream::basic_stringstream</CODE></H3>

<PRE>explicit <B>basic_stringstream</B>(
    ios_base::openmode mode =
        ios_base::in | ios_base::out);
explicit <B>basic_stringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode =
         ios_base::in | ios_base::out);</PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="istream.html#basic_iostream">basic_iostream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_iostream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf__basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode)</CODE>.</P>

<H3><A NAME="basic_stringstream__rdbuf"></A><CODE>basic_stringstream::rdbuf</CODE></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_stringstream__str"></A><CODE>basic_stringstream::str</CODE></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_stringstream__rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf__str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H2><A NAME="istringstream"></A><CODE>istringstream</CODE></H2>

<PRE>typedef basic_istringstream&lt;char&gt; <B>istringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istringstream"><CODE>basic_istringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="ostringstream"></A><CODE>ostringstream</CODE></H2>

<PRE>typedef basic_ostringstream&lt;char&gt; <B>ostringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_ostringstream"><CODE>basic_ostringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="stringbuf"></A><CODE>stringbuf</CODE></H2>

<PRE>typedef basic_stringbuf&lt;char&gt; <B>stringbuf</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringbuf"><CODE>basic_stringbuf</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="stringstream"></A><CODE>stringstream</CODE></H2>

<PRE>typedef basic_stringstream&lt;char&gt; <B>stringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringstream"><CODE>basic_stringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="swap"></A><CODE>swap</CODE></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    void <B>swap</B>(basic_stringbuf&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_stringbuf&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B>swap</B>(basic_istringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_istringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B>swap</B>(basic_ostringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_ostringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B>swap</B>(basic_stringstream&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_stringstream&lt;Elem, Tr, Alloc&gt;&amp; right); <B>[added with C++11]</B></PRE>

<P>The template function executes
<CODE>left.swap(right)</CODE>.</P>

<H2><A NAME="wistringstream"></A><CODE>wistringstream</CODE></H2>

<PRE>typedef basic_istringstream&lt;wchar_t&gt; <B>wistringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istringstream"><CODE>basic_istringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wostringstream"></A><CODE>wostringstream</CODE></H2>

<PRE>typedef basic_ostringstream&lt;wchar_t&gt; <B>wostringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_ostringstream"><CODE>basic_ostringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wstringbuf"></A><CODE>wstringbuf</CODE></H2>

<PRE>typedef basic_stringbuf&lt;wchar_t&gt; <B>wstringbuf</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringbuf"><CODE>basic_stringbuf</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wstringstream"></A><CODE>wstringstream</CODE></H2>

<PRE>typedef basic_stringstream&lt;wchar_t&gt; <B>wstringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringstream"><CODE>basic_stringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
