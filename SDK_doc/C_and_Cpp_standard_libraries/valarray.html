<HTML><HEAD>
<TITLE>&lt;valarray&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;valarray&gt;"></A><CODE>&lt;valarray&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#gslice">gslice</A>
&middot; <A HREF="#gslice_array">gslice_array</A>
&middot; <A HREF="#indirect_array">indirect_array</A>
&middot; <A HREF="#mask_array">mask_array</A>
&middot; <A HREF="#slice">slice</A>
&middot; <A HREF="#slice_array">slice_array</A>
&middot; <A HREF="#valarray">valarray</A>
&middot; <A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abs">abs</A>
&middot; <A HREF="#acos">acos</A>
&middot; <A HREF="#asin">asin</A>
&middot; <A HREF="#atan">atan</A>
&middot; <A HREF="#atan2">atan2</A>
&middot; <A HREF="#begin">begin</A>
&middot; <A HREF="#cos">cos</A>
&middot; <A HREF="#cosh">cosh</A>
&middot; <A HREF="#end">end</A>
&middot; <A HREF="#exp">exp</A>
&middot; <A HREF="#log">log</A>
&middot; <A HREF="#log10">log10</A>
&middot; <A HREF="#operator!2">operator!=</A>
&middot; <A HREF="#operator%">operator%</A>
&middot; <A HREF="#operator&amp;">operator&amp;</A>
&middot; <A HREF="#operator&amp;&amp;">operator&amp;&amp;</A>
&middot; <A HREF="#operator&gt;">operator&gt;</A>
&middot; <A HREF="#operator&gt;&gt;">operator&gt;&gt;</A>
&middot; <A HREF="#operator&gt;2">operator&gt;=</A>
&middot; <A HREF="#operator&lt;">operator&lt;</A>
&middot; <A HREF="#operator&lt;&lt;">operator&lt;&lt;</A>
&middot; <A HREF="#operator&lt;2">operator&lt;=</A>
&middot; <A HREF="#operator*">operator*</A>
&middot; <A HREF="#operator+">operator+</A>
&middot; <A HREF="#operator-">operator-</A>
&middot; <A HREF="#operator_slash">operator/</A>
&middot; <A HREF="#operator22">operator==</A>
&middot; <A HREF="#operator^">operator^</A>
&middot; <A HREF="#operator|">operator|</A>
&middot; <A HREF="#operator||">operator||</A>
&middot; <A HREF="#pow">pow</A>
&middot; <A HREF="#sin">sin</A>
&middot; <A HREF="#sinh">sinh</A>
&middot; <A HREF="#sqrt">sqrt</A>
&middot; <A HREF="#swap">swap</A>
&middot; <A HREF="#tan">tan</A>
&middot; <A HREF="#tanh">tanh</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;valarray&gt;</CODE></B>
to define the template class
<CODE><A HREF="#valarray">valarray</A></CODE> and numerous
supporting template classes and functions. These template classes and functions
are permitted unusual latitude, in the interest of improved performance.
Specifically, any function described here as
returning <CODE>valarray&lt;Ty&gt;</CODE> may actually return
an object of some other type <CODE>Other</CODE>. In that case, any other
function described here that
accepts one or more arguments of type <CODE>valarray&lt;Ty&gt;</CODE> must have
overloads that accept arbitrary combinations of those arguments,
each replaced with an argument of type <CODE>Other</CODE>. (Put simply,
the only way you can detect such a substitution is to go looking for it.)</P>

<PRE>namespace std {
class <B><A HREF="#slice">slice</A></B>;
class <B><A HREF="#gslice">gslice</A></B>;

        // TEMPLATE CLASSES
template&lt;class Ty&gt;
    class <B><A HREF="#valarray">valarray</A></B>;
template&lt;class Ty&gt;
    class <B><A HREF="#slice_array">slice_array</A></B>;
template&lt;class Ty&gt;
    class <B><A HREF="#gslice_array">gslice_array</A></B>;
template&lt;class Ty&gt;
    class <B><A HREF="#mask_array">mask_array</A></B>;
template&lt;class Ty&gt;
    class <B><A HREF="#indirect_array">indirect_array</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty&gt;
    void <B><A HREF="#swap">swap</A></B>(valarray&lt;Ty&gt;&amp; left,
        valarray&lt;Ty&gt;&amp; right); <B>[added with C++11]</B>

template&lt;class Ty&gt;
    Ty *<B><A HREF="#begin">begin</A></B>(valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    const Ty *<B><A HREF="#begin">begin</A></B>(const valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    Ty *<B><A HREF="#end">end</A></B>(valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    const Ty *<B><A HREF="#end">end</A></B>(const valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator*">operator*</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator*">operator*</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator*">operator*</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator_slash">operator/</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator_slash">operator/</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator_slash">operator/</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator%">operator%</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const vararray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator%">operator%</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator%">operator%</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator+">operator+</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator+">operator+</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator+">operator+</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator-">operator-</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator-">operator-</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator-">operator-</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator^">operator^</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator^">operator^</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator^">operator^</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&amp;">operator&amp;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&amp;">operator&amp;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&amp;">operator&amp;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator|">operator|</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator|">operator|</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator|">operator|</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&amp;&amp;">operator&amp;&amp;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&amp;&amp;">operator&amp;&amp;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&amp;&amp;">operator&amp;&amp;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator||">operator||</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator||">operator||</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator||">operator||</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator22">operator==</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator22">operator==</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator22">operator==</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator!2">operator!=</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator!2">operator!=</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator!2">operator!=</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;">operator&lt;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;">operator&lt;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;">operator&lt;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;">operator&gt;</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;">operator&gt;</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&gt;">operator&gt;</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);

template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#abs">abs</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#acos">acos</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#asin">asin</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#atan">atan</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#atan2">atan2</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#atan2">atan2</A></B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#atan2">atan2</A></B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#cos">cos</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#cosh">cosh</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#exp">exp</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#log">log</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#log10">log10</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#pow">pow</A></B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#pow">pow</A></B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#pow">pow</A></B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#sin">sin</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#sinh">sinh</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#sqrt">sqrt</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#tan">tan</A></B>(const valarray&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B><A HREF="#tanh">tanh</A></B>(const valarray&lt;Ty&gt;&amp; left);
}  // namespace std</PRE>

<H2><A NAME="abs"></A><CODE>abs</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>abs</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the absolute value of <CODE>left[I]</CODE>.</P>

<H2><A NAME="acos"></A><CODE>acos</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>acos</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the arccosine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="asin"></A><CODE>asin</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>asin</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the arcsine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="atan"></A><CODE>atan</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>atan</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the arctangent of <CODE>left[I]</CODE>.</P>

<H2><A NAME="atan2"></A><CODE>atan2</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>atan2</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>atan2</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>atan2</B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the arctangent of <CODE>left[I] / right[I]</CODE>.
The second template function stores in element <CODE>I</CODE>
the arctangent of <CODE>left[I] / right</CODE>.
The third template function stores in element <CODE>I</CODE>
the arctangent of <CODE>left / right[I]</CODE>.</P>

<H2><A NAME="begin"></A><CODE>begin</CODE></H2>

<PRE>template&lt;class Ty&gt;
    Ty *<B>begin</B>(valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    const Ty *<B>begin</B>(const valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B></PRE>

<P>The function returns <CODE>&amp;array[0]</CODE>.</P>

<H2><A NAME="cos"></A><CODE>cos</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>cos</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the cosine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="cosh"></A><CODE>cosh</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>cosh</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the hyperbolic cosine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="end"></A><CODE>end</CODE></H2>

<PRE>template&lt;class Ty&gt;
    Ty *<B>end</B>(valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B>
template&lt;class Ty&gt;
    const Ty *<B>end</B>(const valarray&lt;Ty&gt;&amp; array); <B>[added with C++11]</B></PRE>

<P>The function returns <CODE>&amp;array[array.size()]</CODE>.</P>

<H2><A NAME="exp"></A><CODE>exp</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>exp</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the exponential of <CODE>left[I]</CODE>.</P>

<H2><A NAME="gslice"></A><CODE>gslice</CODE></H2>

<PRE>class <B>gslice</B> {
public:
    <B><A HREF="#gslice__gslice">gslice</A></B>();
    <B><A HREF="#gslice__gslice">gslice</A></B>(size_t off,
        const valarray&lt;size_t&gt; lenarr,
        const valarray&lt;size_t&gt; incarr);
    size_t <B><A HREF="#gslice__start">start</A></B>() const;
    const valarray&lt;size_t&gt; <B><A HREF="#gslice__size">size</A></B>() const;
    const valarray&lt;size_t&gt; <B><A HREF="#gslice__stride">stride</A></B>() const;
    };</PRE>

<P>The class stores the parameters that characterize a
<CODE><A HREF="#gslice_array">gslice_array</A></CODE> when an
object of class <CODE>gslice</CODE> appears as a subscript
for an object of class
<CODE><A HREF="#valarray__operator[]">valarray</A>&lt;Ty&gt;</CODE>.
The stored values include:</P>

<UL>
<LI>a <B>starting index</B></LI>

<LI>a <B>length vector</B> of class <CODE>valarray&lt;size_t&gt;</CODE></LI>

<LI>a <B>stride vector</B> of class <CODE>valarray&lt;size_t&gt;</CODE></LI>
</UL>

<P>The two vectors must have the same length.</P>

<H3><A NAME="gslice__gslice"></A><CODE>gslice::gslice</CODE></H3>

<PRE><B>gslice</B>();
<B>gslice</B>(size_t off,
    const valarray&lt;size_t&gt; lenarr,
    const valarray&lt;size_t&gt; incarr);</PRE>

<P>The default constructor stores zero for the starting index,
and zero-length vectors for the length and stride vectors.
The second constructor stores <CODE>off</CODE>
for the starting index, <CODE>lenarr</CODE> for the length vector,
and <CODE>incarr</CODE> for the stride vector.</P>

<H3><A NAME="gslice__size"></A><CODE>gslice::size</CODE></H3>

<PRE>const valarray&lt;size_t&gt; <B>size</B>() const;</PRE>

<P>The member function returns the stored length vector.</P>

<H3><A NAME="gslice__start"></A><CODE>gslice::start</CODE></H3>

<PRE>size_t <B>start</B>() const;</PRE>

<P>The member function returns the stored starting index.</P>

<H3><A NAME="gslice__stride"></A><CODE>gslice::stride</CODE></H3>

<PRE>const valarray&lt;size_t&gt; <B>stride</B>() const;</PRE>

<P>The member function returns the stored stride vector.</P>

<H2><A NAME="gslice_array"></A><CODE>gslice_array</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>gslice_array</B> {
public:
    typedef Ty <B><A NAME="gslice_array__value_type"></A>value_type</B>;
    void <B><A NAME="gslice_array__operator2"></A>operator=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator*2"></A>operator*=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator_slash2"></A>operator/=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator%2"></A>operator%=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator+2"></A>operator+=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator-2"></A>operator-=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator^2"></A>operator^=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator&amp;2"></A>operator&amp;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator|2"></A>operator|=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator&lt;&lt;2"></A>operator&lt;&lt;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="gslice_array__operator&gt;&gt;2"></A>operator&gt;&gt;=</B>(const valarray&lt;Ty&gt; right) const;

    <B>gslice_array</B>() = delete; <B>[added with C++11]</B>&nbsp;
    <B>gslice_array</B>(
        const gslice_array&amp;);  // not defined
    gslice_array&amp; <B>operator=</B>(
        const gslice_array&amp;);  // not defined
    const gslice_array&amp; <B>operator=</B>(
        const gslice_array&amp;) const;  // not defined <B>[added with C++11]</B>
    };</PRE>

<P>The class describes an object that
stores a reference to an object <CODE>va</CODE> of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
along with an object <CODE>gs</CODE> of class
<CODE><A HREF="#gslice">gslice</A></CODE> which
describes the sequence of elements to select from the
<CODE>valarray&lt;Ty&gt;</CODE> object.</P>

<P>You construct a <CODE>gslice_array&lt;Ty&gt;</CODE> object only
by writing an expression of the form
<CODE><A HREF="#valarray__operator[]">va[gs]</A></CODE>.
The member functions of class <CODE>gslice_array</CODE> then
behave like the corresponding function signatures defined
for <CODE>valarray&lt;Ty&gt;</CODE>, except that only the sequence
of selected elements is affected.</P>

<P>The sequence is determined as follows. For a length vector
<CODE>gs.<A HREF="#gslice__size">size</A>()</CODE>
of length <CODE>N</CODE>, construct the index
vector <CODE>valarray&lt;size_t&gt; idx(0, N)</CODE>. This
designates the initial element of the sequence, whose index
<CODE>K</CODE> within <CODE>va</CODE> is given by the mapping:</P>

<PRE>K = gs.start();
for (size_t I = 0; I &lt; N; ++I)
    K += idx[I] * gs.stride()[I];</PRE>

<P>The successor to an index vector value is given by:</P>

<PRE>for (size_t I = N; 0 &lt; I--; )
    if (++idx[I] &lt; gs.size()[I])
        break;
    else
        idx[I] = 0;</PRE>

<P>For example:</P>

<PRE>const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
// va[gslice(3, len, str)] selects elements with
//   indices 3, 5, 7, 10, 12, 14</PRE>

<H2><A NAME="indirect_array"></A><CODE>indirect_array</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>indirect_array</B> {
public:
    typedef Ty <B><A NAME="indirect_array__value_type"></A>value_type</B>;
    void <B><A NAME="indirect_array__operator2"></A>operator=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator*2"></A>operator*=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator_slash2"></A>operator/=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator%2"></A>operator%=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator+2"></A>operator+=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator-2"></A>operator-=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator^2"></A>operator^=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator&amp;2"></A>operator&amp;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator|2"></A>operator|=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator&lt;&lt;2"></A>operator&lt;&lt;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="indirect_array__operator&gt;&gt;2"></A>operator&gt;&gt;=</B>(const valarray&lt;Ty&gt; right) const;

    <B>indirect_array</B>() = delete; <B>[added with C++11]</B>&nbsp;
    <B>indirect_array</B>(
        const indirect_array&amp;);  // not defined
    indirect_array&amp; <B>operator=</B>(
        const indirect_array&amp;);  // not defined
    const indirect_array&amp; <B>operator=</B>(
        const indirect_array&amp;) const;  // not defined <B>[added with C++11]</B>
    };</PRE>

<P>The class describes an object that
stores a reference to an object <CODE>va</CODE> of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
along with an object <CODE>xa</CODE> of class
<CODE>valarray&lt;size_t&gt;</CODE> which
describes the sequence of elements to select from the
<CODE>valarray&lt;Ty&gt;</CODE> object.</P>

<P>You construct an <CODE>indirect_array&lt;Ty&gt;</CODE> object only
by writing an expression of the form
<CODE><A HREF="#valarray__operator[]">va[xa]</A></CODE>.
The member functions of class <CODE>indirect_array</CODE> then
behave like the corresponding function signatures defined
for <CODE>valarray&lt;Ty&gt;</CODE>, except that only the sequence
of selected elements is affected.</P>

<P>The sequence consists of
<CODE>xa.<A HREF="#valarray__size">size</A>()</CODE>
elements, where element <CODE>I</CODE> becomes the index
<CODE>xa[I]</CODE> within <CODE>va</CODE>. For example:</P>

<PRE>const size_t vi[] = {7, 5, 2, 3, 8};
// va[valarray&lt;size_t&gt;(vi, 5)] selects elements with
//   indices 7, 5, 2, 3, 8</PRE>

<H2><A NAME="log"></A><CODE>log</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>log</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the natural logarithm of <CODE>left[I]</CODE>.</P>

<H2><A NAME="log10"></A><CODE>log10</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>log10</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the base-10 logarithm of <CODE>left[I]</CODE>.</P>

<H2><A NAME="mask_array"></A><CODE>mask_array</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>mask_array</B> {
public:
    typedef Ty <B><A NAME="mask_array__value_type"></A>value_type</B>;
    void <B><A NAME="mask_array__operator2"></A>operator=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator*2"></A>operator*=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator_slash2"></A>operator/=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator%2"></A>operator%=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator+2"></A>operator+=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator-2"></A>operator-=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator^2"></A>operator^=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator&amp;2"></A>operator&amp;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator|2"></A>operator|=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator&lt;&lt;2"></A>operator&lt;&lt;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="mask_array__operator&gt;&gt;2"></A>operator&gt;&gt;=</B>(const valarray&lt;Ty&gt; right) const;

    <B>mask_array</B>() = delete; <B>[added with C++11]</B>&nbsp;
    <B>mask_array</B>(
        const mask_array&amp;);  // not defined
    mask_array&amp; <B>operator=</B>(
        const mask_array&amp;);  // not defined
    const mask_array&amp; <B>operator=</B>(
        const mask_array&amp;) const;  // not defined <B>[added with C++11]</B>
    };</PRE>

<P>The class describes an object that
stores a reference to an object <CODE>va</CODE> of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
along with an object <CODE>ba</CODE> of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE> which
describes the sequence of elements to select from the
<CODE>valarray&lt;Ty&gt;</CODE> object.</P>

<P>You construct a <CODE>mask_array&lt;Ty&gt;</CODE> object only
by writing an expression of the form
<CODE><A HREF="#valarray__operator[]">va[ba]</A></CODE>.
The member functions of class <CODE>mask_array</CODE> then
behave like the corresponding function signatures defined
for <CODE>valarray&lt;Ty&gt;</CODE>, except that only the sequence
of selected elements is affected.</P>

<P>The sequence consists of at most
<CODE>ba.<A HREF="#valarray__size">size</A>()</CODE>
elements. An element <CODE>J</CODE> is included only if <CODE>ba[J]</CODE>
is true. Thus, there are as many elements in the sequence as there are
true elements in <CODE>ba</CODE>.
If <CODE>I</CODE> is the index of the lowest true element
in <CODE>ba</CODE>, then <CODE>va[I]</CODE> is element zero in the
selected sequence. For example:</P>

<PRE>const bool vb[] = {false, false, true, true, false, true};
// va[valarray&lt;bool&gt;(vb, 56] selects elements with
//   indices 2, 3, 5</PRE>

<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator!=</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator!=</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator!=</B>(const Ty&amp; left,
       const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] != right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] != right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left != right[I]</CODE>.</P>

<H2><A NAME="operator%"></A><CODE>operator%</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator%</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator%</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator%</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] % right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] % right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left % right[I]</CODE>.</P>

<H2><A NAME="operator&amp;"></A><CODE>operator&amp;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&amp;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&amp;</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&amp;</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &amp; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &amp; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &amp; right[I]</CODE>.</P>

<H2><A NAME="operator&amp;&amp;"></A><CODE>operator&amp;&amp;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&amp;&amp;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&amp;&amp;</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&amp;&amp;</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;bool&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &amp;&amp; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &amp;&amp; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &amp;&amp; right[I]</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &gt; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &gt; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &gt; right[I]</CODE>.</P>

<H2><A NAME="operator&gt;&gt;"></A><CODE>operator&gt;&gt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&gt;&gt;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&gt;&gt;</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&gt;&gt;</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &gt;&gt; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &gt;&gt; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &gt;&gt; right[I]</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;=</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;=</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&gt;=</B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &gt;= right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &gt;= right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &gt;= right[I]</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;</B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &lt; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &lt; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &lt; right[I]</CODE>.</P>

<H2><A NAME="operator&lt;&lt;"></A><CODE>operator&lt;&lt;</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&lt;&lt;</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&lt;&lt;</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator&lt;&lt;</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &lt;&lt; right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &lt;&lt; right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &lt;&lt; right[I]</CODE>.</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;=</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;=</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator&lt;=</B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator retrrns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] &lt;= right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] &lt;= right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left &lt;= right[I]</CODE>.</P>

<H2><A NAME="operator*"></A><CODE>operator*</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator*</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator*</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator*</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] * right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] * right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left * right[I]</CODE>.</P>

<H2><A NAME="operator+"></A><CODE>operator+</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator+</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator+</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator+</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] + right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] + right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left + right[I]</CODE>.</P>

<H2><A NAME="operator-"></A><CODE>operator-</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator-</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator-</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator-</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] - right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] - right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left - right[I]</CODE>.</P>

<H2><A NAME="operator_slash"></A><CODE>operator/</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator/</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator/</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator/</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] / right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] / right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left / right[I]</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator==</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator==</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator==</B>(const Ty&amp; left  const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray&lt;bool&gt;">valarray&lt;bool&gt;</A></CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] == right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] == right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left == right[I]</CODE>.</P>

<H2><A NAME="operator^"></A><CODE>operator^</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator^</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator^</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator^</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] ^ right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] ^ right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left ^ right[I]</CODE>.</P>

<H2><A NAME="operator|"></A><CODE>operator|</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator|</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator|</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>operator|</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] | right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] | right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left | right[I]</CODE>.</P>

<H2><A NAME="operator||"></A><CODE>operator||</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator||</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator||</B>(const valarray&lt;Ty&gt; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;bool&gt; <B>operator||</B>(const Ty&amp; left,
        const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;bool&gt;</CODE>,
each of whose
elements <CODE>I</CODE> is <CODE>left[I] || right[I]</CODE>.
The second template operator stores in element <CODE>I</CODE>
<CODE>left[I] || right</CODE>.
The third template operator stores in element <CODE>I</CODE>
<CODE>left || right[I]</CODE>.</P>

<H2><A NAME="pow"></A><CODE>pow</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>pow</B>(const valarray&lt;Ty&gt;&amp; left,
        const valarray&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>pow</B>(const valarray&lt;Ty&gt; left, const Ty&amp; right);
template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>pow</B>(const Ty&amp; left, const valarray&lt;Ty&gt;&amp; right);</PRE>

<P>The first template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>left[I]</CODE> raised to the
<CODE>right[I]</CODE> power.
The second template function stores in element <CODE>I</CODE>
<CODE>left[I]</CODE> raised to the <CODE>right</CODE> power.
The third template function stores in element <CODE>I</CODE>
<CODE>left</CODE> raised to the <CODE>right[I]</CODE> power.</P>

<H2><A NAME="sin"></A><CODE>sin</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>sin</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the sine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="sinh"></A><CODE>sinh</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>sinh</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the hyperbolic sine of <CODE>left[I]</CODE>.</P>

<H2><A NAME="slice"></A><CODE>slice</CODE></H2>

<PRE>class <B>slice</B> {
public:
    <B><A HREF="#slice__slice">slice</A></B>();
    <B><A HREF="#slice__slice">slice</A></B>(size_t st, size_t len, size_t str);
    size_t <B><A HREF="#slice__start">start</A></B>() const;
    size_t <B><A HREF="#slice__size">size</A></B>() const;
    size_t <B><A HREF="#slice__stride">stride</A></B>() const;
    };</PRE>

<P>The class stores the parameters that characterize a
<CODE><A HREF="#slice_array">slice_array</A></CODE> when an
object of class <CODE>slice</CODE> appears as a subscript
for an object of class
<CODE><A HREF="#valarray__operator[]">valarray</A>&lt;Ty&gt;</CODE>.
The stored values include:</P>

<UL>
<LI>a <B>starting index</B></LI>

<LI>a <B>total length</B></LI>

<LI>a <B>stride</B>, or distance between subsequent indices</LI>
</UL>

<H3><A NAME="slice__slice"></A><CODE>slice::slice</CODE></H3>

<PRE><B>slice</B>();
<B>slice</B>(size_t st,
        const valarray&lt;size_t&gt; len, const valarray&lt;size_t&gt; str);</PRE>

<P>The default constructor stores zeros for the starting index,
total length, and stride. The second constructor stores <CODE>st</CODE>
for the starting index, <CODE>len</CODE> for the total length,
and <CODE>str</CODE> for the stride.</P>

<H3><A NAME="slice__size"></A><CODE>slice::size</CODE></H3>

<PRE>size_t <B>size</B>() const;</PRE>

<P>The member function returns the stored total length.</P>

<H3><A NAME="slice__start"></A><CODE>slice::start</CODE></H3>

<PRE>size_t <B>start</B>() const;</PRE>

<P>The member function returns the stored starting index.</P>

<H3><A NAME="slice__stride"></A><CODE>slice::stride</CODE></H3>

<PRE>size_t <B>stride</B>() const;</PRE>

<P>The member function returns the stored stride.</P>

<H2><A NAME="slice_array"></A><CODE>slice_array</CODE></H2>

<PRE>template&lt;class Ty&gt;
    class <B>slice_array</B> {
public:
    typedef Ty <B><A NAME="slice_array__value_type"></A>value_type</B>;
    void <B><A NAME="slice_array__operator2"></A>operator=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator*2"></A>operator*=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator_slash2"></A>operator/=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator%2"></A>operator%=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator+2"></A>operator+=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator-2"></A>operator-=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator^2"></A>operator^=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator&amp;2"></A>operator&amp;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator|2"></A>operator|=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator&lt;&lt;2"></A>operator&lt;&lt;=</B>(const valarray&lt;Ty&gt; right) const;
    void <B><A NAME="slice_array__operator&gt;&gt;2"></A>operator&gt;&gt;=</B>(const valarray&lt;Ty&gt; right) const;

    <B>slice_array</B>() = delete; <B>[added with C++11]</B>&nbsp;
    <B>slice_array</B>(
        const slice_array&amp;);  // not defined
    slice_array&amp; <B>operator=</B>(
        const slice_array&amp;);  // not defined
    const slice_array&amp; <B>operator=</B>(
        const slice_array&amp;) const;  // not defined <B>[added with C++11]</B>
    };</PRE>

<P>The class describes an object that
stores a reference to an object <CODE>va</CODE> of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>,
along with an object <CODE>sl</CODE> of class
<CODE><A HREF="#slice">slice</A></CODE> which
describes the sequence of elements to select from the
<CODE>valarray&lt;Ty&gt;</CODE> object.</P>

<P>You construct a <CODE>slice_array&lt;Ty&gt;</CODE> object only
by writing an expression of the form
<CODE><A HREF="#valarray__operator[]">va[sl]</A></CODE>.
The member functions of class <CODE>slice_array</CODE> then
behave like the corresponding function signatures defined
for <CODE>valarray&lt;Ty&gt;</CODE>, except that only the sequence
of selected elements is affected.</P>

<P>The sequence consists of
<CODE>sl.<A HREF="#slice__size">size</A>()</CODE>
elements, where element <CODE>I</CODE> becomes the index
<CODE>sl.<A HREF="#slice__start">start</A>() + I *
sl.<A HREF="#slice__stride">stride</A>()</CODE> within <CODE>va</CODE>.
For example:</P>

<PRE>// va[slice(2, 5, 3)] selects elements with
//   indices 2, 5, 8, 11, 14</PRE>

<H2><A NAME="sqrt"></A><CODE>sqrt</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>sqrt</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the square root of <CODE>left[I]</CODE>.</P>

<H2><A NAME="swap"></A><CODE>swap</CODE></H2>

<PRE>template&lt;class Ty&gt;
    void <B>swap</B>(valarray&lt;Ty&gt;&amp; left,
        valarray&lt;Ty&gt;&amp; right); <B>[added with C++11]</B></PRE>

<P>The template function executes
<CODE>left.<A HREF="#valarray__swap">swap</A>(right)</CODE>.</P>

<H2><A NAME="tan"></A><CODE>tan</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>tan</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the tangent of <CODE>left[I]</CODE>.</P>

<H2><A NAME="tanh"></A><CODE>tanh</CODE></H2>

<PRE>template&lt;class Ty&gt;
    valarray&lt;Ty&gt; <B>tanh</B>(const valarray&lt;Ty&gt;&amp; left);</PRE>

<P>The template function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, each of whose
elements <CODE>I</CODE> is the hyperbolic tangent of <CODE>left[I]</CODE>.</P>

<H2><A NAME="valarray"></A><CODE>valarray</CODE></H2>

<HR>
<P><B><CODE><A HREF="#valarray__apply">apply</A>
&middot; <A HREF="#valarray__cshift">cshift</A>
&middot; <A HREF="#valarray__max">max</A>
&middot; <A HREF="#valarray__min">min</A>
&middot; <A HREF="#valarray__operator!">operator!</A>
&middot; <A HREF="#valarray__operator%2">operator%=</A>
&middot; <A HREF="#valarray__operator&amp;2">operator&amp;=</A>
&middot; <A HREF="#valarray__operator&gt;&gt;2">operator&gt;&gt;=</A>
&middot; <A HREF="#valarray__operator&lt;&lt;2">operator&lt;&lt;=</A>
&middot; <A HREF="#valarray__operator*2">operator*=</A>
&middot; <A HREF="#valarray__operator+">operator+</A>
&middot; <A HREF="#valarray__operator+2">operator+=</A>
&middot; <A HREF="#valarray__operator-">operator-</A>
&middot; <A HREF="#valarray__operator-2">operator-=</A>
&middot; <A HREF="#valarray__operator_slash2">operator/=</A>
&middot; <A HREF="#valarray__operator2">operator=</A>
&middot; <A HREF="#valarray__operator[]">operator[]</A>
&middot; <A HREF="#valarray__operator^2">operator^=</A>
&middot; <A HREF="#valarray__operator|2">operator|=</A>
&middot; <A HREF="#valarray__operator~">operator~</A>
&middot; <A HREF="#valarray__resize">resize</A>
&middot; <A HREF="#valarray__shift">shift</A>
&middot; <A HREF="#valarray__size">size</A>
&middot; <A HREF="#valarray__sum">sum</A>
&middot; <A HREF="#valarray__swap">swap</A>
&middot; <A HREF="#valarray__valarray">valarray</A>
&middot; <A HREF="#valarray__value_type">value_type</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Ty&gt;
    class <B>valarray</B> {
public:
    typedef Ty <B><A HREF="#valarray__value_type">value_type</A></B>;

    <B><A HREF="#valarray__valarray">valarray</A></B>();
    explicit <B><A HREF="#valarray__valarray">valarray</A></B>(size_t count);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const Ty&amp; val, size_t count));
    <B><A HREF="#valarray__valarray">valarray</A></B>(const Ty *ptr, size_t count);
    <B><A HREF="#valarray__valarray">valarray</A></B>(initializer_list&lt;Ty&gt; init); <B>[added with C++11]</B>&nbsp;
    <B><A HREF="#valarray__valarray">valarray</A></B>(const slice_array&lt;Ty&gt;&amp; slicearr);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const gslice_array&lt;Ty&gt;&amp; gslicearr);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const mask_array&lt;Ty&gt;&amp; maskarr);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const indirect_array&lt;Ty&gt;&amp; indarr);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const valarray&lt;Ty&gt;&amp; right);
    <B><A HREF="#valarray__valarray">valarray</A></B>(const valarray&lt;Ty&gt;&amp;&amp; right) noexcept; <B>[added with C++11]</B>

    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const valarray&lt;Ty&gt;&amp;&amp; right) noexcept; <B>[added with C++11]</B>
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const Ty&amp; val);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const slice_array&lt;Ty&gt;&amp; slicearr);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const gslice_array&lt;Ty&gt;&amp; gslicearr);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const mask_array&lt;Ty&gt;&amp; maskarr);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator2">operator=</A></B>(const indirect_array&lt;Ty&gt;&amp; indarr);

    Ty&amp; <B><A HREF="#valarray__operator[]">operator[]</A></B>(size_t off);
    slice_array&lt;Ty&gt; <B><A HREF="#valarray__operator[]">operator[]</A></B>(slice slicearr);
    gslice_array&lt;Ty&gt; <B><A HREF="#valarray__operator[]">operator[]</A></B>(const gslice&amp; gslicearr);
    mask_array&lt;Ty&gt; <B><A HREF="#valarray__operator[]">operator[]</A></B>(const valarray&lt;bool&gt;&amp; boolarr);
    indirect_array&lt;Ty&gt;
        <B><A HREF="#valarray__operator[]">operator[]</A></B>(const valarray&lt;size_t&gt;&amp; indarr);

    Ty&amp; <B><A HREF="#valarray__operator[]">operator[]</A></B>(size_t off) const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__operator[]">operator[]</A></B>(slice slicearr) const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__operator[]">operator[]</A></B>(const gslice&amp; gslicearr) const;
    valarray&lt;Ty&gt;
        <B><A HREF="#valarray__operator[]">operator[]</A></B>(const valarray&lt;bool&gt;&amp; boolarr) const;
    valarray&lt;Ty&gt;
        <B><A HREF="#valarray__operator[]">operator[]</A></B>(const valarray&lt;size_t&gt;&amp; indarr) const;

    valarray&lt;Ty&gt; <B><A HREF="#valarray__operator+">operator+</A></B>() const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__operator-">operator-</A></B>() const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__operator~">operator~</A></B>() const;
    valarray&lt;bool&gt; <B><A HREF="#valarray__operator!">operator!</A></B>() const;
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator*2">operator*=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator*2">operator*=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator_slash2">operator/=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator_slash2">operator/=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator%2">operator%=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator%2">operator%=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator+2">operator+=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator+2">operator+=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator-2">operator-=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator-2">operator-=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator^2">operator^=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator^2">operator^=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&amp;2">operator&amp;=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&amp;2">operator&amp;=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator|2">operator|=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator|2">operator|=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&lt;&lt;2">operator&lt;&lt;=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&lt;&lt;2">operator&lt;&lt;=</A></B>(const Ty&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&gt;&gt;2">operator&gt;&gt;=</A></B>(const valarray&lt;Ty&gt;&amp; right);
    valarray&lt;Ty&gt;&amp; <B><A HREF="#valarray__operator&gt;&gt;2">operator&gt;&gt;=</A></B>(const Ty&amp; right);

    size_t <B><A HREF="#valarray__size">size</A></B>() const;
    Ty <B><A HREF="#valarray__sum">sum</A></B>() const;
    Ty <B><A HREF="#valarray__max">max</A></B>() const;
    Ty <B><A HREF="#valarray__min">min</A></B>() const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__shift">shift</A></B>(int count) const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__cshift">cshift</A></B>(int count) const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__apply">apply</A></B>(Ty func(Ty)) const;
    valarray&lt;Ty&gt; <B><A HREF="#valarray__apply">apply</A></B>(Ty func(const Ty&amp;)) const;
    void <B><A HREF="#valarray__resize">resize</A></B>(size_t newsize);
    void <B><A HREF="#valarray__resize">resize</A></B>(size_t newsize, const Ty&amp; val);

    void <B><A HREF="#valarray__swap">swap</A></B>(valarray&amp; right) noexcept; <B>[added with C++11]</B>
   };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type <CODE>Ty</CODE>.
The sequence is stored as an array of <CODE>Ty</CODE>.
It differs from template class
<CODE><A HREF="vector.html#vector">vector</A></CODE> in two important
ways:</P>

<UL>
<LI>It defines numerous arithmetic operations between corresponding
elements of <CODE>valarray&lt;Ty&gt;</CODE> objects of the same
type and length, such as <CODE>xarr = cos(yarr) + sin(zarr)</CODE>.</LI>

<LI>It defines a variety of interesting ways to subscript a
<CODE>valarray&lt;Ty&gt;</CODE> object, by overloading
<CODE><A HREF="#valarray__operator[]">operator[]</A></CODE>.</LI>
</UL>

<P>An object of class <CODE>Ty</CODE>:</P>

<UL>
<LI>has a public default constructor and destructor -- with
conventional behavior</LI>

<LI>has a public copy constructor, move constructor, and/or
assignment operator, as needed -- with
conventional behavior</LI>

<LI>defines the arithmetic operators and math functions, as needed,
that are defined for the floating-point
types -- with conventional behavior</LI>
</UL>

<P>In particular, no subtle differences may exist between copy or
move construction and default construction followed by assignment.
And none of the operations
on objects of class <CODE>Ty</CODE> may throw exceptions.</P>

<H3><A NAME="valarray__apply"></A><CODE>valarray::apply</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>apply</B>(Ty func(Ty)) const;
valarray&lt;Ty&gt; <B>apply</B>(Ty func(const Ty&amp;)) const;</PRE>

<P>The member function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>func((*this)[I])</CODE>.</P>

<H3><A NAME="valarray__cshift"></A><CODE>valarray::cshift</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>cshift</B>(int count) const;</PRE>

<P>The member function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>(*this)[(I + count) % size()]</CODE>.
Thus, if element zero is taken as the leftmost element, a positive
value of <CODE>count</CODE> shifts the elements circularly left <CODE>count</CODE>
places.</P>

<H3><A NAME="valarray__max"></A><CODE>valarray::max</CODE></H3>

<PRE>Ty <B>max</B>() const;</PRE>

<P>The member function returns the value of the largest element
of <CODE>*this</CODE>, which must have nonzero length.
If the length is greater than one, it compares values
by applying <CODE>operator&lt;</CODE>
between pairs of corresponding elements of class <CODE>Ty</CODE>.</P>

<H3><A NAME="valarray__min"></A><CODE>valarray::min</CODE></H3>

<PRE>Ty <B>min</B>() const;</PRE>

<P>The member function returns the value of the smallest element
of <CODE>*this</CODE>, which must have nonzero length.
If the length is greater than one, it compares values
by applying <CODE>operator&lt;</CODE>
between pairs of elements of class <CODE>Ty</CODE>.</P>

<H3><A NAME="valarray__operator!"></A><CODE>valarray::operator!</CODE></H3>

<PRE>valarray&lt;bool&gt; <B>operator!</B>() const;</PRE>

<P>The member operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;bool&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>!(*this)</CODE>.</P>

<H3><A NAME="valarray__operator%2"></A><CODE>valarray::operator%=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator%=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator%=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] % right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator&amp;2"></A><CODE>valarray::operator&amp;=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator&amp;=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator&amp;=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] &amp; right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator&gt;&gt;2"></A><CODE>valarray::operator&gt;&gt;=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator&gt;&gt;=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator&gt;&gt;=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] &gt;&gt; right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator&lt;&lt;2"></A><CODE>valarray::operator&lt;&lt;=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator&lt;&lt;=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator&lt;&lt;=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] &lt;&lt; right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator*2"></A><CODE>valarray::operator*=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator*=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator*=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] * right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator+"></A><CODE>valarray::operator+</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>operator+</B>() const;</PRE>

<P>The member operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>(*this)[I]</CODE>.</P>

<H3><A NAME="valarray__operator+2"></A><CODE>valarray::operator+=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator+=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator+=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] + right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator-"></A><CODE>valarray::operator-</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>operator-</B>() const;</PRE>

<P>The member operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>-(*this)[I]</CODE>.</P>

<H3><A NAME="valarray__operator-2"></A><CODE>valarray::operator-=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator-=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator-=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] - right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator_slash2"></A><CODE>valarray::operator/=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator/=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator/=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] / right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator2"></A><CODE>valarray::operator=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator=</B>(valarray&lt;Ty&gt;&amp;&amp; right) noexcept; <B>[added with C++11]</B>
valarray&lt;Ty&gt;&amp; <B>operator=</B>(const Ty&amp; val);
valarray&lt;Ty&gt;&amp; <B>operator=</B>(initializer_list&lt;Ty&gt; init) <B>[added with C++11]</B>
valarray&lt;Ty&gt;&amp; <B>operator=</B>(const slice_array&lt;Ty&gt;&amp; slicearr);
valarray&lt;Ty&gt;&amp; <B>operator=</B>(const gslice_array&lt;Ty&gt;&amp; gslicearr);
valarray&lt;Ty&gt;&amp; <B>operator=</B>(const mask_array&lt;Ty&gt;&amp; maskarr);
valarray&lt;Ty&gt;&amp; <B>operator=</B>(const indirect_array&lt;Ty&gt;&amp; indarr);</PRE>

<P>The first member operator replaces the controlled sequence with
a copy of the sequence controlled by <CODE>right</CODE>.
The second member operator is the same as the first, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>The third member operator replaces each element of the controlled
sequence with a copy of <CODE>val</CODE>.
The fourth member operator replaces the controlled sequence
from an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>The remaining member operators replace those elements of the controlled
sequence selected by their arguments, which are generated only by
<CODE><A HREF="#valarray__operator[]">operator[]</A></CODE>.
If the value of a member in the replacement controlled sequence
depends on a member in the initial controlled sequence, the result
is undefined.</P>

<P>If the length of the controlled sequence changes, the result is
undefined.</P>

<H3><A NAME="valarray__operator[]"></A><CODE>valarray::operator[]</CODE></H3>

<PRE>Ty&amp; <B>operator[]</B>(size_t off);
slice_array&lt;Ty&gt; <B>operator[]</B>(slice slicearr);
gslice_array&lt;Ty&gt; <B>operator[]</B>(const gslice&amp; gslicearr);
mask_array&lt;Ty&gt; <B>operator[]</B>(const valarray&lt;bool&gt;&amp; boolarr);
indirect_array&lt;Ty&gt; <B>operator[]</B>(const valarray&lt;size_t&gt;&amp; indarr);

Ty&amp; <B>operator[]</B>(size_t off) const;
valarray&lt;Ty&gt; <B>operator[]</B>(slice slicearr) const;
valarray&lt;Ty&gt; <B>operator[]</B>(const gslice&amp; gslicearr) const;
valarray&lt;Ty&gt; <B>operator[]</B>(const valarray&lt;bool&gt;&amp; boolarr) const;
valarray&lt;Ty&gt; <B>operator[]</B>(const valarray&lt;size_t&gt;&amp; indarr) const;</PRE>

<P>The member operator is overloaded to provide several ways to select
sequences of elements from among those controlled by <CODE>*this</CODE>.
The first group of five member operators work in conjunction with
various overloads of
<CODE><A HREF="#valarray__operator2">operator=</A></CODE>
(and other assigning operators) to allow selective replacement
(slicing) of the controlled sequence. The selected elements must
exist.</P>

<P>The first member operator selects element <CODE>off</CODE>.
For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
v0[3] = 'A';
// v0 == valarray&lt;char&gt;("abcAefghijklmnop", 16)</PRE>

<P>The second member operator selects those elements of the controlled
sequence designated by <CODE>slicearr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16)</PRE>

<P>The third member operator selects those elements of the controlled
sequence designated by <CODE>gslicearr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDEF", 6);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)</PRE>

<P>The fourth member operator selects those elements of the controlled
sequence designated by <CODE>boolarr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABC", 3);
const bool vb[] = {false, false, true, true, false, true};
v0[valarray&lt;bool&gt;(vb, 6)] = v1;
// v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)</PRE>

<P>The fifth member operator selects those elements of the controlled
sequence designated by <CODE>indarr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
const size_t vi[] = {7, 5, 2, 3, 8};
v0[valarray&lt;size_t&gt;(vi, 5)] = v1;
// v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)</PRE>

<P>The second group of five member operators each construct an object
that represents the value(s) selected. The selected elements must
exist.</P>

<P>The sixth member operator returns the value of element <CODE>off</CODE>.
For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[3] returns 'd'</PRE>

<P>The seventh member operator returns an object of class
<CODE>valarray&lt;Ty&gt;</CODE> containing those elements of the controlled
sequence designated by <CODE>slicearr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray&lt;char&gt;("cfilo", 5)</PRE>

<P>The eighth member operator selects those elements of the controlled
sequence designated by <CODE>gslicearr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t lv[] = {2, 3};
const size_t dv[] = {7, 2};
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
//    valarray&lt;char&gt;("dfhkmo", 6)</PRE>

<P>The ninth member operator selects those elements of the controlled
sequence designated by <CODE>boolarr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const bool vb[] = {false, false, true, true, false, true};
// v0[valarray&lt;bool&gt;(vb, 6)] returns
//    valarray&lt;char&gt;("cdf", 3)</PRE>

<P>The last member operator selects those elements of the controlled
sequence designated by <CODE>indarr</CODE>. For example:</P>

<PRE>valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t vi[] = {7, 5, 2, 3, 8};
// v0[valarray&lt;size_t&gt;(vi, 5)] returns
//    valarray&lt;char&gt;("hfcdi", 5)</PRE>

<H3><A NAME="valarray__operator^2"></A><CODE>valarray::operator^=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator^=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator^=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] ^ right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator|2"></A><CODE>valarray::operator|=</CODE></H3>

<PRE>valarray&lt;Ty&gt;&amp; <B>operator|=</B>(const valarray&lt;Ty&gt;&amp; right);
valarray&lt;Ty&gt;&amp; <B>operator|=</B>(const Ty&amp; right);</PRE>

<P>The member operator replaces each element <CODE>I</CODE>
of <CODE>*this</CODE> with <CODE>(*this)[I] | right[I]</CODE>.
It returns <CODE>*this</CODE>.</P>

<H3><A NAME="valarray__operator~"></A><CODE>valarray::operator~</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>operator~</B>() const;</PRE>

<P>The member operator returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is <CODE>~(*this)[I]</CODE>.</P>

<H3><A NAME="valarray__resize"></A><CODE>valarray::resize</CODE></H3>

<PRE>void <B>resize</B>(size_t newsize);
void <B>resize</B>(size_t newsize, const Ty&amp; val);</PRE>

<P>The member functions both ensure that
<CODE><A HREF="#valarray__size">size</A>()</CODE> henceforth
returns <CODE>newsize</CODE>. The first member function initializes all
elements to <CODE>Ty()</CODE>, while the second member function initializes
all elements to <CODE>val</CODE>.
Any pointers or references to
elements in the controlled sequence are invalidated.</P>

<H3><A NAME="valarray__shift"></A><CODE>valarray::shift</CODE></H3>

<PRE>valarray&lt;Ty&gt; <B>shift</B>(int count) const;</PRE>

<P>The member function returns an object of class
<CODE><A HREF="#valarray">valarray</A>&lt;Ty&gt;</CODE>, of length
<CODE><A HREF="#valarray__size">size</A>()</CODE>, each of whose
elements <CODE>I</CODE> is either <CODE>(*this)[I + count]</CODE>,
if <CODE>I + count</CODE> is a valid subscript, or <CODE>Ty()</CODE>.
Thus, if element zero is taken as the leftmost element, a positive
value of <CODE>count</CODE> shifts the elements left <CODE>count</CODE>
places, with zero fill.</P>

<H3><A NAME="valarray__size"></A><CODE>valarray::size</CODE></H3>

<PRE>size_t <B>size</B>() const;</PRE>

<P>The member function returns the number of elements
in the array.</P>

<H3><A NAME="valarray__sum"></A><CODE>valarray::sum</CODE></H3>

<PRE>Ty <B>sum</B>() const;</PRE>

<P>The member function returns the sum of all elements of <CODE>*this</CODE>,
which must have nonzero length. If the length is greater than one,
it adds values to the sum by applying
<CODE>operator+=</CODE> between pairs of elements
of class <CODE>Ty</CODE>.</P>

<H3><CODE><A NAME="valarray__swap"></A>valarray::swap</CODE></H3>

<PRE>void <B>swap</B>(valarray&amp; right) noexcept; <B>[added with C++11]</B></PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>right</CODE>. It does so in constant time,
it throws no exceptions, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.</P>

<H3><A NAME="valarray__valarray"></A><CODE>valarray::valarray</CODE></H3>

<PRE><B>valarray</B>();
explicit <B>valarray</B>(size_t count);
<B>valarray</B>(const Ty&amp; val, size_t count));
<B>valarray</B>(const Ty *ptr, size_t count);
<B>valarray</B>(initializer_list&lt;Ty&gt; init); <B>[added with C++11]</B>&nbsp;
<B>valarray</B>(const slice_array&lt;Ty&gt;&amp; slicearr);
<B>valarray</B>(const gslice_array&lt;Ty&gt;&amp; gslicearr);
<B>valarray</B>(const mask_array&lt;Ty&gt;&amp; maskarr);
<B>valarray</B>(const indirect_array&lt;Ty&gt;&amp; indarr);
<B>valarray</B>(const valarray&lt;Ty&gt;&amp; right);
<B>valarray</B>(valarray&lt;Ty&gt;&amp;&amp; right) noexcept; <B>[added with C++11]</B></PRE>

<P>The first (default) constructor initializes the object to an empty
array. The next three constructors each initialize the object to an array
of <CODE>count</CODE> elements as follows:</P>

<UL>
<LI>For <CODE>explicit valarray(size_t count)</CODE>,
each element is initialized with the default constructor.</LI>

<LI>For <CODE>valarray(const Ty&amp; val, size_t count))</CODE>,
each element is initialized with <CODE>val</CODE>.</LI>

<LI>For <CODE>valarray(const Ty *ptr, size_t count)</CODE>,
the element at position <CODE>I</CODE> is initialized with
<CODE>p[I]</CODE>.</LI>
</UL>

<P>The next constructor specifies the initial controlled sequence
with an object of class
<CODE><B><A HREF="lib_cpp.html#initializer_list">initializer_list</A></B>&lt;Ty&gt;</CODE>.</P>

<P>Each of the remaining constructors initializes the object to a
<CODE>valarray&lt;Ty&gt;</CODE> object determined by the argument.</P>

<P>The last constructor is the same as the next to last, but with an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="valarray__value_type"></A><CODE>valarray::value_type</CODE></H3>

<PRE>typedef Ty <B>value_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>

<H2><A NAME="valarray&lt;bool&gt;"></A><CODE>valarray&lt;bool&gt;</CODE></H2>

<PRE>class <B>valarray</B>&lt;bool&gt;</PRE>

<P>The type is a specialization of template class
<CODE><A HREF="#valarray">valarray</A></CODE>, for elements
of type <CODE>bool</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
