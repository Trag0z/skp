<HTML><HEAD>
<TITLE>&lt;iterator&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;iterator&gt;"></A><CODE>&lt;iterator&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#advance">advance</A>
&middot; <A HREF="#back_insert_iterator">back_insert_iterator</A>
&middot; <A HREF="#back_inserter">back_inserter</A>
&middot; <A HREF="#begin">begin</A>
&middot; <A HREF="#bidirectional_iterator_tag">bidirectional_iterator_tag</A>
&middot; <A HREF="#distance">distance</A>
&middot; <A HREF="#end">end</A>
&middot; <A HREF="#forward_iterator_tag">forward_iterator_tag</A>
&middot; <A HREF="#front_insert_iterator">front_insert_iterator</A>
&middot; <A HREF="#front_inserter">front_inserter</A>
&middot; <A HREF="#input_iterator_tag">input_iterator_tag</A>
&middot; <A HREF="#insert_iterator">insert_iterator</A>
&middot; <A HREF="#inserter">inserter</A>
&middot; <A HREF="#istream_iterator">istream_iterator</A>
&middot; <A HREF="#istreambuf_iterator">istreambuf_iterator</A>
&middot; <A HREF="#iterator">iterator</A>
&middot; <A HREF="#iterator_traits">iterator_traits</A>
&middot; <A HREF="#move_iterator">move_iterator</A>
&middot; <A HREF="#make_move_iterator">make_move_iterator</A>
&middot; <A HREF="#next">next</A>
&middot; <A HREF="#operator!2">operator!=</A>
&middot; <A HREF="#operator22">operator==</A>
&middot; <A HREF="#operator&lt;">operator&lt;</A>
&middot; <A HREF="#operator&lt;2">operator&lt;=</A>
&middot; <A HREF="#operator&gt;">operator&gt;</A>
&middot; <A HREF="#operator&gt;2">operator&gt;=</A>
&middot; <A HREF="#operator+">operator+</A>
&middot; <A HREF="#operator-">operator-</A>
&middot; <A HREF="#ostream_iterator">ostream_iterator</A>
&middot; <A HREF="#ostreambuf_iterator">ostreambuf_iterator</A>
&middot; <A HREF="#output_iterator_tag">output_iterator_tag</A>
&middot; <A HREF="#prev">prev</A>
&middot; <A HREF="#random_access_iterator_tag">random_access_iterator_tag</A>
&middot; <A HREF="#reverse_iterator">reverse_iterator</A>
</CODE></B></P>
<HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;iterator&gt;</CODE></B>
to define a number of classes, template classes, and template
functions that aid in the declaration and manipulation of iterators.</P>

<PRE>namespace std {
struct <B><A HREF="#input_iterator_tag">input_iterator_tag</A></B>;
struct <B><A HREF="#output_iterator_tag">output_iterator_tag</A></B>;
struct <B><A HREF="#forward_iterator_tag">forward_iterator_tag</A></B>;
struct <B><A HREF="#bidirectional_iterator_tag">bidirectional_iterator_tag</A></B>;
struct <B><A HREF="#random_access_iterator_tag">random_access_iterator_tag</A></B>;

        // TEMPLATE CLASSES
template&lt;class Category, class Ty, class Diff,
    class Pointer, class Reference&gt;
    struct <B><A HREF="#iterator">iterator</A></B>;
template&lt;class Iter&gt;
    struct <B><A HREF="#iterator_traits">iterator_traits</A></B>;
template&lt;class Ty&gt;
    struct <B><A HREF="#iterator_traits">iterator_traits</A></B>&lt;Ty *&gt;;
template&lt;class Ty&gt;
    struct <B>iterator_traits</B>&lt;const Ty *&gt;;

template&lt;class Container&gt;
    class <B><A HREF="#back_insert_iterator">back_insert_iterator</A></B>;
template&lt;class Container&gt;
    class <B><A HREF="#front_insert_iterator">front_insert_iterator</A></B>;
template&lt;class Container&gt;
    class <B><A HREF="#insert_iterator">insert_iterator</A></B>;
template&lt;class Container&gt;
    class <B><A HREF="#move_iterator">move_iterator</A></B>;
template&lt;class RanIt&gt;
    class <B><A HREF="#reverse_iterator">reverse_iterator</A></B>;

template&lt;class Ty, class Elem, class Tr, class Diff&gt;
    class <B><A HREF="#istream_iterator">istream_iterator</A></B>;
template&lt;class Ty, class Elem, class Tr&gt;
    class <B><A HREF="#ostream_iterator">ostream_iterator</A></B>;
template&lt;class Elem, class Tr&gt;
    class <B><A HREF="#istreambuf_iterator">istreambuf_iterator</A></B>;
template&lt;class Elem, class Tr&gt;
    class <B><A HREF="#ostreambuf_iterator">ostreambuf_iterator</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr, class Diff&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; left,
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; right);
template&lt;class Elem, class Tr&gt;
    bool <B><A HREF="#operator22">operator==</A></B>(
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; left,
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr, class Diff&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; left,
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; right);
template&lt;class Elem, class Tr&gt;
    bool <B><A HREF="#operator!2">operator!=</A></B>(
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; left,
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&lt;2">operator&lt;=</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B><A HREF="#operator&gt;2">operator&gt;=</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);

template&lt;class RanIt1,
    class RanIt2&gt;
    Tdiff <B><A HREF="#operator-">operator-</A></B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    Tdiff <B><A HREF="#operator-">operator-</A></B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);

template&lt;class RanIt, class Diff&gt;
    move_iterator&lt;RanIt&gt; <B><A HREF="#operator+">operator+</A></B>(
        Diff off,
        const move_iterator&lt;RanIt&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt, class Diff&gt;
    reverse_iterator&lt;RanIt&gt; <B><A HREF="#operator+">operator+</A></B>(
        Diff off,
        const reverse_iterator&lt;RanIt&gt;&amp; right);

template&lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; <B><A HREF="#back_inserter">back_inserter</A></B>(Container&amp; cont);
template&lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; <B><A HREF="#front_inserter">front_inserter</A></B>(Container&amp; cont);
template&lt;class Container, class Iter&gt;
    insert_iterator&lt;Container&gt; <B><A HREF="#inserter">inserter</A></B>(Container&amp; cont, Iter it); <B>[replaced with C++11]</B>
template&lt;class Container&gt;
    insert_iterator&lt;Container&gt; <B><A HREF="#inserter">inserter</A></B>(Container&amp; cont,
        typename Container::iterator it); <B>[added with C++11]</B>

template&lt;class Iter&gt;
    move_iterator&lt;Iter&gt; <B><A HREF="#make_move_iterator">make_move_iterator</A></B>(const Iter&amp; it); <B>[added with C++11]</B>

template&lt;class InIt, class Diff&gt;
    void <B><A HREF="#advance">advance</A></B>(InIt&amp; it, Diff off);
template&lt;class InIt&gt;
    typename iterator_traits&lt;InIt&gt;::difference_type
        <B><A HREF="#distance">distance</A></B>(InIt first, InIt last);
template&lt;class FwdIt&gt;
    FwdIt <B><A HREF="#next">next</A></B>(FwdIt first,
        typename iterator_traits&lt;FwdIt&gt;::difference_type off = 1); <B>[added with C++11]</B>
template&lt;class BidIt&gt;
    BidIt <B><A HREF="#prev">prev</A></B>(BidIt first,
        typename iterator_traits&lt;BidIt&gt;::difference_type off = 1); <B>[added with C++11]</B>

template&lt;class Container&gt;
    auto <B><A HREF="#begin">begin</A></B>(Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.begin());
template&lt;class Container&gt;
    auto <B><A HREF="#begin">begin</A></B>(const Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.begin());
template&lt;class Ty, size_t Size&gt;
    Ty *<B><A HREF="#begin">begin</A></B>(Ty (&amp;array)[Size]); <B>[added with C++11]</B>

template&lt;class Container&gt;
    auto <B><A HREF="#end">end</A></B>(Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.end());
template&lt;class Container&gt;
    auto <B><A HREF="#end">end</A></B>(const Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.end());
template&lt;class Ty, size_t Size&gt;
    Ty *<B><A HREF="#end">end</A></B>(Ty (&amp;array)[Size]); <B>[added with C++11]</B>
}  // namespace std</PRE>

<H2><A NAME="advance"></A><CODE>advance</CODE></H2>

<PRE>template&lt;class InIt, class Diff&gt;
    void <B>advance</B>(InIt&amp; it, Diff off);</PRE>

<P>The template function effectively advances <CODE>it</CODE> by
incrementing it <CODE>off</CODE> times. If <CODE>InIt</CODE> is
a random-access iterator type, the function evaluates the expression
<CODE>it += off</CODE>. Otherwise, it performs each increment
by evaluating <CODE>++it</CODE>. If <CODE>InIt</CODE> is an
input or forward iterator type, <CODE>off</CODE> must not be negative.</P>

<H2><A NAME="back_insert_iterator"></A><CODE>back_insert_iterator</CODE></H2>

<PRE>template&lt;class Container&gt;
    class <B>back_insert_iterator</B>
        : public iterator&lt;output_iterator_tag,
            void, void, void, void&gt; {
public:
    typedef Container <B><A HREF="#back_insert_iterator__container_type">container_type</A></B>;
    explicit <B><A HREF="#back_insert_iterator__back_insert_iterator">back_insert_iterator</A></B>(Container&amp; cont);

    back_insert_iterator&amp;
        <B><A HREF="#back_insert_iterator__operator2">operator=</A></B>(const typename Container::value_type&amp; val);
    back_insert_iterator&amp;
        <B><A HREF="#back_insert_iterator__operator2">operator=</A></B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B>

    back_insert_iterator&amp; <B><A HREF="#back_insert_iterator__operator*">operator*</A></B>();
    back_insert_iterator&amp; <B><A HREF="#back_insert_iterator__operator++">operator++</A></B>();
    back_insert_iterator <B><A HREF="#back_insert_iterator__operator++">operator++</A></B>(int);

protected:
    Container *<B><A HREF="#back_insert_iterator__container">container</A></B>;
    };</PRE>

<P>The template class describes an output iterator object.
It inserts elements
into a container of type <B><CODE>Container</CODE></B>, which it accesses via
the protected pointer object it stores called
<B><CODE><A NAME="back_insert_iterator__container"></A>container</CODE></B>.
The container must define:</P>

<UL>
<LI>the member type <B><CODE>const_reference</CODE></B>, which is the type of
a constant reference to an element of the sequence controlled by the container</LI>

<LI>the member type <B><CODE>value_type</CODE></B>, which is the type of
an element of the sequence controlled by the container</LI>

<LI>the member function <CODE><B>push_back</B>(const_reference val)</CODE>,
which appends a new element to the end of the sequence
by copying the value <CODE>val</CODE></LI>

<LI><B>[added with C++11]</B> the member function <CODE><B>push_back</B>(value_type&amp;&amp; val)</CODE>,
which appends a new element to the end of the sequence
by moving the value <CODE>val</CODE></LI>
</UL>

<H3><A NAME="back_insert_iterator__back_insert_iterator"></A><CODE>back_insert_iterator::back_insert_iterator</CODE></H3>

<PRE>explicit <B>back_insert_iterator</B>(Container&amp; cont);</PRE>

<P>The constructor initializes
<CODE><A HREF="#back_insert_iterator__container">container</A></CODE>
with <CODE>&amp;cont</CODE>.</P>

<H3><A NAME="back_insert_iterator__container_type"></A><CODE>back_insert_iterator::container_type</CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><A NAME="back_insert_iterator__operator*"></A><CODE>back_insert_iterator::operator*</CODE></H3>

<PRE>back_insert_iterator&amp; <B>operator*</B>();</PRE>

<P>The member function returns <CODE>*this</CODE>.</P>

<H3><A NAME="back_insert_iterator__operator++"></A><CODE>back_insert_iterator::operator++</CODE></H3>

<PRE>back_insert_iterator&amp; <B>operator++</B>();
back_insert_iterator <B>operator++</B>(int);</PRE>

<P>The member functions both return <CODE>*this</CODE>.</P>

<H3><A NAME="back_insert_iterator__operator2"></A><CODE>back_insert_iterator::operator=</CODE></H3>

<PRE>back_insert_iterator&amp;
    <B>operator=</B>(const typename Container::value_type&amp; val);
back_insert_iterator&amp;
    <B>operator=</B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member operator evaluates
<CODE><A HREF="#back_insert_iterator__container">container</A>-&gt;push_back(val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<P>The second member operator evaluates
<CODE>container-&gt;push_back((typename Container::value_type&amp;&amp;)val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<H2><A NAME="back_inserter"></A><CODE>back_inserter</CODE></H2>

<PRE>template&lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; <B>back_inserter</B>(Container&amp; cont);</PRE>

<P>The template function returns
<CODE><A HREF="#back_insert_iterator__back_insert_iterator">back_insert_iterator</A>&lt;Container&gt;(cont)</CODE>.</P>

<H2><A NAME="begin"></A><CODE>begin</CODE></H2>

<PRE>template&lt;class Container&gt;
    auto <B>begin</B>(Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.begin());
template&lt;class Container&gt;
    auto <B>begin</B>(const Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.begin());
template&lt;class Ty, size_t Size&gt;
    Ty *<B>begin</B>(Ty (&amp;array)[Size]); <B>[added with C++11]</B></PRE>

<P>The first two template functions return <CODE>cont.begin()</CODE>.
The third template function returns <CODE>&amp;array[0]</CODE>.</P>

<H2><A NAME="bidirectional_iterator_tag"></A><CODE>bidirectional_iterator_tag</CODE></H2>

<PRE>struct <B>bidirectional_iterator_tag</B>
    : public forward_iterator_tag {
    };</PRE>

<P>The type is the same as
<CODE>iterator&lt;Iter&gt;::<A HREF="#iterator__iterator_category">iterator_category</A></CODE>
when <CODE>Iter</CODE> describes an object that can serve as a
bidirectional iterator.</P>

<H2><A NAME="distance"></A><CODE>distance</CODE></H2>

<PRE>template&lt;class InIt&gt;
    typename iterator_traits&lt;InIt&gt;::difference_type
        <B>distance</B>(InIt first, InIt last);</PRE>

<P>The template function sets a count <CODE>N</CODE> to zero. It then
effectively advances <CODE>first</CODE>
and increments <CODE>N</CODE> until <CODE>first == last</CODE>.
If <CODE>InIt</CODE> is
a random-access iterator type, the function evaluates the expression
<CODE>N += last - first</CODE>. Otherwise, it performs each iterator
increment by evaluating <CODE>++first</CODE>.
The function returns <CODE>N</CODE>.</P>


<H2><A NAME="end"></A><CODE>end</CODE></H2>

<PRE>template&lt;class Container&gt;
    auto <B>end</B>(Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.end());
template&lt;class Container&gt;
    auto <B>end</B>(const Container&amp; cont) <B>[added with C++11]</B>
        -&gt; decltype(cont.end());
template&lt;class Ty, size_t Size&gt;
    Ty *<B>end</B>(Ty (&amp;array)[Size]); <B>[added with C++11]</B></PRE>

<P>The first two template functions return <CODE>cont.end()</CODE>.
The third template function returns <CODE>&amp;array[Size]</CODE>.</P>

<H2><A NAME="forward_iterator_tag"></A><CODE>forward_iterator_tag</CODE></H2>

<PRE>struct <B>forward_iterator_tag</B>
    : public input_iterator_tag {
    };</PRE>

<P>The type is the same as
<CODE>iterator&lt;Iter&gt;::<A HREF="#iterator__iterator_category">iterator_category</A></CODE>
when <CODE>Iter</CODE> describes an object that can serve as a
forward iterator.</P>

<H2><A NAME="front_insert_iterator"></A><CODE>front_insert_iterator</CODE></H2>

<PRE>template&lt;class Container&gt;
    class <B>front_insert_iterator</B>
        : public iterator&lt;output_iterator_tag,
            void, void, void, void&gt; {
public:
    typedef Container <B><A HREF="#front_insert_iterator__container_type">container_type</A></B>;
    explicit <B><A HREF="#front_insert_iterator__front_insert_iterator">front_insert_iterator</A></B>(Container&amp; cont);

    front_insert_iterator&amp;
        <B><A HREF="#front_insert_iterator__operator2">operator=</A></B>(const typename Container::value_type&amp; val);
    front_insert_iterator&amp;
        <B><A HREF="#front_insert_iterator__operator2">operator=</A></B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B>

    front_insert_iterator&amp; <B><A HREF="#front_insert_iterator__operator*">operator*</A></B>();
    front_insert_iterator&amp; <B><A HREF="#front_insert_iterator__operator++">operator++</A></B>();
    front_insert_iterator <B><A HREF="#front_insert_iterator__operator++">operator++</A></B>(int);

protected:
    Container *<B><A HREF="#front_insert_iterator__container">container</A></B>;
    };</PRE>

<P>The template class describes an output iterator object.
It inserts elements
into a container of type <B><CODE>Container</CODE></B>, which it accesses via
the protected pointer object it stores called
<B><CODE><A NAME="front_insert_iterator__container"></A>container</CODE></B>.
The container must define:</P>

<UL>
<LI>the member type <B><CODE>const_reference</CODE></B>, which is the type of
a constant reference to an element of the sequence controlled by the container</LI>

<LI>the member type <B><CODE>value_type</CODE></B>, which is the type of
an element of the sequence controlled by the container</LI>

<LI>the member function <CODE><B>push_front</B>(const_reference val)</CODE>,
which prepends a new element at the beginning of the sequence
by copying the value <CODE>val</CODE></LI>

<LI><B>[added with C++11]</B> the member function <CODE><B>push_back</B>(value_type&amp;&amp; val)</CODE>,
which prepends a new element at the beginning of the sequence
by moving the value <CODE>val</CODE></LI>
</UL>

<H3><A NAME="front_insert_iterator__container_type"></A><CODE>front_insert_iterator::container_type</CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><A NAME="front_insert_iterator__front_insert_iterator"></A><CODE>front_insert_iterator::front_insert_iterator</CODE></H3>

<PRE>explicit <B>front_insert_iterator</B>(Container&amp; cont);</PRE>

<P>The constructor initializes
<CODE><A HREF="#front_insert_iterator__container">container</A></CODE>
with <CODE>&amp;cont</CODE>.</P>

<H3><A NAME="front_insert_iterator__operator*"></A><CODE>front_insert_iterator::operator*</CODE></H3>

<PRE>front_insert_iterator&amp; <B>operator*</B>();</PRE>

<P>The member function returns <CODE>*this</CODE>.</P>

<H3><A NAME="front_insert_iterator__operator++"></A><CODE>front_insert_iterator::operator++</CODE></H3>

<PRE>front_insert_iterator&amp; <B>operator++</B>();
front_insert_iterator <B>operator++</B>(int);</PRE>

<P>The member functions both return <CODE>*this</CODE>.</P>

<H3><A NAME="front_insert_iterator__operator2"></A><CODE>front_insert_iterator::operator=</CODE></H3>

<PRE>front_insert_iterator&amp;
    <B>operator=</B>(const typename Container::value_type&amp; val);
front_insert_iterator&amp;
    <B>operator=</B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member operator evaluates
<CODE><A HREF="#front_insert_iterator__container">container</A>-&gt;push_front(val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<P>The second member operator evaluates
<CODE>container-&gt;push_front((typename Container::value_type&amp;&amp;)val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<H2><A NAME="front_inserter"></A><CODE>front_inserter</CODE></H2>

<PRE>template&lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; <B>front_inserter</B>(Container&amp; cont);</PRE>

<P>The template function returns
<CODE><A HREF="#front_insert_iterator__front_insert_iterator">front_insert_iterator</A>&lt;Container&gt;(cont)</CODE>.</P>

<H2><A NAME="input_iterator_tag"></A><CODE>input_iterator_tag</CODE></H2>

<PRE>struct <B>input_iterator_tag</B> {
    };</PRE>

<P>The type is the same as
<CODE>iterator&lt;Iter&gt;::<A HREF="#iterator__iterator_category">iterator_category</A></CODE>
when <CODE>Iter</CODE> describes an object that can serve as an
input iterator.</P>

<H2><A NAME="insert_iterator"></A><CODE>insert_iterator</CODE></H2>

<PRE>template&lt;class Container&gt;
    class <B>insert_iterator</B>
        : public iterator&lt;output_iterator_tag,
            void, void, void, void&gt; {
public:
    typedef Container <B><A HREF="#insert_iterator__container_type">container_type</A></B>;
    <B><A HREF="#insert_iterator__insert_iterator">insert_iterator</A></B>(Container&amp; cont,
        typename Container::iterator it);

    insert_iterator&amp;
        <B><A HREF="#insert_iterator__operator2">operator=</A></B>(typename const typename Container::value_type&amp; val);
    insert_iterator&amp;
        <B><A HREF="#insert_iterator__operator2">operator=</A></B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B>

    insert_iterator&amp; <B><A HREF="#insert_iterator__operator*">operator*</A></B>();
    insert_iterator&amp; <B><A HREF="#insert_iterator__operator++">operator++</A></B>();
    insert_iterator&amp; <B><A HREF="#insert_iterator__operator++">operator++</A></B>(int);

protected:
    Container *<B><A HREF="#insert_iterator__container">container</A></B>;
    typename Container::iterator <B><A HREF="#insert_iterator__iter">iter</A></B>;
    };</PRE>

<P>The template class describes an output iterator object.
It inserts elements
into a container of type <B><CODE>Container</CODE></B>, which it accesses via
the protected pointer object it stores called
<B><CODE><A NAME="insert_iterator__container"></A>container</CODE></B>.
It also stores the protected iterator object, of class
<CODE>Container::iterator</CODE>, called
<B><CODE><A NAME="insert_iterator__iter"></A>iter</CODE></B>.
The container must define:</P>

<UL>
<LI>the member type <B><CODE>const_reference</CODE></B>, which is the type of
a constant reference to an element of the sequence controlled by the container</LI>

<LI>the member type <B><CODE>iterator</CODE></B>, which is the type of
an iterator for the container</LI>

<LI>the member type <B><CODE>value_type</CODE></B>, which is the type of
an element of the sequence controlled by the container</LI>

<LI>the member function <CODE><B>insert</B>(iterator it,
const_reference val)</CODE>,
which inserts a new element immediately before
the element designated by <CODE>it</CODE> in the controlled sequence,
by copying the value <CODE>val</CODE>,
then returns an iterator that designates the inserted element</LI>

<LI><B>[added with C++11]</B> the member function <CODE><B>insert</B>(iterator it,
value_type&amp;&amp; val)</CODE>,
which inserts a new element immediately before
the element designated by <CODE>it</CODE> in the controlled sequence,
by moving the value <CODE>val</CODE>,
then returns an iterator that designates the inserted element</LI>
</UL>

<H3><A NAME="insert_iterator__container_type"></A><CODE>insert_iterator::container_type</CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><A NAME="insert_iterator__insert_iterator"></A><CODE>insert_iterator::insert_iterator</CODE></H3>

<PRE><B>insert_iterator</B>(Container&amp; cont,
    typename Container::iterator it);</PRE>

<P>The constructor initializes
<CODE><A HREF="#insert_iterator__container">container</A></CODE>
with <CODE>&amp;cont</CODE>, and
<CODE><A HREF="#insert_iterator__iter">iter</A></CODE>
with <CODE>it</CODE>.</P>

<H3><A NAME="insert_iterator__operator*"></A><CODE>insert_iterator::operator*</CODE></H3>

<PRE>insert_iterator&amp; <B>operator*</B>();</PRE>

<P>The member function returns <CODE>*this</CODE>.</P>

<H3><A NAME="insert_iterator__operator++"></A><CODE>insert_iterator::operator++</CODE></H3>

<PRE>insert_iterator&amp; <B>operator++</B>();
insert_iterator&amp; <B>operator++</B>(int);</PRE>

<P>The member functions both return <CODE>*this</CODE>.</P>

<H3><A NAME="insert_iterator__operator2"></A><CODE>insert_iterator::operator=</CODE></H3>

<PRE>insert_iterator&amp;
    <B>operator=</B>(typename const typename Container::value_type&amp; val);
insert_iterator&amp;
    <B>operator=</B>(typename Container::value_type&amp;&amp; val); <B>[added with C++11]</B></PRE>

<P>The first member operator evaluates
<CODE><A HREF="#insert_iterator__iter">iter</A> =
<A HREF="#insert_iterator__container">container</A>-&gt;insert(iter, val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<P>The second member operator evaluates
<CODE>iter = container-&gt;insert(iter, (typename Container::value_type&amp;&amp;)val)</CODE>,
then returns <CODE>*this</CODE>.</P>

<H2><A NAME="inserter"></A><CODE>inserter</CODE></H2>

<PRE>template&lt;class Container, class Iter&gt;
    insert_iterator&lt;Container&gt; <B>inserter</B>(Container&amp; cont, Iter it); <B>[replaced with C++11]</B>
template&lt;class Container&gt;
    insert_iterator&lt;Container&gt; <B>inserter</B>(Container&amp; cont,
        typename Container::iterator it); <B>[added with C++11]</B></PRE>

<P>The template function returns
<CODE><A HREF="#insert_iterator__insert_iterator">insert_iterator</A>&lt;Container&gt;(cont, it)</CODE>.</P>

<H2><A NAME="istream_iterator"></A><CODE>istream_iterator</CODE></H2>

<PRE>template&lt;class Ty, class Elem = char,
    class Tr = char_traits&gt;
    class Diff = ptrdiff_t&gt;
    class <B>istream_iterator</B>
        : public iterator&lt;input_iterator_tag,
            Ty, Diff, const Ty *, const Ty&amp;&gt; {
public:
    typedef Elem <B><A HREF="#istream_iterator__char_type">char_type</A></B>;
    typedef Tr <B><A HREF="#istream_iterator__traits_type">traits_type</A></B>;
    typedef basic_istream&lt;Elem, Tr&gt; <B><A HREF="#istream_iterator__istream_type">istream_type</A></B>;

    constexpr <B><A HREF="#istream_iterator__istream_iterator">istream_iterator</A></B>();
    <B><A HREF="#istream_iterator__istream_iterator">istream_iterator</A></B>(istream_type&amp; istr);
    <B>istream_iterator</B>(const istream_iterator&amp;) = default; <B>[added with C++11]</B>&nbsp;
    <B>~istream_iterator</B>() = default; <B>[added with C++11]</B>

    const Ty&amp; <B><A HREF="#istream_iterator__operator*">operator*</A></B>() const;
    const Ty *<B><A HREF="#istream_iterator__operator-&gt;">operator-&gt;</A></B>() const;
    istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; <B><A HREF="#istream_iterator__operator++">operator++</A></B>();
    istream_iterator&lt;Ty, Elem, Tr, Diff&gt; <B><A HREF="#istream_iterator__operator++">operator++</A></B>(int);
    };</PRE>

<P>The template class describes an input iterator object.
It extracts objects of class <B><CODE>Ty</CODE></B>
from an <B>input stream</B>, which it accesses via an object it stores,
of type pointer to
<CODE>basic_istream&lt;Elem, Tr&gt;</CODE>.
After constructing or incrementing an object of class
<CODE>istream_iterator</CODE> with a non-null stored pointer,
the object attempts to extract and store an object of type
<CODE>Ty</CODE> from the associated input stream. If the extraction
fails, the object effectively replaces the stored pointer with
a null pointer (thus making an end-of-sequence indicator).</P>


<H3><A NAME="istream_iterator__char_type"></A><CODE>istream_iterator::char_type</CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="istream_iterator__istream_iterator"></A><CODE>istream_iterator::istream_iterator</CODE></H3>

<PRE>constexpr <B>istream_iterator</B>();
<B>istream_iterator</B>(istream_type&amp; istr);</PRE>

<P>The first constructor initializes the input stream pointer
with a null pointer.
The second constructor initializes the input stream pointer
with <CODE>&amp;istr</CODE>, then attempts to extract and store
an object of type <CODE>Ty</CODE>.</P>

<H3><A NAME="istream_iterator__istream_type"></A><CODE>istream_iterator::istream_type</CODE></H3>

<PRE>typedef basic_istream&lt;Elem, Tr&gt; <B>istream_type</B>;</PRE>

<P>The type is a synonym for
<CODE>basic_istream&lt;Elem, Tr&gt;</CODE>.</P>

<H3><A NAME="istream_iterator__operator*"></A><CODE>istream_iterator::operator*</CODE></H3>

<PRE>const Ty&amp; <B>operator*</B>() const;</PRE>

<P>The operator returns the stored object of type <CODE>Ty</CODE>.</P>

<H3><A NAME="istream_iterator__operator-&gt;"></A><CODE>istream_iterator::operator-&gt;</CODE></H3>

<PRE>const Ty *<B>operator-&gt;</B>() const;</PRE>

<P>The operator returns <CODE>&amp;**this</CODE>.</P>

<H3><A NAME="istream_iterator__operator++"></A><CODE>istream_iterator::operator++</CODE></H3>

<PRE>istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; <B>operator++</B>();
istream_iterator&lt;Ty, Elem, Tr, Diff&gt; <B>operator++</B>(int);</PRE>

<P>The first operator attempts to extract and store an object
of type <CODE>Ty</CODE> from the associated input stream. The second
operator makes a copy of the object, increments the object, then
returns the copy.</P>

<H3><A NAME="istream_iterator__traits_type"></A><CODE>istream_iterator::traits_type</CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H2><A NAME="istreambuf_iterator"></A><CODE>istreambuf_iterator</CODE></H2>

<PRE>template&lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B>istreambuf_iterator</B>
        : public iterator&lt;input_iterator_tag,
            Elem, typename Ty::off_type, Elem *, Elem&gt; {
public:
    typedef Elem <B><A HREF="#istreambuf_iterator__char_type">char_type</A></B>;
    typedef Tr <B><A HREF="#istreambuf_iterator__traits_type">traits_type</A></B>;
    typedef typename Tr::int_type <B><A HREF="#istreambuf_iterator__int_type">int_type</A></B>;
    typedef basic_streambuf&lt;Elem, Tr&gt; <B><A HREF="#istreambuf_iterator__streambuf_type">streambuf_type</A></B>;
    typedef basic_istream&lt;Elem, Tr&gt; <B><A HREF="#istreambuf_iterator__istream_type">istream_type</A></B>;

    constexpr <B><A HREF="#istreambuf_iterator__istreambuf_iterator">istreambuf_iterator</A></B>(streambuf_type *strbuf = 0) throw();
    <B><A HREF="#istreambuf_iterator__istreambuf_iterator">istreambuf_iterator</A></B>(istream_type&amp; istr) throw();
    <B>istreambuf_iterator</B>(const istreambuf_iterator&amp;) throw() = default;
    <B>~istreambuf_iterator</B>() throw() = default;

    Elem <B><A HREF="#istreambuf_iterator__operator*">operator*</A></B>() const;
    Elem *<B><A HREF="#istreambuf_iterator__operator-&gt;">operator-&gt;</A></B>() const;
    istreambuf_iterator&amp; <B><A HREF="#istreambuf_iterator__operator++">operator++</A></B>();
    istreambuf_iterator <B><A HREF="#istreambuf_iterator__operator++">operator++</A></B>(int);
    bool <B><A HREF="#istreambuf_iterator__equal">equal</A></B>(const istreambuf_iterator&amp; right) const;
    };</PRE>

<P>The template class describes an input iterator object.
It extracts elements of class <B><CODE>Elem</CODE></B>
from an <B>input stream buffer</B>,
which it accesses via an object it stores,
of type pointer to
<CODE>basic_streambuf&lt;Elem,
<B>Tr</B>&gt;</CODE>.
After constructing or incrementing an object of class
<CODE>istreambuf_iterator</CODE> with a non-null stored pointer,
the object effectively attempts to extract and store an object of type
<CODE>Elem</CODE> from the associated input stream.
(The extraction may be delayed, however, until the object
is actually dereferenced or copied.) If the extraction
fails, the object effectively replaces the stored pointer with
a null pointer (thus making an end-of-sequence indicator).</P>


<H3><A NAME="istreambuf_iterator__char_type"></A><CODE>istreambuf_iterator::char_type</CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="istreambuf_iterator__equal"></A><CODE>istreambuf_iterator::equal</CODE></H3>

<PRE>bool <B>equal</B>(const istreambuf_iterator&amp; right) const;</PRE>

<P>The member function returns true only if the stored stream buffer
pointers for the object and <CODE>right</CODE> are both null pointers
or are both non-null pointers.</P>

<H3><A NAME="istreambuf_iterator__int_type"></A><CODE>istreambuf_iterator::int_type</CODE></H3>

<PRE>typedef typename Tr::int_type <B>int_type</B>;</PRE>

<P>The type is a synonym for
<CODE>Ty::int_type</CODE>.</P>

<H3><A NAME="istreambuf_iterator__istream_type"></A><CODE>istreambuf_iterator::istream_type</CODE></H3>

<PRE>typedef basic_istream&lt;Elem, Tr&gt; <B>istream_type</B>;</PRE>

<P>The type is a synonym for
<CODE>basic_istream&lt;Elem,
Tr&gt;</CODE>.</P>

<H3><A NAME="istreambuf_iterator__istreambuf_iterator"></A><CODE>istreambuf_iterator::istreambuf_iterator</CODE></H3>

<PRE>constexpr <B>istreambuf_iterator</B>(streambuf_type *strbuf = 0) throw();
<B>istreambuf_iterator</B>(istream_type&amp; istr) throw();</PRE>

<P>The first constructor initializes the input stream-buffer pointer
with <CODE>strbuf</CODE>.
The second constructor initializes the input stream-buffer pointer with
<CODE>istr.rdbuf()</CODE>,
then (eventually) attempts to extract and store
an object of type <CODE>Elem</CODE>.</P>

<H3><A NAME="istreambuf_iterator__operator*"></A><CODE>istreambuf_iterator::operator*</CODE></H3>

<PRE>Elem <B>operator*</B>() const;</PRE>

<P>The operator returns the stored object of type <CODE>Elem</CODE>.</P>

<H3><A NAME="istreambuf_iterator__operator-&gt;"></A><CODE>istreambuf_iterator::operator-&gt;</CODE></H3>

<PRE>Elem *<B>operator-&gt;</B>() const;</PRE>

<P>The operator returns a pointer to the stored object of type <CODE>Elem</CODE>.</P>

<H3><A NAME="istreambuf_iterator__operator++"></A><CODE>istreambuf_iterator::operator++</CODE></H3>

<PRE>istreambuf_iterator&amp; <B>operator++</B>();
istreambuf_iterator <B>operator++</B>(int);</PRE>

<P>The first operator (eventually) attempts to extract and store an object
of type <CODE>Elem</CODE> from the associated input stream. The second
operator makes a copy of the object, increments the object, then
returns the copy.</P>

<H3><A NAME="istreambuf_iterator__streambuf_type"></A><CODE>istreambuf_iterator::streambuf_type</CODE></H3>

<PRE>typedef basic_streambuf&lt;Elem, Tr&gt; <B>streambuf_type</B>;</PRE>

<P>The type is a synonym for
<CODE>basic_streambuf&lt;Elem,
Tr&gt;</CODE>.</P>

<H3><A NAME="istreambuf_iterator__traits_type"></A><CODE>istreambuf_iterator::traits_type</CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H2><A NAME="iterator"></A><CODE>iterator</CODE></H2>

<PRE>template&lt;class Category, class Ty, class Diff = ptrdiff_t
    class Pointer = Ty *, class Reference = Ty&amp;&gt;
    struct <B>iterator</B> {
    typedef Category <B>iterator_category</B>;
    typedef Ty <B>value_type</B>;
    typedef Diff <B>difference_type</B>;
    typedef Pointer <B>pointer</B>;
    typedef Reference <B>reference</B>;
    };</PRE>

<P>The template class can serve as a convenient base class
for an iterator class that you define.
It defines the member types
<CODE><A NAME="iterator__iterator_category"></A>iterator_category</CODE>
(a synonym for the template parameter <CODE>Category</CODE>),
<CODE><A NAME="iterator__value_type"></A>value_type</CODE>
(a synonym for the template parameter <CODE>Ty</CODE>),
<CODE><A NAME="iterator__difference_type"></A>difference_type</CODE>
(a synonym for the template parameter <CODE>Diff</CODE>),
<CODE><A NAME="iterator__pointer"></A>pointer</CODE>
(a synonym for the template parameter <CODE>Pointer</CODE>), and
<CODE><A NAME="iterator__reference"></A>reference</CODE>
(a synonym for the template parameter <CODE>Reference</CODE>).</P>

<P>Note that <CODE>value_type</CODE> should <I>not</I> be a constant
type even if <CODE>pointer</CODE> points at an object of const type
and <CODE>reference</CODE> designates an object of const type.</P>

<H2><A NAME="iterator_traits"></A><CODE>iterator_traits</CODE></H2>

<PRE>template&lt;class Iter&gt;
    struct <B>iterator_traits</B> {
    typedef typename Iter::iterator_category <B>iterator_category</B>;
    typedef typename Iter::value_type <B>value_type</B>;
    typedef typename Iter::difference_type <B>difference_type</B>;
    typedef typename Iter::pointer <B>pointer</B>;
    typedef typename Iter::reference <B>reference</B>;
    };
template&lt;class Ty&gt;
    struct <B>iterator_traits</B>&lt;Ty *&gt; {
    typedef random_access_iterator_tag <B>iterator_category</B>;
    typedef Ty <B>value_type</B>;
    typedef ptrdiff_t <B>difference_type</B>;
    typedef Ty *<B>pointer</B>;
    typedef Ty&amp; <B>reference</B>;
    };
template&lt;class Ty&gt;
    struct <B>iterator_traits</B>&lt;const Ty *&gt; {
    typedef random_access_iterator_tag <B>iterator_category</B>;
    typedef Ty <B>value_type</B>;
    typedef ptrdiff_t <B>difference_type</B>;
    typedef const Ty *<B>pointer</B>;
    typedef const Tr&amp; <B>reference</B>;
    };</PRE>

<P>The template class determines several critical types associated
with the iterator type <CODE>Iter</CODE>.
It defines the member types
<CODE><A NAME="iterator_traits__iterator_category"></A>iterator_category</CODE>
(a synonym for <CODE>Iter::iterator_category</CODE>),
<CODE><A NAME="iterator_traits__value_type"></A>value_type</CODE>
(a synonym for <CODE>Iter::value_type</CODE>),
<CODE><A NAME="iterator_traits__difference_type"></A>difference_type</CODE>
(a synonym for <CODE>Iter::difference_type</CODE>),
<CODE><A NAME="iterator_traits__pointer"></A>pointer</CODE>
(a synonym for <CODE>Iter::pointer</CODE>), and
<CODE><A NAME="iterator_traits__reference"></A>reference</CODE>
(a synonym for <CODE>Iter::reference</CODE>).</P>

<P>The partial specializations determine the critical types associated
with an object pointer type <CODE>Ty *</CODE> or <CODE>const Ty *</CODE>. In this
implementation,
you can also use several template functions that do not make use of
partial specialization:</P>

<PRE>template&lt;class Category, class Ty, class Diff&gt;
    C <B><A NAME="_Iter_cat"></A>_Iter_cat</B>(const iterator&lt;Category, Ty, Diff&gt;&amp;);
template&lt;class Ty&gt;
    random_access_iterator_tag <B>_Iter_cat</B>(const Ty *);

template&lt;class Category, class Ty, class Diff&gt;
    Ty *<B><A NAME="_Val_type"></A>_Val_type</B>(const iterator&lt;Category, Ty, Diff&gt;&amp;);
template&lt;class Ty&gt;
    Ty *<B>_Val_type</B>(const Ty *);

template&lt;class Category, class Ty, class Diff&gt;
    Diff *<B><A NAME="_Dist_type"></A>_Dist_type</B>(const iterator&lt;Category, Ty, Diff&gt;&amp;);
template&lt;class Ty&gt;
    ptrdiff_t *<B>_Dist_type</B>(const Ty *);</PRE>

<P>which determine several of the same types a bit more indirectly.
You use these functions as arguments
on a function call. Their sole purpose is to supply a useful template
class parameter to the called function.</P>

<H2><A NAME="make_move_iterator"></A><CODE>make_move_iterator</CODE></H2>

<PRE>template&lt;class Iter&gt;
    move_iterator&lt;Iter&gt; <B>make_move_iterator</B>(const Iter&amp; it);</PRE>

<P>The template function returns
<CODE><A HREF="#move_iterator__move_iterator">move_iterator</A>&lt;Iter&gt;(it)</CODE>.</P>

<H2><A NAME="move_iterator"></A><CODE>move_iterator</CODE></H2>

<PRE>template&lt;class RanIt&gt;
    class <B>move_iterator</B> { <B>[added with C++11]</B>
public:
    typedef RanIt <B><A HREF="#move_iterator__iterator_type">iterator_type</A></B>;
    typedef typename iterator_traits&lt;RanIt&gt;::iterator_category
        <B><A HREF="#move_iterator__iterator_category">iterator_category</A></B>;
    typedef typename iterator_traits&lt;RanIt&gt;::value_type
        <B><A HREF="#move_iterator__value_type">value_type</A></B>;
    typedef typename iterator_traits&lt;RanIt&gt;::difference_type
        <B><A HREF="#move_iterator__difference_type">difference_type</A></B>;
    typedef RanIt
        <B><A HREF="#move_iterator__pointer">pointer</A></B>;
    typedef value_type&amp;&amp;
        <B><A HREF="#move_iterator__reference">reference</A></B>;

    <B><A HREF="#move_iterator__move_iterator">move_iterator</A></B>();
    explicit <B><A HREF="#move_iterator__move_iterator">move_iterator</A></B>(RanIt right);
    template&lt;class Ty&gt;
        <B><A HREF="#move_iterator__move_iterator">move_iterator</A></B>(const move_iterator&lt;Ty&gt;&amp; right);

    RanIt <B><A HREF="#move_iterator__base">base</A></B>() const;
    reference <B><A HREF="#move_iterator__operator*">operator*</A></B>() const;
    pointer <B><A HREF="#move_iterator__operator-&gt;">operator-&gt;</A></B>() const;

    move_iterator&amp; <B><A HREF="#move_iterator__operator++">operator++</A></B>();
    move_iterator <B><A HREF="#move_iterator__operator++">operator++</A></B>(int);
    move_iterator&amp; <B><A HREF="#move_iterator__operator--">operator--</A></B>();
    move_iterator <B><A HREF="#move_iterator__operator--">operator--</A></B>();

    move_iterator&amp; <B><A HREF="#move_iterator__operator+2">operator+=</A></B>(difference_type off);
    move_iterator <B><A HREF="#move_iterator__operator+">operator+</A></B>(difference_type off) const;
    move_iterator&amp; <B><A HREF="#move_iterator__operator-2">operator-=</A></B>(difference_type off);
    move_iterator <B><A HREF="#move_iterator__operator-">operator-</A></B>(difference_type off) const;
    T1 <B><A HREF="#move_iterator__operator[]">operator[]</A></B>(difference_type off) const;
    };</PRE>

<P>The template class describes an object that behaves like a
random-access iterator, except when dereferenced. It stores a random-access iterator
of type <B><CODE>RanIt</CODE></B>, accessible via the member function
<CODE><A HREF="#move_iterator__base">base</A>()</CODE>.
All operations on a <CODE>move_iterator</CODE>
are performed directly on the stored iterator, except that the result of
<CODE><A HREF="#move_iterator__operator*">operator*</A></CODE> is implicitly
cast to <CODE><A HREF="#move_iterator__value_type">value_type</A>&amp;&amp;</CODE>
to make an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<P>It is permissible to instantiantiate <CODE>move_iterator</CODE> for
iterators with categories weaker than random-access provided that
no undefined operations are attempted on the stored iterator.</P>

<H3><A NAME="move_iterator__base"></A><CODE>move_iterator::base</CODE></H3>

<PRE>RanIt <B>base</B>() const;</PRE>

<P>The member function returns the stored iterator.</P>

<H3><A NAME="move_iterator__difference_type"></A><CODE>move_iterator::difference_type</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::difference_type
    <B>difference_type</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::pointer</CODE>.</P>

<H3><A NAME="move_iterator__iterator_category"></A><CODE>move_iterator::iterator_category</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::iterator_category
    <B>iterator_category</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::iterator_category</CODE>.</P>

<H3><A NAME="move_iterator__iterator_type"></A><CODE>move_iterator::iterator_type</CODE></H3>

<PRE>typedef RanIt <B>iterator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>RanIt</CODE>.</P>

<H3><A NAME="move_iterator__move_iterator"></A><CODE>move_iterator::move_iterator</CODE></H3>

<PRE><B>move_iterator</B>();
explicit <B>move_iterator</B>(RanIt right);
template&lt;class Ty&gt;
    <B><A HREF="#move_iterator__move_iterator">move_iterator</A></B>(const move_iterator&lt;Ty&gt;&amp; right);</PRE>

<P>The first constructor initializes the stored iterator
with its default constructor. The remaining constructors initialize the stored iterator
with <CODE><A HREF="#move_iterator__base">base</A>.base()</CODE>.</P>

<H3><A NAME="move_iterator__operator*"></A><CODE>move_iterator::operator*</CODE></H3>

<PRE>reference <B>operator*</B>() const;</PRE>

<P>The operator returns
<CODE>(reference)*<A HREF="#move_iterator__base">base</A>()</CODE>.</P>

<H3><A NAME="move_iterator__operator+"></A><CODE>move_iterator::operator+</CODE></H3>

<PRE>move_iterator <B>operator+</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>move_iterator(*this) += off</CODE>.</P>

<H3><A NAME="move_iterator__operator++"></A><CODE>move_iterator::operator++</CODE></H3>

<PRE>move_iterator&amp; <B>operator++</B>();
move_iterator <B>operator++</B>(int);</PRE>

<P>The first (preincrement) operator increments the stored iterator,
then returns <CODE>*this</CODE>.</P>

<P>The second (postincrement) operator makes a copy of <CODE>*this</CODE>,
evaluates <CODE>++*this</CODE>, then returns the copy.</P>

<H3><A NAME="move_iterator__operator+2"></A><CODE>move_iterator::operator+=</CODE></H3>

<PRE>move_iterator&amp; <B>operator+=</B>(difference_type off);</PRE>

<P>The operator adds <CODE>off</CODE> to the stored iterator,
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="move_iterator__operator-"></A><CODE>move_iterator::operator-</CODE></H3>

<PRE>move_iterator <B>operator-</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>move_iterator(*this) -= off</CODE>.</P>

<H3><A NAME="move_iterator__operator--"></A><CODE>move_iterator::operator--</CODE></H3>

<PRE>move_iterator&amp; <B>operator--</B>();
move_iterator <B>operator--</B>();</PRE>

<P>The first (predecrement) decrements the stored iterator,
then returns <CODE>*this</CODE>.</P>

<P>The second (postdecrement) operator makes a copy of <CODE>*this</CODE>,
evaluates <CODE>--*this</CODE>, then returns the copy.</P>

<H3><A NAME="move_iterator__operator-2"></A><CODE>move_iterator::operator-=</CODE></H3>

<PRE>move_iterator&amp; <B>operator-=</B>(difference_type off);</PRE>

<P>The operator evaluates <CODE>*this += -off</CODE>,
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="move_iterator__operator-&gt;"></A><CODE>move_iterator::operator-&gt;</CODE></H3>

<PRE>pointer <B>operator-&gt;</B>() const;</PRE>

<P>The operator returns <CODE>&amp;**this</CODE>.</P>

<H3><A NAME="move_iterator__operator[]"></A><CODE>move_iterator::operator[]</CODE></H3>

<PRE>T1 <B>operator[]</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>*(*this + off)</CODE>, of unspecified type
<CODE>T1</CODE>.</P>

<H3><A NAME="move_iterator__pointer"></A><CODE>move_iterator::pointer</CODE></H3>

<PRE>typedef RanIt
    <B>pointer</B>;</PRE>

<P>The type is a synonym for <CODE>RanIt</CODE>.</P>

<H3><A NAME="move_iterator__reference"></A><CODE>move_iterator::reference</CODE></H3>

<PRE>typedef value_type&amp;&amp;
    <B>reference</B>;</PRE>

<P>The type is a synonym for
<CODE>value_type&amp;&amp;</CODE>, which is an
<A HREF="lib_cpp.html#rvalue_references">rvalue reference</A>.</P>

<H3><A NAME="move_iterator__value_type"></A><CODE>move_iterator::value_type</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::value_type
    <B>value_type</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::value_type</CODE>.</P>

<H2><A NAME="next"></A><CODE>next</CODE></H2>

<PRE>template&lt;class FwdIt&gt;
    FwdIt <B>next</B>(FwdIt first,
        typename iterator_traits&lt;FwdIt&gt;::difference_type off = 1); <B>[added with C++11]</B></PRE>

<P>The template function returns <CODE>next</CODE> incremented
<CODE>off</CODE> times.</P>


<H2><A NAME="operator!2"></A><CODE>operator!=</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator!=</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator!=</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr, class Diff&gt;
    bool <B>operator!=</B>(
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; left,
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; right);
template&lt;class Elem, class Tr&gt;
    bool <B>operator!=</B>(
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; left,
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; right);</PRE>

<P>The template operator returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator22"></A><CODE>operator==</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator==</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator==</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr, class Diff&gt;
    bool <B>operator==</B>(
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; left,
        const istream_iterator&lt;Ty, Elem, Tr, Diff&gt;&amp; right);
template&lt;class Elem, class Tr&gt;
    bool <B>operator==</B>(
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; left,
        const istreambuf_iterator&lt;Elem, Tr&gt;&amp; right);</PRE>

<P>The first two template operators return true only if
both <CODE>left</CODE> and <CODE>right</CODE> store the same
iterator. The third template operator returns true only
if both <CODE>left</CODE> and <CODE>right</CODE> store the same
stream pointer. The fourth template operator returns
<CODE>left.<A HREF="#istreambuf_iterator__equal">equal</A>(right)</CODE>.</P>

<H2><A NAME="operator&lt;"></A><CODE>operator&lt;</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&lt;</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&lt;</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);</PRE>

<P>The first template operator returns
<CODE>left.<A HREF="#move_iterator__base">base</A>() &lt;
right.base()</CODE>.</P>

<P>The second template operator returns
<CODE>right.<A HREF="#reverse_iterator__current">current</A> &lt;
left.current</CODE> [sic].</P>

<H2><A NAME="operator&lt;2"></A><CODE>operator&lt;=</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&lt;=</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&lt;=</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);</PRE>

<P>The template operatorsreturn <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"></A><CODE>operator&gt;</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&gt;</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&gt;</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);</PRE>

<P>The template operators return <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;2"></A><CODE>operator&gt;=</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&gt;=</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    bool <B>operator&gt;=</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);</PRE>

<P>The template operators return <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="operator+"></A><CODE>operator+</CODE></H2>

<PRE>template&lt;class RanIt, class Diff&gt;
    move_iterator&lt;RanIt&gt; <B>operator+</B>(
        Diff off,
        const move_iterator&lt;RanIt&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt&gt;
    reverse_iterator&lt;RanIt&gt; <B>operator+</B>(
        Diff off,
        const reverse_iterator&lt;RanIt&gt;&amp; right);</PRE>

<P>The template operators return <CODE>right + off</CODE>.</P>

<H2><A NAME="operator-"></A><CODE>operator-</CODE></H2>

<PRE>template&lt;class RanIt1,
    class RanIt2&gt;
    Tdiff <B>operator-</B>(
        const move_iterator&lt;RanIt1&gt;&amp; left,
        const move_iterator&lt;RanIt2&gt;&amp; right); <B>[added with C++11]</B>
template&lt;class RanIt1,
    class RanIt2&gt;
    Tdiff <B>operator-</B>(
        const reverse_iterator&lt;RanIt1&gt;&amp; left,
        const reverse_iterator&lt;RanIt2&gt;&amp; right);</PRE>

<P>The first template operator returns
<CODE>left.<A HREF="#move_iterator__base">base</A>() - right.base()</CODE>.</P>

<P>The second template operator returns
<CODE>right.<A HREF="#reverse_iterator__current">current</A> -
left.current</CODE> [sic].</P>

<P>Beginning with <B>C++11</B>, <CODE>Tdiff</CODE> is determined
by the type of the returned expression. Otherwise, it is
<CODE>RanIt1::difference_type</CODE>.</P>

<H2><A NAME="ostream_iterator"></A><CODE>ostream_iterator</CODE></H2>

<PRE>template&lt;class Ty, class Elem = char,
    class Tr = char_traits&lt;Elem&gt;  &gt;
    class <B>ostream_iterator</B>
        : public iterator&lt;output_iterator_tag,
            void, void, void, void&gt; {
public:
    typedef Elem <B><A HREF="#ostream_iterator__char_type">char_type</A></B>;
    typedef Tr <B><A HREF="#ostream_iterator__traits_type">traits_type</A></B>;

    typedef basic_ostream&lt;Elem, Tr&gt; <B><A HREF="#ostream_iterator__ostream_type">ostream_type</A></B>;
    <B><A HREF="#ostream_iterator__ostream_iterator">ostream_iterator</A></B>(ostream_type&amp; ostr);
    <B><A HREF="#ostream_iterator__ostream_iterator">ostream_iterator</A></B>(ostream_type&amp; ostr, const Elem *delim);

    ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B><A HREF="#ostream_iterator__operator2">operator=</A></B>(const Ty&amp; val);
    ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B><A HREF="#ostream_iterator__operator*">operator*</A></B>();
    ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B><A HREF="#ostream_iterator__operator++">operator++</A></B>();
    ostream_iterator&lt;Ty, Elem, Tr&gt; <B><A HREF="#ostream_iterator__operator++">operator++</A></B>(int);
    };</PRE>

<P>The template class describes an output iterator object.
It inserts objects of class <B><CODE>Ty</CODE></B>
into an <B>output stream</B>, which it accesses via an object it stores,
of type pointer to
<CODE>basic_ostream&lt;Elem, Tr&gt;</CODE>.
It also stores a pointer to a <B>delimiter string</B>, a
null-terminated string
of elements of type <CODE>Elem</CODE>, which is appended after
each insertion. (Note that the string itself is <I>not</I> copied
by the constructor.</P>


<H3><A NAME="ostream_iterator__char_type"></A><CODE>ostream_iterator::char_type</CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="ostream_iterator__operator*"></A><CODE>ostream_iterator::operator*</CODE></H3>

<PRE>ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B>operator*</B>();</PRE>

<P>The operator returns <CODE>*this</CODE>.</P>

<H3><A NAME="ostream_iterator__operator++"></A><CODE>ostream_iterator::operator++</CODE></H3>

<PRE>ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B>operator++</B>();
ostream_iterator&lt;Ty, Elem, Tr&gt; <B>operator++</B>(int);</PRE>

<P>The operators both return <CODE>*this</CODE>.</P>

<H3><A NAME="ostream_iterator__operator2"></A><CODE>ostream_iterator::operator=</CODE></H3>

<PRE>ostream_iterator&lt;Ty, Elem, Tr&gt;&amp; <B>operator=</B>(const Ty&amp; val);</PRE>

<P>The operator inserts <CODE>val</CODE> into the
output stream associated with the object,
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="ostream_iterator__ostream_iterator"></A><CODE>ostream_iterator::ostream_iterator</CODE></H3>

<PRE><B>ostream_iterator</B>(ostream_type&amp; ostr);
<B>ostream_iterator</B>(ostream_type&amp; ostr, const Elem *delim);</PRE>

<P>The first constructor initializes the output stream pointer
with <CODE>&amp;ostr</CODE>. The delimiter string pointer designates an
empty string. The second constructor initializes the output stream
pointer with <CODE>&amp;ostr</CODE> and the delimiter string pointer
with <CODE>delim</CODE>.</P>

<H3><A NAME="ostream_iterator__ostream_type"></A><CODE>ostream_iterator::ostream_type</CODE></H3>

<PRE>typedef basic_ostream&lt;Elem, Tr&gt; <B>ostream_type</B>;</PRE>

<P>The type is a synonym for
<CODE>basic_ostream&lt;Elem, Tr&gt;</CODE>.</P>

<H3><A NAME="ostream_iterator__traits_type"></A><CODE>ostream_iterator::traits_type</CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H2><A NAME="ostreambuf_iterator"></A><CODE>ostreambuf_iterator</CODE></H2>

<PRE>template&lt;class Elem, class Tr = char_traits&lt;Elem&gt; &gt;
    class <B>ostreambuf_iterator</B>
        : public iterator&lt;output_iterator_tag,
            void, void, void, void&gt; {
public:
    typedef Elem <B><A HREF="#ostreambuf_iterator__char_type">char_type</A></B>;
    typedef Tr <B><A HREF="#ostreambuf_iterator__traits_type">traits_type</A></B>;
    typedef basic_streambuf&lt;Elem, Tr&gt; <B><A HREF="#ostreambuf_iterator__streambuf_type">streambuf_type</A></B>;
    typedef basic_ostream&lt;Elem, Tr&gt; <B><A HREF="#ostreambuf_iterator__ostream_type">ostream_type</A></B>;

    <B><A HREF="#ostreambuf_iterator__ostreambuf_iterator">ostreambuf_iterator</A></B>(streambuf_type *stebuf) throw();
    <B><A HREF="#ostreambuf_iterator__ostreambuf_iterator">ostreambuf_iterator</A></B>(ostream_type&amp; ostr) throw();
    ostreambuf_iterator&amp; <B><A HREF="#ostreambuf_iterator__operator2">operator=</A></B>(Elem ch);
    ostreambuf_iterator&amp; <B><A HREF="#ostreambuf_iterator__operator*">operator*</A></B>();
    ostreambuf_iterator&amp; <B><A HREF="#ostreambuf_iterator__operator++">operator++</A></B>();
    T1 <B><A HREF="#ostreambuf_iterator__operator++">operator++</A></B>(int);
    bool <B><A HREF="#ostreambuf_iterator__failed">failed</A></B>() const throw();
    };</PRE>

<P>The template class describes an output iterator object.
It inserts elements of class <B><CODE>Elem</CODE></B>
into an <B>output stream buffer</B>,
which it accesses via an object it stores,
of type pointer to
<CODE>basic_streambuf&lt;Elem, Tr&gt;</CODE>.</P>


<H3><A NAME="ostreambuf_iterator__char_type"></A><CODE>ostreambuf_iterator::char_type</CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__failed"></A><CODE>ostreambuf_iterator::failed</CODE></H3>

<PRE>bool <B>failed</B>() const throw();</PRE>

<P>The member function returns true only if an insertion into the
output stream buffer has earlier failed.</P>

<H3><A NAME="ostreambuf_iterator__operator*"></A><CODE>ostreambuf_iterator::operator*</CODE></H3>

<PRE>ostreambuf_iterator&amp; <B>operator*</B>();</PRE>

<P>The operator returns <CODE>*this</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__operator++"></A><CODE>ostreambuf_iterator::operator++</CODE></H3>

<PRE>ostreambuf_iterator&amp; <B>operator++</B>();
T1 <B>operator++</B>(int);</PRE>

<P>The first operator returns <CODE>*this</CODE>. The second operator
returns an object of unspecified type <CODE>T1</CODE> that can be converted to
<CODE>ostreambuf_iterator&lt;Elem, Tr&gt;</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__operator2"></A><CODE>ostreambuf_iterator::operator=</CODE></H3>

<PRE>ostreambuf_iterator&amp; <B>operator=</B>(Elem ch);</PRE>

<P>The operator inserts <CODE>ch</CODE> into the associated stream buffer,
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__ostream_type"></A><CODE>ostreambuf_iterator::ostream_type</CODE></H3>

<PRE>typedef basic_ostream&lt;Elem, Tr&gt; <B>ostream_type</B>;</PRE>

<P>The type is a synonym for
<CODE>basic_ostream&lt;Elem,
Tr&gt;</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__ostreambuf_iterator"></A><CODE>ostreambuf_iterator::ostreambuf_iterator</CODE></H3>

<PRE><B>ostreambuf_iterator</B>(streambuf_type *strbuf) throw();
<B>ostreambuf_iterator</B>(ostream_type&amp; ostr) throw();</PRE>

<P>The first constructor initializes the output stream-buffer pointer
with <CODE>strbuf</CODE>.
The second constructor initializes the output stream-buffer pointer with
<CODE>ostr.rdbuf()</CODE>.
(The stored pointer must not be a null pointer.)</P>

<H3><A NAME="ostreambuf_iterator__streambuf_type"></A><CODE>ostreambuf_iterator::streambuf_type</CODE></H3>

<PRE>typedef basic_streambuf&lt;Elem, Tr&gt; <B>streambuf_type</B>;</PRE>

<P>The type is a synonym for <CODE>basic_streambuf&lt;Elem, Tr&gt;</CODE>.</P>

<H3><A NAME="ostreambuf_iterator__traits_type"></A><CODE>ostreambuf_iterator::traits_type</CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H2><A NAME="output_iterator_tag"></A><CODE>output_iterator_tag</CODE></H2>

<PRE>struct <B>output_iterator_tag</B> {
    };</PRE>

<P>The type is the same as
<CODE>iterator&lt;Iter&gt;::<A HREF="#iterator__iterator_category">iterator_category</A></CODE>
when <CODE>Iter</CODE> describes an object that can serve as a
output iterator.</P>

<H2><A NAME="prev"></A><CODE>prev</CODE></H2>

<PRE>template&lt;class BidIt&gt;
    BidIt <B>prev</B>(BidIt first,
        typename iterator_traits&lt;InIt&gt;::difference_type off = 1); <B>[added with C++11]</B></PRE>

<P>The template function returns <CODE>next</CODE> decremented
<CODE>off</CODE> times.</P>


<H2><A NAME="random_access_iterator_tag"></A><CODE>random_access_iterator_tag</CODE></H2>

<PRE>struct <B>random_access_iterator_tag</B>
    : public bidirectional_iterator_tag {
    };</PRE>

<P>The type is the same as
<CODE>iterator&lt;Iter&gt;::<A HREF="#iterator__iterator_category">iterator_category</A></CODE>
when <CODE>Iter</CODE> describes an object that can serve as a
random-access iterator.</P>

<H2><A NAME="reverse_iterator"></A><CODE>reverse_iterator</CODE></H2>

<PRE>template&lt;class RanIt&gt;
    class <B>reverse_iterator</B> : public iterator&lt;
        typename iterator_traits&lt;RanIt&gt;::iterator_category,
        typename iterator_traits&lt;RanIt&gt;::value_type,
        typename iterator_traits&lt;RanIt&gt;::difference_type,
        typename iterator_traits&lt;RanIt&gt;::pointer,
        typename iterator_traits&lt;RanIt&gt;::reference&gt; {
public:
    typedef typename iterator_traits&lt;RanIt&gt;::difference_type
        <B><A HREF="#reverse_iterator__difference_type">difference_type</A></B>;
    typedef typename iterator_traits&lt;RanIt&gt;::pointer
        <B><A HREF="#reverse_iterator__pointer">pointer</A></B>;
    typedef typename iterator_traits&lt;RanIt&gt;::reference
        <B><A HREF="#reverse_iterator__reference">reference</A></B>;
    typedef RanIt <B><A HREF="#reverse_iterator__iterator_type">iterator_type</A></B>;

    <B><A HREF="#reverse_iterator__reverse_iterator">reverse_iterator</A></B>();
    explicit <B><A HREF="#reverse_iterator__reverse_iterator">reverse_iterator</A></B>(RanIt right);
    template&lt;class Ty&gt;
        <B><A HREF="#reverse_iterator__reverse_iterator">reverse_iterator</A></B>(const reverse_iterator&lt;Ty&gt;&amp; right);

    RanIt <B><A HREF="#reverse_iterator__base">base</A></B>() const;
    reference <B><A HREF="#reverse_iterator__operator*">operator*</A></B>() const;
    pointer <B><A HREF="#reverse_iterator__operator-&gt;">operator-&gt;</A></B>() const;

    reverse_iterator&amp; <B><A HREF="#reverse_iterator__operator++">operator++</A></B>();
    reverse_iterator <B><A HREF="#reverse_iterator__operator++">operator++</A></B>(int);
    reverse_iterator&amp; <B><A HREF="#reverse_iterator__operator--">operator--</A></B>();
    reverse_iterator <B><A HREF="#reverse_iterator__operator--">operator--</A></B>();

    reverse_iterator&amp; <B><A HREF="#reverse_iterator__operator+2">operator+=</A></B>(difference_type off);
    reverse_iterator <B><A HREF="#reverse_iterator__operator+">operator+</A></B>(difference_type off) const;
    reverse_iterator&amp; <B><A HREF="#reverse_iterator__operator-2">operator-=</A></B>(difference_type off);
    reverse_iterator <B><A HREF="#reverse_iterator__operator-">operator-</A></B>(difference_type off) const;
    T1 <B><A HREF="#reverse_iterator__operator[]">operator[]</A></B>(difference_type off) const;

protected:
    RanIt <B>current</B>;
    };</PRE>

<P>The template class describes an object that behaves like a
random-access iterator, only in reverse. It stores a random-access iterator
of type <B><CODE>RanIt</CODE></B> in the protected object
<B><CODE><A NAME="reverse_iterator__current"></A>current</CODE></B>.
Incrementing the object <CODE>X</CODE> of type
<CODE>reverse_iterator</CODE>
decrements <CODE>X.current</CODE>, and decrementing <CODE>x</CODE>
increments <CODE>X.current</CODE>.
Moreover, the expression <CODE>*X</CODE> evaluates to
<CODE>*(current - 1)</CODE>,
of type <B><CODE>reference</CODE></B>. Typically, <CODE>reference</CODE> is
type <CODE>Tr&amp;</CODE>.</P>

<P>Thus, you can use an object of class
<CODE>reverse_iterator</CODE> to access in reverse
order a sequence that is traversed in order by a random-access
iterator.</P>

<P>Several STL <A HREF="lib_cont.html#Containers">containers</A> specialize
<CODE>reverse_iterator</CODE> for <CODE>RanIt</CODE> a bidirectional iterator.
In these cases, you must not call any of the member functions <CODE>operator+=</CODE>,
<CODE>operator+</CODE>, <CODE>operator-=</CODE>, <CODE>operator-</CODE>, or
<CODE>operator[]</CODE>.</P>

<H3><A NAME="reverse_iterator__base"></A><CODE>reverse_iterator::base</CODE></H3>

<PRE>RanIt <B>base</B>() const;</PRE>

<P>The member function returns
<CODE><A HREF="#reverse_iterator__current">current</A></CODE>.</P>

<H3><A NAME="reverse_iterator__difference_type"></A><CODE>reverse_iterator::difference_type</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::difference_type
    <B>difference_type</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::pointer</CODE>.</P>

<H3><A NAME="reverse_iterator__iterator_type"></A><CODE>reverse_iterator::iterator_type</CODE></H3>

<PRE>typedef RanIt <B>iterator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>RanIt</CODE>.</P>

<H3><A NAME="reverse_iterator__operator*"></A><CODE>reverse_iterator::operator*</CODE></H3>

<PRE>reference <B>operator*</B>() const;</PRE>

<P>The operator returns
<CODE>*(<A HREF="#reverse_iterator__current">current</A> - 1)</CODE>.</P>

<H3><A NAME="reverse_iterator__operator+"></A><CODE>reverse_iterator::operator+</CODE></H3>

<PRE>reverse_iterator <B>operator+</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>reverse_iterator(*this) += off</CODE>.</P>

<H3><A NAME="reverse_iterator__operator++"></A><CODE>reverse_iterator::operator++</CODE></H3>

<PRE>reverse_iterator&amp; <B>operator++</B>();
reverse_iterator <B>operator++</B>(int);</PRE>

<P>The first (preincrement) operator evaluates
<CODE>--<A HREF="#reverse_iterator__current">current</A></CODE>,
then returns <CODE>*this</CODE>.</P>

<P>The second (postincrement) operator makes a copy of <CODE>*this</CODE>,
evaluates <CODE>--current</CODE>, then returns the copy.</P>

<H3><A NAME="reverse_iterator__operator+2"></A><CODE>reverse_iterator::operator+=</CODE></H3>

<PRE>reverse_iterator&amp; <B>operator+=</B>(difference_type off);</PRE>

<P>The operator evaluates
<CODE><A HREF="#reverse_iterator__current">current</A> - off</CODE>.
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="reverse_iterator__operator-"></A><CODE>reverse_iterator::operator-</CODE></H3>

<PRE>reverse_iterator <B>operator-</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>reverse_iterator(*this) -= off</CODE>.</P>

<H3><A NAME="reverse_iterator__operator--"></A><CODE>reverse_iterator::operator--</CODE></H3>

<PRE>reverse_iterator&amp; <B>operator--</B>();
reverse_iterator <B>operator--</B>();</PRE>

<P>The first (predecrement) operator evaluates
<CODE>++<A HREF="#reverse_iterator__current">current</A></CODE>,
then returns <CODE>*this</CODE>.</P>

<P>The second (postdecrement) operator makes a copy of <CODE>*this</CODE>,
evaluates <CODE>++current</CODE>, then returns the copy.</P>

<H3><A NAME="reverse_iterator__operator-2"></A><CODE>reverse_iterator::operator-=</CODE></H3>

<PRE>reverse_iterator&amp; <B>operator-=</B>(difference_type off);</PRE>

<P>The operator evaluates
<CODE><A HREF="#reverse_iterator__current">current</A> + off</CODE>,
then returns <CODE>*this</CODE>.</P>

<H3><A NAME="reverse_iterator__operator-&gt;"></A><CODE>reverse_iterator::operator-&gt;</CODE></H3>

<PRE>pointer <B>operator-&gt;</B>() const;</PRE>

<P>The operator returns <CODE>&amp;**this</CODE>.</P>

<H3><A NAME="reverse_iterator__operator[]"></A><CODE>reverse_iterator::operator[]</CODE></H3>

<PRE>T1 <B>operator[]</B>(difference_type off) const;</PRE>

<P>The operator returns <CODE>*(*this + off)</CODE>, of unspecified type
<CODE>T1</CODE>.</P>

<H3><A NAME="reverse_iterator__pointer"></A><CODE>reverse_iterator::pointer</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::pointer
    <B>pointer</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::pointer</CODE>.</P>

<H3><A NAME="reverse_iterator__reference"></A><CODE>reverse_iterator::reference</CODE></H3>

<PRE>typedef typename iterator_traits&lt;RanIt&gt;::reference
    <B>reference</B>;</PRE>

<P>The type is a synonym for the iterator trait
<CODE>typename iterator_traits&lt;RanIt&gt;::reference</CODE>.</P>

<H3><A NAME="reverse_iterator__reverse_iterator"></A><CODE>reverse_iterator::reverse_iterator</CODE></H3>

<PRE><B>reverse_iterator</B>();
explicit <B>reverse_iterator</B>(RanIt right);
template&lt;class Ty&gt;
    <B><A HREF="#reverse_iterator__reverse_iterator">reverse_iterator</A></B>(const reverse_iterator&lt;Ty&gt;&amp; right);</PRE>

<P>The first constructor initializes
<CODE><A HREF="#reverse_iterator__current">current</A></CODE>
with its default constructor. The second constructor initializes
<CODE>current</CODE> with
<CODE>right.<A HREF="#reverse_iterator__current">current</A></CODE>.</P>

<P>The template constructor initializes <CODE>current</CODE>
with <CODE>right.<A HREF="#reverse_iterator__base">base</A>()</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &copy; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
