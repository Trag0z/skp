<HTML><HEAD>
<TITLE>&lt;stdlib.h&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;stdlib.h&gt;"></A><CODE>&lt;stdlib.h&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#EXIT_FAILURE">EXIT_FAILURE</A>
&middot; <A HREF="#EXIT_SUCCESS">EXIT_SUCCESS</A>
&middot; <A HREF="#MB_CUR_MAX">MB_CUR_MAX</A>
&middot; <A HREF="#NULL">NULL</A>
&middot; <A HREF="#RAND_MAX">RAND_MAX</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abort">abort</A>
&middot; <A HREF="#abs">abs</A>
&middot; <A HREF="#atexit">atexit</A>
&middot; <A HREF="#at_quick_exit">at_quick_exit</A>
&middot; <A HREF="#atof">atof</A>
&middot; <A HREF="#atoff">atoff</A>
&middot; <A HREF="#atoi">atoi</A>
&middot; <A HREF="#atol">atol</A>
&middot; <A HREF="#atoll">atoll</A>
&middot; <A HREF="#bsearch">bsearch</A>
&middot; <A HREF="#calloc">calloc</A>
&middot; <A HREF="#div">div</A>
&middot; <A HREF="#div_t">div_t</A>
&middot; <A HREF="#_Exit">_Exit</A>
&middot; <A HREF="#exit">exit</A>
&middot; <A HREF="#free">free</A>
&middot; <A HREF="#getargc">getargc</A>
&middot; <A HREF="#getargv">getargv</A>
&middot; <A HREF="#labs">labs</A>
&middot; <A HREF="#llabs">llabs</A>
&middot; <A HREF="#ldiv">ldiv</A>
&middot; <A HREF="#ldiv_t">ldiv_t</A>
&middot; <A HREF="#lldiv">lldiv</A>
&middot; <A HREF="#lldiv_t">lldiv_t</A>
&middot; <A HREF="#malloc">malloc</A>
&middot; <A HREF="#malloc_managed_size">malloc_managed_size</A>
&middot; <A HREF="#malloc_stats">malloc_stats</A>
&middot; <A HREF="#malloc_stats_fast">malloc_stats_fast</A>
&middot; <A HREF="#malloc_usable_size">malloc_usable_size</A>
&middot; <A HREF="#mblen">mblen</A>
&middot; <A HREF="#mbstowcs">mbstowcs</A>
&middot; <A HREF="#mbtowc">mbtowc</A>
&middot; <A HREF="#memalign">memalign</A>
&middot; <A HREF="#qsort">qsort</A>
&middot; <A HREF="#quick_exit">quick_exit</A>
&middot; <A HREF="#rand">rand</A>
&middot; <A HREF="#rand_r">rand_r</A>
&middot; <A HREF="#realloc">realloc</A>
&middot; <A HREF="#reallocalign">reallocalign</A>
&middot; <A HREF="#sceLibcSetHeapInitError">sceLibcSetHeapInitError</A>
&middot; <A HREF="#size_t">size_t</A>
&middot; <A HREF="#srand">srand</A>
&middot; <A HREF="#strtod">strtod</A>
&middot; <A HREF="#strtof">strtof</A>
&middot; <A HREF="#strtol">strtol</A>
&middot; <A HREF="#strtold">strtold</A>
&middot; <A HREF="#strtoll">strtoll</A>
&middot; <A HREF="#strtoul">strtoul</A>
&middot; <A HREF="#strtoull">strtoull</A>
&middot; <A HREF="#wchar_t">wchar_t</A>
&middot; <A HREF="#wcstombs">wcstombs</A>
&middot; <A HREF="#wctomb">wctomb</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abort_handler_s">abort_handler_s</A>
&middot; <A HREF="#bsearch_s">bsearch_s</A>
&middot; <A HREF="#constraint_handler_t">constraint_handler_t</A>
&middot; <A HREF="#errno_t">errno_t</A>
&middot; <A HREF="#ignore_handler_s">ignore_handler_s</A>
&middot; <A HREF="#mbstowcs_s">mbstowcs_s</A>
&middot; <A HREF="#qsort_s">qsort_s</A>
&middot; <A HREF="#rsize_t">rsize_t</A>
&middot; <A HREF="#set_constraint_handler_s">set_constraint_handler_s</A>
&middot; <A HREF="#wcstombs_s">wcstombs_s</A>
&middot; <A HREF="#wctomb_s">wctomb_s</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;stdlib.h&gt;</CODE></B> to declare an
assortment of useful functions and to define the macros and types
that help you use them.</P>

<PRE>    /* MACROS */
#define <A HREF="#EXIT_FAILURE"><B>EXIT_FAILURE</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#EXIT_SUCCESS"><B>EXIT_SUCCESS</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#MB_CUR_MAX"><B>MB_CUR_MAX</B></A> <I>&lt;rvalue integer expression &gt;= 1&gt;</I>
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#RAND_MAX"><B>RAND_MAX</B></A> <I>&lt;integer constant expression &gt;= 32,767&gt;</I>

    /* TYPES */
typedef struct {
    int quot, rem;
    } <A HREF="#div_t"><B>div_t</B></A>;
typedef struct {
    long quot, rem;
    } <A HREF="#ldiv_t"><B>ldiv_t</B></A>;
typedef struct { <B>[added with C99]</B>
    long long quot, rem;
    } <A HREF="#lldiv_t"><B>lldiv_t</B></A>;

struct <A HREF="#malloc_managed_size"><B>malloc_managed_size</B></A> { <B>[non-standard]</B>
  size_t max_system_size;
  size_t current_system_size;
  size_t max_inuse_size;
  size_t current_inuse_size;
  size_t reserved[4];
};

typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;
typedef <I>i-type</I> <A HREF="#wchar_t"><B>wchar_t</B></A>; <B>[keyword in C++]</B>

    /* FUNCTIONS */
int <A HREF="#abs"><B>abs</B></A>(int i);
long <A HREF="#abs"><B>abs</B></A>(long i); <B>[C++ only]</B>
long long <A HREF="#abs"><B>abs</B></A>(long long i); <B>[C++ only, added with C99]</B>
long long <A HREF="#llabs"><B>llabs</B></A>(long long i); <B>[added with C99]</B>
long <A HREF="#labs"><B>labs</B></A>(long i);

div_t <A HREF="#div"><B>div</B></A>(int numer, int denom);
ldiv_t <A HREF="#div"><B>div</B></A>(long numer, long denom); <B>[C++ only]</B>
lldiv_t <A HREF="#div"><B>div</B></A>(long long numer, long long denom); <B>[C++ only, added with C99]</B>
lldiv_t <A HREF="#lldiv"><B>lldiv</B></A>(long long numer, long long denom); <B>[added with C99]</B>
ldiv_t <A HREF="#ldiv"><B>ldiv</B></A>(long numer, long denom);

int <A HREF="#rand"><B>rand</B></A>(void);
void <A HREF="#srand"><B>srand</B></A>(unsigned int seed);
int <A HREF="#rand_r"><B>rand_r</B></A>(unsigned int *seedp); <B>[non-standard]</B>

double <A HREF="#atof"><B>atof</B></A>(const char *s);
float <A HREF="#atoff"><B>atoff</B></A>(const char *s); <B>[non-standard]</B>
int <A HREF="#atoi"><B>atoi</B></A>(const char *s);
long <A HREF="#atol"><B>atol</B></A>(const char *s);
long long <A HREF="#atoll"><B>atoll</B></A>(const char *s); <B>[added with C99]</B>

double <A HREF="#strtod"><B>strtod</B></A>(const char *restrict s, char **restrict endptr);
float <A HREF="#strtof"><B>strtof</B></A>(const char *restrict s, char **restrict endptr); <B>[added with C99]</B>
long double <A HREF="#strtold"><B>strtold</B></A>(const char *restrict s,
    char **restrict endptr); <B>[added with C99]</B>

long long <A HREF="#strtoll"><B>strtoll</B></A>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B>
unsigned long long <A HREF="#strtoull"><B>strtoull</B></A>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B>

long <A HREF="#strtol"><B>strtol</B></A>(const char *restrict s, char **restrict endptr, int base);
unsigned long <A HREF="#strtoul"><B>strtoul</B></A>(const char *restrict s, char **restrict endptr,
    int base);

void *<A HREF="#calloc"><B>calloc</B></A>(size_t nelem, size_t size);
void <A HREF="#free"><B>free</B></A>(void *ptr);
void *<A HREF="#malloc"><B>malloc</B></A>(size_t size);
void *<A HREF="#memalign"><B>memalign</B></A>(size_t boundary, size_t size); <B>[non-standard]</B>
void *<A HREF="#realloc"><B>realloc</B></A>(void *ptr, size_t size);
void *<A HREF="#reallocalign"><B>reallocalign</B></A>(void *ptr, size_t size, size_t boundary); <B>[non-standard]</B>
int <A HREF="#malloc_stats"><B>malloc_stats</B></A>(struct malloc_managed_size *mmsize); <B>[non-standard]</B>
int <A HREF="#malloc_stats_fast"><B>malloc_stats_fast</B></A>(struct malloc_managed_size *mmsize); <B>[non-standard]</B>
size_t <A HREF="#malloc_usable_size"><B>malloc_usable_size</B></A>(void* p); <B>[non-standard]</B>
void <A HREF="#sceLibcSetHeapInitError"><B>sceLibcSetHeapInitError</B></A>(unsigned int err_number); <B>[non-standard]</B>

int <A HREF="#mblen"><B>mblen</B></A>(const char *s, size_t n);
size_t <A HREF="#mbstowcs"><B>mbstowcs</B></A>(wchar_t *restrict wcs, const char *restrict s, size_t n);
int <A HREF="#mbtowc"><B>mbtowc</B></A>(wchar_t *restrict pwc, const char *restrict s, size_t n);
size_t <A HREF="#wcstombs"><B>wcstombs</B></A>(char *restrict s, const wchar_t *restrict wcs, size_t n);
int <A HREF="#wctomb"><B>wctomb</B></A>(char *s, wchar_t wchar);

void <A HREF="#_Exit"><B>_Exit</B></A>(int status) noexcept; <B>[added with C99]</B>
void <A HREF="#exit"><B>exit</B></A>(int status); <B>[does not return]</B>
void <A HREF="#abort"><B>abort</B></A>(void) noexcept; <B>[does not return]</B>
int <A HREF="#getargc"><B>getargc</B></A>(void); <B>[non-standard]</B>
char **<A HREF="#getargv"><B>getargv</B></A>(void); <B>[non-standard]</B>

extern "C++"
    int <A HREF="#atexit"><B>atexit</B></A>(void (*func)(void)) noexcept; <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    int <A HREF="#atexit"><B>atexit</B></A>(void (*func)(void)) noexcept;

void <A HREF="#quick_exit"><B>quick_exit</B></A>(int status) noexcept; <B>[does not return]</B> <B>[added with C++11]</B>
extern "C++"
    int <A HREF="#at_quick_exit"><B>at_quick_exit</B></A>(void (*func)(void)) noexcept; <B>[added with C++11]</B>
extern "C" <B>[C++ only]</B>
    int <A HREF="#at_quick_exit"><B>at_quick_exit</B></A>(void (*func)(void)) noexcept; <B>[added with C++11]</B>

extern "C++"
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce));

extern "C++"
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));

#if __STDC_WANT_LIB_EXT1__ <B>[added with <A HREF="index_ext1.html#TR24731">TR24731</A>]</B>
typedef void (*<A HREF="#constraint_handler_t"><B>constraint_handler_t</B></A>)(const char *restrict s,
    void *restrict p, errno_t errcode);
typedef int <A HREF="#errno_t"><B>errno_t</B></A>;
typedef size_t <A HREF="#rsize_t"><B>rsize_t</B></A>;

constraint_handler_t <A HREF="#set_constraint_handler_s"><B>set_constraint_handler_s</B></A>(
    constraint_handler_t new_hand);
void <A HREF="#abort_handler_s"><B>abort_handler_s</B></A>(const char *restrict s,
    void *restrict p, errno_t errcode);
void <A HREF="#ignore_handler_s"><B>ignore_handler_s</B></A>(const char *restrict s,
    void *restrict p, errno_t errcode);

errno_t <A HREF="#wctomb_s"><B>wctomb_s</B></A>(int *restrict pstat,
    char *restrict s, rsize_t maxsize, wchar_t wchar);
errno_t <A HREF="#mbstowcs_s"><B>mbstowcs_s</B></A>(size_t *restrict psize,
    wchar_t *restrict wcs, rsize_t maxsize,
    const char *restrict s, rsize_t n);
errno_t <A HREF="#wcstombs_s"><B>wcstombs_s</B></A>(size_t *restrict psize,
    char *restrict s, rsize_t maxsize,
    const wchar_t *restrict wcs, rsize_t n);

extern "C++"
    void *<A HREF="#bsearch_s"><B>bsearch_s</B></A>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce, void *context),
        void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<A HREF="#bsearch_s"><B>bsearch_s</B></A>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce, void *context),
        void *context);

extern "C++"
    errno_t <A HREF="#qsort_s"><B>qsort_s</B></A>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2, void *context),
        void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    errno_t <A HREF="#qsort_s"><B>qsort_s</B></A>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2, void *context),
        void *context);
#endif /* __STDC_WANT_LIB_EXT1__ */</PRE>

<H2><A NAME="abort"></A><CODE>abort</CODE></H2>

<PRE>void <B>abort</B>(void) noexcept; <B>[does not return]</B></PRE>

<P>The function is available only in &quot;Development Mode&quot; of Development Kit. See &quot;Programming Startup Guide&quot; for details.</P>

<P>The function causes abnormal
program termination and reports unsuccessful termination to the target
environment. The function calls
<CODE><A HREF="#_Exit">_Exit</A>(EXIT_FAILURE)</CODE>,
to report unsuccessful termination with
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>.</P>

<P><CODE>abort</CODE> never returns to its caller.</P>

<H2><A NAME="abort_handler_s"></A><CODE>abort_handler_s</CODE></H2>

<PRE>void <B>abort_handler_s</B>(const char *s, void *p,
    errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The function
writes <CODE>mesg</CODE> to the standard error stream and calls
<CODE><A HREF="#abort">abort</A></CODE>.
It can serve as a
<A HREF="index_ext1.html#constraint_handler">constraint handler</A>.</P>

<H2><A NAME="abs"></A><CODE>abs</CODE></H2>

<PRE>int <B>abs</B>(int i);
long <B>abs</B>(long i); <B>[C++ only]</B>
long long <B>abs</B>(long long i); <B>[C++ only, added with C99]</B></PRE>

<P>The function returns the absolute value of
<CODE>i</CODE>, <CODE>|i|</CODE>. The version that accepts
a <I>long</I> argument behaves the same as
<A HREF="#labs"><CODE>labs</CODE></A>. The version that accepts
a <I>long long</I> argument behaves the same as
<A HREF="#llabs"><CODE>llabs</CODE></A>.</P>

<H2><A NAME="atexit"></A><CODE>atexit</CODE></H2>

<PRE>extern "C++"
    int <B>atexit</B>(void (*func)(void)) noexcept; <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    int <B>atexit</B>(void (*func)(void)) noexcept;</PRE>

<P>The function registers the function whose address is <CODE>func</CODE>
to be called by
<A HREF="#exit"><CODE>exit</CODE></A> (or when
<A HREF="lib_over.html#main"><CODE>main</CODE></A> returns)
and returns zero if successful.
The functions are called in reverse order of registry. You can register at
least 32 functions.</P>

<P>Furthermore, in C++, if control leaves a called function because
it fails to handle a thrown exception, <CODE>terminate</CODE>
is called.</P>

<P>In C++, if static variables in functions and global variables have class types, their destructors are registered using this function.
They are counted as the number of registered functions.
Whether the registrations are successful or not is not tested.
Notice therefore that the destructor will just not be invoked in the failure case.</P>

<P>The function is thread safe.</P>

<H2><A NAME="at_quick_exit"></A><CODE>at_quick_exit</CODE></H2>

<PRE>extern "C++"
    int <B>at_quick_exit</B>(void (*func)(void)) noexcept; <B>[added with C++11]</B>
extern "C" <B>[C++ only]</B>
    int <B>at_quick_exit</B>(void (*func)(void)) noexcept; <B>[added with C++11]</B></PRE>

<P>The function registers the function whose address is <CODE>func</CODE>
to be called by
<A HREF="#quick_exit"><CODE>quick_exit</CODE></A>
and returns zero if successful.
The functions are called in reverse order of registry. You can register at
least 32 functions.</P>

<P>Furthermore, in C++, if control leaves a called function because
it fails to handle a thrown exception, <CODE>terminate</CODE>
is called.</P>

<P>The function is thread safe.</P>

<H2><A NAME="atof"></A><CODE>atof</CODE></H2>

<PRE>double <B>atof</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtod">strtod</A>(s, 0)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoff"></A><CODE>atoff</CODE></H2>

<PRE>float <B>atoff</B>(const char *s); <B>[non-standard]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>float</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtof">strtof</A>(s, 0)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoi"></A><CODE>atoi</CODE></H2>

<PRE>int <B>atoi</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>int</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE>(int)<A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atol"></A><CODE>atol</CODE></H2>

<PRE>long <B>atol</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoll"></A><CODE>atoll</CODE></H2>

<PRE>long long <B>atoll</B>(const char *s); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long long</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtoll">strtoll</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="bsearch"></A><CODE>bsearch</CODE></H2>

<PRE>extern "C++"
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
        int (*cmp)(const void *ck, const void *ce));</PRE>

<P>The function searches an array of ordered values and returns
the address of an array element that equals the search key <CODE>key</CODE>
(if one exists); otherwise, it returns a null pointer. The array consists
of <CODE>nelem</CODE> elements, each of <CODE>size</CODE> bytes,
beginning with the element whose address is <CODE>base</CODE>.</P>

<P><CODE>bsearch</CODE> calls the comparison function whose address is
<CODE>cmp</CODE> to compare the search key with elements of the array. The
comparison function must return:</P>

<UL>
<LI>a negative value if the search key <CODE>ck</CODE> is less than the
array element <CODE>ce</CODE></LI>

<LI>zero if the two are equal</LI>

<LI>a positive value if the search key is greater than the array
element</LI>
</UL>

<P><CODE>bsearch</CODE> assumes that the array elements are in nondescending
order according to the same comparison rules that are used by the
comparison function.</P>

<H2><A NAME="bsearch_s"></A><CODE>bsearch_s</CODE></H2>

<PRE>extern "C++"
    void *<B>bsearch_s</B>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce, void *context),
        void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<B>bsearch_s</B>(const void *key, const void *base,
        rsize_t nelem, rsize_t size,
        int (*cmp)(const void *ck, const void *ce, void *context),
        void *context); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>nelem</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>size</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>key</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>base</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>cmp</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a null pointer.</P>

<P>Otherwise, the function searches an array of ordered values and returns
the address of an array element that equals the search key <CODE>key</CODE>
(if one exists); otherwise, it returns a null pointer. The array consists
of <CODE>nelem</CODE> elements, each of <CODE>size</CODE> bytes,
beginning with the element whose address is <CODE>base</CODE>.</P>

<P><CODE>bsearch</CODE> calls the comparison function whose address is
<CODE>cmp</CODE> to compare the search key with elements of the array,
passing <CODE>context</CODE> as the third argument.
The comparison function must return:</P>

<UL>
<LI>a negative value if the search key <CODE>ck</CODE> is less than the
array element <CODE>ce</CODE></LI>

<LI>zero if the two are equal</LI>

<LI>a positive value if the search key is greater than the array
element</LI>
</UL>

<P><CODE>bsearch</CODE> assumes that the array elements are in nondescending
order according to the same comparison rules that are used by the
comparison function.</P>

<H2><A NAME="calloc"></A><CODE>calloc</CODE></H2>

<PRE>void *<B>calloc</B>(size_t nelem, size_t size);</PRE>

<P>The function allocates an array object containing <CODE>nelem</CODE>
elements each of size <CODE>size</CODE>, stores zeros in all bytes of the
array, and returns the address of the first element of the array if
successful; otherwise, it returns a null pointer. You can safely convert
the return value to an object pointer of any type whose size in bytes
is not greater than <CODE>size</CODE>.
The allocated object is guaranteed to be 16-byte aligned.</P>

<P>Even if <CODE>nelem</CODE> or <CODE>size</CODE> is zero, the function allocates a space, but the program cannot use it.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="constraint_handler_t"></A><CODE>constraint_handler_t</CODE></H2>

<PRE>typedef void (*<B>constraint_handler_t</B>(const char *restrict s,
    void *restrict p, errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The type describes a pointer to a function suitable for use as a
<A HREF="index_ext1.html#constraint_handler">constraint handler</A>.</P>

<H2><A NAME="div"></A><CODE>div</CODE></H2>

<PRE>div_t <B>div</B>(int numer, int denom);
ldiv_t <B>div</B>(long numer, long denom); <B>[C++ only]</B>
lldiv_t <B>div</B>(long long numer, long long denom); <B>[C++ only, added with C99]</B></PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="div_t"></A><CODE>div_t</CODE></H2>

<PRE>typedef struct {
    int quot, rem;
    } <B>div_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#div"><CODE>div</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>int.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="errno_t"></A><CODE>errno_t</CODE></H2>

<PRE>typedef int <B>errno_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <I>int,</I> used to represent
a value that can be stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="exit"></A><CODE>exit</CODE></H2>

<PRE>void <B>exit</B>(int status); <B>[does not return]</B></PRE>

<P>The function is available only in &quot;Development Mode&quot; of Development Kit. See &quot;Programming Startup Guide&quot; for details.</P>

<P>The function causes normal program termination to occur
and returns control to the target environment. If
<CODE>status</CODE> is zero or
<A HREF="#EXIT_SUCCESS"><CODE>EXIT_SUCCESS</CODE></A>,
the program reports successful termination. If <CODE>status</CODE> is
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>, the
program reports unsuccessful termination. An implementation can define
additional values for <CODE>status</CODE>.</P>

<P>This function executes the following process in that order, before it returns control to the target environment.</P>

<UL>
<LI>Call the functions which are registered by <A HREF="#atexit"><CODE>atexit</CODE></A>, including the global destructors.</LI>
<LI>Flush and close all open streams</LI>
</UL>

<P>It is not allowed to call this function from the <CODE>module_exit</CODE> function of a PRX.</P>

<P><CODE>exit</CODE> never returns to its caller.</P>

<H2><A NAME="_Exit"></A><CODE>_Exit</CODE></H2>

<PRE>void <B>_Exit</B>(int status) noexcept; <B>[does not return]</B> <B>[added with C99]</B></PRE>

<P>The function is available only in &quot;Development Mode&quot; of Development Kit. See &quot;Programming Startup Guide&quot; for details.</P>

<P>The function causes normal program termination to occur
and returns control to the target environment. The value of
<CODE>status</CODE> has the same effect as for a call to
<A HREF="#exit"><CODE>exit</CODE></A>. The function does <I>not</I>
call functions registered by
<A HREF="#atexit"><CODE>atexit</CODE></A>.</P>

<P>This function executes the following process, before it returns control to the target environment.</P>

<UL>
<LI>Flush and close all open streams</LI>
</UL>

<P><CODE>_Exit</CODE> never returns to its caller.</P>

<H2><A NAME="EXIT_FAILURE"></A><CODE>EXIT_FAILURE</CODE></H2>

<PRE>#define <B>EXIT_FAILURE</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports unsuccessful termination.</P>

<H2><A NAME="EXIT_SUCCESS"></A><CODE>EXIT_SUCCESS</CODE></H2>

<PRE>#define <B>EXIT_SUCCESS</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports successful termination.</P>

<H2><A NAME="free"></A><CODE>free</CODE></H2>

<PRE>void <B>free</B>(void *ptr);</PRE>

<P>If <CODE>ptr</CODE> is not a null pointer, the function deallocates
the object whose address is <CODE>ptr</CODE>; otherwise, it does nothing.
You can deallocate only objects that you first allocate by calling
the standard memory management functions
(<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>).</P>

<P>If <CODE>ptr</CODE> was not allocated or already freed, then <CODE>free</CODE>
will cause the current program to abort.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="getargc"></A><CODE>getargc</CODE></H2>

<PRE>int <B>getargc</B>(void); <B>[non-standard]</B></PRE>

<P>The function returns the value that will be passed to <CODE>main()</CODE> via parameter <CODE>argc</CODE>.</P>

<P>NOTE: The function can be called from global constructors in the C++ programming language.</P>

<H2><A NAME="getargv"></A><CODE>getargv</CODE></H2>

<PRE>char **<B>getargv</B>(void); <B>[non-standard]</B></PRE>

<P>The function returns the value that will be passed to <CODE>main()</CODE> via parameter <CODE>argv</CODE>.</P>

<P>NOTE: The function can be called from global constructors in the C++ programming language. The content of <CODE>argv</CODE> cannot be modified.</P>

<H2><A NAME="ignore_handler_s"></A><CODE>ignore_handler_s</CODE></H2>

<PRE>void <B>ignore_handler_s</B>(const char *s, void *p,
    errno_t errcode); <B>[added with TR24731]</B></PRE>

<P>The function simply returns.
It can serve as a
<A HREF="index_ext1.html#constraint_handler">constraint handler</A>.</P>

<H2><A NAME="labs"></A><CODE>labs</CODE></H2>

<PRE>long <B>labs</B>(long i);</PRE>

<P>The function returns the absolute value of <CODE>i</CODE>,
<CODE>|i|</CODE>, the same as
<A HREF="#abs"><CODE>abs</CODE></A>.</P>

<H2><A NAME="llabs"></A><CODE>llabs</CODE></H2>

<PRE>long long <B>llabs</B>(long long i); <B>[added with C99]</B></PRE>

<P>The function returns the absolute value of <CODE>i</CODE>,
<CODE>|i|</CODE>, the same as
<A HREF="#abs"><CODE>abs</CODE></A>.</P>

<H2><A NAME="ldiv"></A><CODE>ldiv</CODE></H2>

<PRE>ldiv_t <B>ldiv</B>(long numer, long denom);</PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="lldiv"></A><CODE>lldiv</CODE></H2>

<PRE>lldiv_t <B>lldiv</B>(long long numer, long long denom); <B>[added with C99]</B></PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="ldiv_t"></A><CODE>ldiv_t</CODE></H2>

<PRE>typedef struct {
    long quot, rem;
    } <B>ldiv_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#ldiv"><CODE>ldiv</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>long.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="lldiv_t"></A><CODE>lldiv_t</CODE></H2>

<PRE>typedef struct { <B>[added with C99]</B>
    long long quot, rem;
    } <B>lldiv_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#lldiv"><CODE>lldiv</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>long long.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="malloc"></A><CODE>malloc</CODE></H2>

<PRE>void *<B>malloc</B>(size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, and returns
the address of the object if successful; otherwise, it returns a null
pointer. The values stored in the object are indeterminate. You can
safely convert the return value to an object pointer of any type whose
size is not greater than <CODE>size</CODE>.
The allocated object is guaranteed to be 16-byte aligned.</P>

<P>Malloc is based on dlmalloc which is written by Doug Lea.
See <A HREF="index.html#DONG_LEA"><I>A Memory Allocator</I></A> for the detail of dlmalloc.</P>

<P>Even if <CODE>size</CODE> is zero, the function allocates a space, but the program cannot use it.</P>

<P>Memory blocks allocated by kernel are assigned as a malloc heap.
The unit size allocated by kernel is 64KiB by default.
Define global variable <CODE>sceLibcHeapUnitSize1MiB</CODE> and specify a non-zero value as shown in the example below to change the unit size to 1MiB.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapUnitSize1MiB = 1; /* Change the unit size to 1MiB */</PRE>

<P>The following four are provided as methods for allocation.
In any methods, the size of the area that is used for the heap can be specified.
The initial value is 256KiB if the unit size is 64KiB, and is 1MiB if it is 1MiB.
The size is set up in a multiple of the unit size.
If the specified size is not a multiple of the unit size, the used size is rounded up to a multiple of the unit size.</P>

<UL>
<LI>Fixed size allocation at process creation (default)

<P>A single memory block is allocated from the kernel at the process creation, and is assigned as a heap area.
The memory block once allocated is kept until the process termination.
It is never returned to the kernel during the program execution.</P>

<P>The size of the memory block for the heap area is statically set up at the program creation.
Since a single memory block with the set up size is allocated, the heap size cannot dynamically be changed during the program execution.</P>

<P>Define global variable <CODE>sceLibcHeapSize</CODE> and specify the number of bytes as shown in the example below to set up the size.
Without the definition, the initial value 256KiB is used.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapSize = 1*1024*1024; /* Set up heap area size as 1MiB */</PRE>

<P>To specify a value as small as possible to <CODE>sceLibcHeapSize</CODE> for the fixed size allocation, a value of the member <CODE>max_inuse_size</CODE> of the structure <A HREF="#malloc_managed_size"><CODE>malloc_managed_size</CODE></A> is helpful.
Since the areas shown by <CODE>max_inuse_size</CODE> are not continuous, the actual size required as the heap is larger than its value.
After the program is executed over a long time, the required size may be even larger, due to the heap fragmentation.
Therefore, please specify a size that is larger than the obtained value of <CODE>max_inuse_size</CODE> to <CODE>sceLibcHeapSize</CODE>, and decide whether or not the size is sufficient by adequate confirmation of the program execution.</P>

</LI>

<LI>Fixed size allocation at initial invocation of malloc

<P>The method is same as the above &quot;Fixed size allocation at process creation&quot; except for the timing of the allocation of a memory block.
The above method allocates a memory block at the process creation time, but this method allocates it at the time when malloc is called for the first time.</P>

<P>Define global variable <CODE>sceLibcHeapDelayedAlloc</CODE> and specify a non-zero value as shown in the example below.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapDelayedAlloc = 1;   /* Allocation at initial invocation of malloc */
unsigned int sceLibcHeapSize = 1*1024*1024; /* Set up heap area size as 1MiB */</PRE>

</LI>

<LI>Dynamic allocation

<P>The method allocates memory blocks from the kernel and dynamically extends the heap area if necessary when malloc is called.
If a memory block becomes unused by calling <CODE><A HREF="#free">free</A></CODE>, it is returned to the kernel.</P>

<P>Notice that the heap area is not guaranteed to be consecutive, because the heap area for malloc is aggregated by memory blocks.
For example, if the heap is fragmented, malloc may request further memory blocks from the kernel, even if there is enough total free space on the heap.</P>

<P>Define global variable <CODE>sceLibcHeapExtendedAlloc</CODE> and specify a non-zero value as shown in the example below for dynamic allocation.
The number of bytes specified for global variable <CODE>sceLibcHeapSize</CODE> represents the maximum total size of the memory blocks allocated by kernel.
If <CODE>sceLibcHeapSize</CODE> is not defined, the initial value 256KiB is used for the maximum total size.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapExtendedAlloc = 1;  /* Switch to dynamic allocation */
unsigned int sceLibcHeapSize = 1*1024*1024; /* Set up heap area upper limit as 1MiB */</PRE>

<P>To specify a value as small as possible to <CODE>sceLibcHeapSize</CODE> for the dynamic allocation, a value of the member <CODE>max_system_size</CODE> of the structure <A HREF="#malloc_managed_size"><CODE>malloc_managed_size</CODE></A> is helpful.
However, depending on the heap fragmentation, the value <CODE>max_system_size</CODE> may be larger after the program is executed over a long time.
Therefore, please specify a size that is larger than an obtained <CODE>max_system_size</CODE> to <CODE>sceLibcHeapSize</CODE>, and judge whether or not the size is sufficient by adequate confirmation of the program execution.</P>

<P>To disable the upper limit for the heap area, set <CODE>sceLibcHeapSize</CODE> as <CODE>SCE_LIBC_HEAP_SIZE_EXTENDED_ALLOC_NO_LIMIT</CODE>.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapExtendedAlloc = 1;  /* Switch to dynamic allocation */
unsigned int sceLibcHeapSize = SCE_LIBC_HEAP_SIZE_EXTENDED_ALLOC_NO_LIMIT; /* no upper limit for heap area */</PRE>

<P>This configuration extends the heap area as far as memory blocks can be allocated from the kernel.
The heap extension may prevent other memory allocations.
Please allocate necessary memory prior to heap extension.</P>

</LI>

<LI>Dynamic allocation with initial allocation size

<P>In addition to the previously described dynamic allocation, the method allocates a memory block with the size specified as the initial allocation size when the process is created or when malloc is called for the first time.</P>

<P>Define global variable <CODE>sceLibcHeapInitialSize</CODE> and specify the number of bytes as shown in the example below to specify the initial allocation size.
The size is set up in a multiple of the previously described unit size (64KiB or 1MiB).
If <CODE>sceLibcHeapSize &lt; sceLibcHeapInitialSize</CODE>, the process execution fails, and an error is displayed.</P>

<P>When using dynamic allocation, specify the initial allocation size as shown in the example below to allocate a memory block at the process creation.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapExtendedAlloc = 1; /* Switch to dynamic allocation */
unsigned int sceLibcHeapSize = 2 * 1024 * 1024; /* Set up heap area upper limit as 2MiB */
unsigned int sceLibcHeapInitialSize = 1 * 1024 * 1024; /* Set up initial allocation size as 1MiB */</PRE>

<P>The memory block allocated at the process creation is not returned to the kernel even when it becomes unused.</P>

<P>When using dynamic allocation, define global variable <CODE>sceLibcHeapDelayedAlloc</CODE>, specify a non-zero value, and also specify the initial allocation size as shown in the example below to allocate a memory block at the first invocation of malloc.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapExtendedAlloc = 1; /* Switch to dynamic allocation */
unsigned int sceLibcHeapDelayedAlloc = 1; /* Allocation at initial invocation of malloc */
unsigned int sceLibcHeapSize = 2 * 1024 * 1024; /* Set up heap area upper limit as 2MiB */
unsigned int sceLibcHeapInitialSize = 1 * 1024 * 1024; /* Set up initial allocation size as 1MiB */</PRE>

<P>The memory block allocated at the first invocation of malloc is not returned to the kernel even when it becomes unused.
As a special case, when the first malloc requires a memory block larger than the initial allocation size, two memory blocks are allocated: one has the initial allocation size, and the other is large enough for the first malloc.
The latter memory block is returned to the kernel when it becomes unused, as opposed to the former.</P>

<P>The upper limit for the heap area can be disabled.
See "Dynamic allocation" for the method and the notice.</P>

</LI>

</UL>

<P>This library has a feature of detecting buffer overruns of the allocated memory areas.
Define global variable <CODE>sceLibcHeapDetectOverrun</CODE> and specify a non-zero value as shown in the example below to enable the feature.</P>

<PRE>#include &lt;stdlib.h&gt;
unsigned int sceLibcHeapDetectOverrun = 1;</PRE>

<P>Buffer overrun detection is performed in <A HREF="#free"><CODE>free</CODE></A>, <A HREF="#realloc"><CODE>realloc</CODE></A>, and <A HREF="#reallocalign"><CODE>reallocalign</CODE></A>.
If detected, <A HREF="stdlib.html#abort"><CODE>abort</CODE></A> is invoked.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="malloc_managed_size"></A><CODE>malloc_managed_size</CODE></H2>

<PRE>struct <B>malloc_managed_size</B> { <B>[non-standard]</B>
  size_t max_system_size;
  size_t current_system_size;
  size_t max_inuse_size;
  size_t current_inuse_size;
  size_t reserved[4];
};</PRE>

<P>The type is the structure type passed to functions <A HREF="#malloc_stats"><CODE>malloc_stats</CODE></A> and <A HREF="#malloc_stats_fast"><CODE>malloc_stats_fast</CODE></A> as an argument.
This structure holds the information about the size of the memory areas that are allocated by the standard memory management functions (<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>). The value of each member in this structure means as follows:</P>

<UL>
<LI><B>max_system_size</B><BR>
The maximum amount of the memory areas that are obtained from the system.</LI>
<LI><B>current_system_size</B><BR>
The current size of the memory areas that are obtained from the system.</LI>
<LI><B>max_inuse_size</B><BR>
The maximum amount of the memory areas that are in use by the standard memory management functions.</LI>
<LI><B>current_inuse_size</B><BR>
The current size of the memory areas that are already in use by the standard memory management functions.</LI>
<LI><B>reserved</B><BR>
A reserved area. Do not use this member.</LI>
</UL>

<H3>Notice</H3>

<P>These values do not only represent the requested size to the standard memory management functions, but also include the size of padding which is needed to keep alignment, and the size of the memory area for memory management by the standard memory management functions. Therefore, these values are larger than the requested size.</P>

<P>After allocating each memory block from the kernel, areas of total 64 bytes are used for memory management.
<CODE>max_inuse_size</CODE> and <CODE>current_inuse_size</CODE> contain the size of these areas.
Therefore, <CODE>current_inuse_size</CODE> will be larger than 0 even if <A HREF="#free"><CODE>free</CODE></A> is called to all memory areas that are allocated by the standard memory management functions.</P>

<P>Because of the heap fragmentation, the areas that are shown by <CODE>max_inuse_size</CODE> or <CODE>current_inuse_size</CODE> are not a single continuous area.
Please note also that the free areas on the heap that are shown by <CODE>(current_system_size - current_inuse_size)</CODE> are not a single continuous area in the same way.</P>

<P>These values denote the memory areas that are managed by the standard memory management functions. Therefore, they will be different from the total memory consumption in the system.</P>

<H2><A NAME="malloc_stats"></A><CODE>malloc_stats</CODE></H2>

<PRE>int <B>malloc_stats</B>(struct malloc_managed_size *mmsize); <B>[non-standard]</B></PRE>

<P>This function obtains the information about the size of the memory areas that are allocated by the standard memory management functions (<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>). Furthermore, this function checks the memory areas for memory management. If only the information about the size of the memory areas is necessary, use <A HREF="#malloc_stats_fast"><CODE>malloc_stats_fast</CODE></A>. The information is returned via the specified structure <A HREF="#malloc_managed_size"><CODE>malloc_managed_size</CODE></A>. If <CODE>mmsize</CODE> is a null pointer, the information obtained by this function will be discarded.</P>

<P>It takes time depending on the number of allocated memory areas to check the memory areas for memory management by the standard memory management functions. If the area has a problem, the function call will fail.</P>

<P>On success, this function returns 0, otherwise it returns 1.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="malloc_stats_fast"></A><CODE>malloc_stats_fast</CODE></H2>

<PRE>int <B>malloc_stats_fast</B>(struct malloc_managed_size *mmsize); <B>[non-standard]</B></PRE>

<P>This function returns the information about the size of the memory areas faster than <A HREF="#malloc_stats"><CODE>malloc_stats</CODE></A>. As for the returned information via the specified structure <A HREF="#malloc_managed_size"><CODE>malloc_managed_size</CODE></A>, this function is equivalent to <CODE>malloc_stats</CODE>, if the function is called in the same timing.
If <CODE>mmsize</CODE> is a null pointer, the information obtained by this function will be discarded.</P>

<P>Unlike <CODE>malloc_stats</CODE>, this function does not check the memory areas for memory management by the standard memory management functions. To check it, use <CODE>malloc_stats</CODE>.</P>

<P>On success, this function returns 0, otherwise it returns 1.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="malloc_usable_size"></A><CODE>malloc_usable_size</CODE></H2>

<PRE>size_t <B>malloc_usable_size</B>(void* p); <B>[non-standard]</B></PRE>

<P>This function returns the number of bytes of the memory area which is allocated by the standard memory management functions (<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>). <CODE>p</CODE> must point to a memory area which is allocated by the standard memory management functions. If <CODE>p</CODE> is a null pointer, this function returns 0.</P>

<P>The standard memory management functions do not only allocate the requested size, but also allocate a memory area for padding which is needed to keep alignment. Therefore, the value returned by this function may be larger than the requested size.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="MB_CUR_MAX"></A><CODE>MB_CUR_MAX</CODE></H2>

<PRE>#define <B>MB_CUR_MAX</B> <I>&lt;rvalue integer expression &gt;= 1&gt;</I></PRE>

<P>The macro yields the maximum number of characters that constitute a
<A HREF="charset.html#Multibyte_Characters">multibyte character</A>
in the current
<A HREF="charset.html#locale">locale</A>. Its value is &lt;=
<A HREF="limits.html#MB_LEN_MAX"><CODE>MB_LEN_MAX</CODE></A>.</P>

<H2><A NAME="mblen"></A><CODE>mblen</CODE></H2>

<PRE>int <B>mblen</B>(const char *s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer, the function returns the
number of bytes in the multibyte string <CODE>s</CODE> that constitute the
next multibyte character, or it returns -1 if the next <CODE>n</CODE>
(or the remaining) bytes do not constitute a valid multibyte character.
<CODE>mblen</CODE> does not include the terminating null in the count of
bytes. The function can use a
<A HREF="charset.html#conversion_state">conversion state</A>
stored in an internal
static-duration object to determine how
to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent_encoding">state-dependent encoding</A>
in the current
<A HREF="charset.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<H2><A NAME="mbstowcs"></A><CODE>mbstowcs</CODE></H2>

<PRE>size_t <B>mbstowcs</B>(wchar_t *restrict wcs, const char *restrict s, size_t n);</PRE>

<P>The function stores a wide character string, in successive elements
of the array whose first element has the address <CODE>wcs</CODE>,
by converting, in turn, each of the multibyte characters
in the multibyte string <CODE>s</CODE>.
The string begins in the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
The function converts each character as if by calling
<A HREF="#mbtowc"><CODE>mbtowc</CODE></A> (except that
the internal conversion state stored for that function is unaffected).
It stores at most <CODE>n</CODE> wide characters, stopping after it stores
a null wide character. It returns the number of wide characters it
stores, not counting the null wide character, if all conversions are
successful; otherwise, it returns -1.</P>

<H2><A NAME="mbstowcs_s"></A><CODE>mbstowcs_s</CODE></H2>

<PRE>errno_t <B>mbstowcs_s</B>(size_t *restrict psize,
    wchar_t *restrict wcs, rsize_t maxsize,
    const char *restrict s, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>wcs</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>wcs</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>wcs</CODE> is not a null pointer and <CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>wcs</CODE> is not a null pointer and the wide-character sequence
generated by the function does not end with a null wide character within
the first <CODE>maxsize</CODE> elements</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>wcs</CODE>
is not a null pointer, the function
stores a null wide character at <CODE>wcs[0]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function stores a wide character string, in successive elements
of the array whose first element has the address <CODE>wcs</CODE>,
by converting, in turn, each of the multibyte characters
in the multibyte string <CODE>s</CODE>.
The string begins in the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
The function converts each character as if by calling
<A HREF="#mbtowc"><CODE>mbtowc</CODE></A> (except that
the internal conversion state stored for that function is unaffected).
It stores at most <CODE>maxsize</CODE> wide characters, stopping after it stores
a null wide character. If the conversion stores no null wide character,
and stores less than <CODE>maxsize</CODE> wide characters, the function
stores a null wide character at the end of the converted wide characters.</P>

<P>The function stores at <CODE>*psize</CODE> the number of converted
wide characters, not counting any terminating null wide character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="mbtowc"></A><CODE>mbtowc</CODE></H2>

<PRE>int <B>mbtowc</B>(wchar_t *restrict pwc, const char *restrict s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>x</CODE>,
the number of bytes in the multibyte string <CODE>s</CODE> that constitute
the next multibyte character.
(<CODE>x</CODE> cannot be greater than
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)
If <CODE>pwc</CODE> is not a null pointer, the function converts the next
multibyte character to its corresponding wide-character value and
stores that value in <CODE>*pwc</CODE>.
It then returns <CODE>x</CODE>, or it
returns -1 if the next <CODE>n</CODE> or the remaining bytes do not
constitute a valid multibyte character. <CODE>mbtowc</CODE> does not include
the terminating null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion_state">conversion state</A>
stored in an internal static-duration object to determine
how to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent_encoding">state-dependent encoding</A>
in the current
<A HREF="charset.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="memalign"></A><CODE>memalign</CODE></H2>

<PRE>void *<B>memalign</B>(size_t boundary, size_t size); <B>[non-standard]</B></PRE>

<P>The function allocates <CODE>size</CODE> bytes and returns a pointer to the
allocated memory.  The memory block returned will be aligned on a
multiple of <CODE>boundary</CODE>, if it is a power of two.  Otherwise, 
the nearest greater power will be used.
The pointers returned by the function may be released by calling 
<CODE>free</CODE>.</P>

<P>16 bytes alignment is guaranteed by normal <CODE>malloc</CODE> calls, so you 
should not call <CODE>memalign</CODE> with <CODE>boundary</CODE> 16 or less.</P>

<P>Even if <CODE>size</CODE> is zero, the function allocates a space, but the program cannot use it.</P>

<P>Applications can reduce fragmentation by minimizing the number of calls
to <CODE>memalign</CODE>.  For example, calling 
<CODE>memalign(64,4096)</CODE> four times to
create four buffers will cause more fragmentation than a single call to
<CODE>memalign(64,16384)</CODE>.  Doing large and/or aligned memory 
allocations first will also help to reduce fragmentation problems.  If 
the amount and size of the memory that is needed is known in advance, 
you can define the variables/structures in your source code and use 
compiler functions like __attribute__ aligned to align them.  This 
reduces overhead and will
improve the compilers ability to optimize code since it knows the
addresses, size and alignment of the memory at compile time.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="NULL"></A><CODE>NULL</CODE></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address_constant_expression">
address constant expression</A>.</P>

<H2><A NAME="qsort"></A><CODE>qsort</CODE></H2>

<PRE>extern "C++"
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));</PRE>

<P>The function sorts, in place, an array consisting of <CODE>nelem</CODE>
elements, each of <CODE>size</CODE> bytes, beginning with the element whose
address is <CODE>base</CODE>. It calls the comparison function whose address
is <CODE>cmp</CODE> to compare pairs of elements. The comparison function
must return a negative value if <CODE>e1</CODE> is less than <CODE>e2</CODE>,
zero if the two are equal, or a positive value if <CODE>e1</CODE> is greater
than <CODE>e2</CODE>. Two array elements that are equal can appear in the
sorted array in either order.</P>

<H2><A NAME="qsort_s"></A><CODE>qsort_s</CODE></H2>

<PRE>extern "C++"
    errno_t <B>qsort_s</B>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2, void *context),
        void *context); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    errno_t <B>qsort_s</B>(void *base, rsize_t nelem, rsize_t size,
        int (*cmp)(const void *e1, const void *e2, void *context),
        void *context); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>nelem</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>size</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>base</CODE> is a null pointer</LI>

<LI><CODE>nelem</CODE> is nonzero and <CODE>cmp</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function does nothing.</P>

<P>Otherwise, the function sorts, in place, an array consisting of <CODE>nelem</CODE>
elements, each of <CODE>size</CODE> bytes, beginning with the element whose
address is <CODE>base</CODE>. It calls the comparison function whose address
is <CODE>cmp</CODE> to compare pairs of elements,
passing <CODE>context</CODE> as the third argument. The comparison function
must return a negative value if <CODE>e1</CODE> is less than <CODE>e2</CODE>,
zero if the two are equal, or a positive value if <CODE>e1</CODE> is greater
than <CODE>e2</CODE>. Two array elements that are equal can appear in the
sorted array in either order.</P>

<H2><A NAME="quick_exit"></A><CODE>quick_exit</CODE></H2>

<PRE>void <B>quick_exit</B>(int status) noexcept; <B>[does not return]</B> <B>[added with C++11]</B></PRE>

<P>The function calls all functions registered by
<A HREF="#at_quick_exit"><CODE>at_quick_exit</CODE></A>,
closes all files, and terminates program execution.</P>

<P><CODE>quick_exit</CODE> never returns to its caller.</P>

<H2><A NAME="rand"></A><CODE>rand</CODE></H2>

<PRE>int <B>rand</B>(void);</PRE>

<P>The function computes a pseudo-random number <CODE>x</CODE> based
on a seed value stored in an internal static-duration object, alters
the stored seed value, and returns <CODE>x</CODE>.
<CODE>x</CODE> is in the interval [0,
<A HREF="#RAND_MAX"><CODE>RAND_MAX</CODE></A>].</P>
<P>The seed value can be stored in the internal static-duration object by calling <A HREF="#srand"><CODE>srand</CODE></A>.</P>
<P>The function is compatible with the <CODE>rand</CODE> function in newlib-1.12.0,
which is distributed in PSP&trade; (PlayStation&reg;Portable) SDK.  It has the following two characteristics:</P>
<OL>
<LI>The pseudo-random number is calculated by the followin expression:
<PRE>x = ((6364136223846793005 * seed + 1) >> 32) mod RAND_MAX
</PRE></LI>
<LI>The function uses a static-duration object, and thus is not multithread-safe.
When used in multithreaded environment, explicit mutual exclusion is necessary.</LI>
</OL>

<H2><A NAME="rand_r"></A><CODE>rand_r</CODE></H2>

<PRE>int <B>rand_r</B>(unsigned int *seedp); <B>[non-standard]</B></PRE>

<P>The function computes a pseudo-random number <CODE>x</CODE> based
on a seed value stored at <CODE>seedp</CODE>, alters
the stored seed value to <CODE>x.</CODE>, and returns <CODE>x.</CODE>
<CODE>x</CODE> is in the interval [0,
<A HREF="#RAND_MAX"><CODE>RAND_MAX</CODE></A>].</P>
<P>The function is compatible with the <CODE>rand_r</CODE> function in newlib-1.12.0,
which is distributed in PSP&trade; (PlayStation&reg;Portable) SDK.  It has the following two characteristics:</P>
<OL>
<LI>The pseudo-random number is calculated by the followin expression:
<PRE>x = (16807 * seed) mod RAND_MAX
</PRE>
If the seed is 0, 719435623 is returned.
If the seed is <CODE>RAND_MAX</CODE>, 0 is returned.</LI>
<LI>The function is multithread-safe.</LI>
</OL>

<H2><A NAME="RAND_MAX"></A><CODE>RAND_MAX</CODE></H2>

<PRE>#define <B>RAND_MAX</B> <I>&lt;integer constant expression &gt;= 32,767&gt;</I></PRE>

<P>The macro yields the maximum value returned by
<A HREF="#rand"><CODE>rand</CODE></A>.</P>

<H2><A NAME="realloc"></A><CODE>realloc</CODE></H2>

<PRE>void *<B>realloc</B>(void *ptr, size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, possibly
obtaining initial stored values from the object
whose address is <CODE>ptr</CODE>.
It returns the address of the new object if successful; otherwise,
it returns a null pointer. You can safely convert the return value
to an object pointer of any type
whose size is not greater than <CODE>size</CODE>.</P>

<P>If <CODE>ptr</CODE> is not a null pointer, it must be the address
of an existing object that you first allocate by calling
the standard memory management functions
(<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>).
If the existing object is not larger
than the newly allocated object, <CODE>realloc</CODE> copies the entire
existing object to the initial part of the allocated object. (The
values stored in the remainder of the object are indeterminate.) Otherwise,
the function copies only the initial part of the existing object that
fits in the allocated object. If <CODE>realloc</CODE> succeeds in allocating
a new object, it deallocates the existing object. Otherwise, the existing
object is left unchanged.</P>

<P>If <CODE>ptr</CODE> is a null pointer, the function does not store
initial values in the newly created object.</P>

<P>Even if <CODE>size</CODE> is zero, the function allocates a space, but the program cannot use it. Notice that this function will cause the current program to abort if <CODE>ptr</CODE> was not allocated or already freed.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="reallocalign"></A><CODE>reallocalign</CODE></H2>

<PRE>void *<B>reallocalign</B>(void *ptr, size_t size, size_t boundary); <B>[non-standard]</B></PRE>

<P>The function is similar to function <A HREF="#realloc"><CODE>realloc</CODE></A>, except memory address of allocated object is aligned by <CODE>boundary</CODE>. The function allocates an object of size <CODE>size</CODE>, possibly obtaining initial stored values from the object whose address is <CODE>ptr</CODE> if ptr is aligned by boundary. 
It returns the address of the new object if successful; otherwise,
it returns a null pointer. The return value can be safely converted
to an object pointer of any type
whose size is not greater than <CODE>size</CODE>.</P>

<P>If <CODE>ptr</CODE> is not a null pointer, it must be the address
of an existing object that was first allocated by the standard memory management functions
(<A HREF="#malloc">malloc</A>, <A HREF="#calloc">calloc</A>, <A HREF="#memalign">memalign</A>, <A HREF="#realloc">realloc</A>, <A HREF="#reallocalign">reallocalign</A>).
If the existing object is not larger
than the newly allocated object, <CODE>reallocalign</CODE> copies the entire
existing object to the initial part of the allocated object. (The
values stored in the remainder of the object are indeterminate.) Otherwise,
the function copies only the initial part of the existing object that
fits in the allocated object. If <CODE>reallocalign</CODE> succeeds in allocating
a new object, it deallocates the existing object. Otherwise, the existing
object is left unchanged.</P>

<P>If <CODE>ptr</CODE> is a null pointer, the function does not store
initial values in the newly created object.</P>

<P>If <CODE>boundary</CODE> is not a power of two, the nearest greater power will be used. And even if <CODE>size</CODE> is zero, the function allocates a space, but the program cannot use it. Notice that this function will cause the current program to abort if <CODE>ptr</CODE> was not allocated or already freed.</P>

<P>This function is replaceable.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="rsize_t"></A><CODE>rsize_t</CODE></H2>

<PRE>typedef size_t <B>rsize_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <CODE>size_t</CODE>,
used to represent a function argument to be checked on entry
to a function. It is a
<A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
for an argument of type <CODE>rsize_t</CODE> to be greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>.</P>

<H2><A NAME="sceLibcSetHeapInitError"></A><CODE>sceLibcSetHeapInitError</CODE></H2>

<PRE>void <B>sceLibcSetHeapInitError</B>(unsigned int err_number); <B>[non-standard]</B></PRE>

<P>The function is used when memory management functions are replaced.
It reports an error of the initialization of the user-defined memory management function to this library.
See &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Tutorial&quot;
and &quot;Memory Management Function Replacements of the C and C++ Standard Libraries: Reference&quot;
for details.</P>

<H2><A NAME="set_constraint_handler_s"></A><CODE>set_constraint_handler_s</CODE></H2>

<PRE>constraint_handler_t <B>set_constraint_handler_s</B>(
    constraint_handler_t new_hand); <B>[added with TR24731]</B></PRE>

<P>The function sets the pointer to the current
<A HREF="index_ext1.html#constraint_handler">constraint handler</A>
to <CODE>new_hand</CODE> and returns the previous pointer.</P>

<H2><A NAME="size_t"></A><CODE>size_t</CODE></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof_operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="srand"></A><CODE>srand</CODE></H2>

<PRE>void <B>srand</B>(unsigned int seed);</PRE>

<P>The function stores the seed value <CODE>seed</CODE>
in a static-duration object that
<A HREF="#rand"><CODE>rand</CODE></A>
uses to compute a pseudo-random number. From a given seed value,
that function always generates the same sequence of return
values. The program behaves as if the target environment calls
<CODE>srand(1)</CODE> at program startup.</P>

<H2><A NAME="strtod"></A><CODE>strtod</CODE></H2>

<PRE>double <B>strtod</B>(const char *restrict s, char **restrict endptr);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by the longest sequence of one or more characters that match
any part of the full pattern for <CODE>strtod</CODE> shown in the diagram.</P>

<P><IMG SRC="strtod0.gif"></P>

<P><B>Boldface</B> indicates a feature added with
C99.</P>

<P>Here, <CODE><I>inf</I></CODE> is the sequence of characters <CODE>inf</CODE>
or <CODE>infinity</CODE> with individual letters in either case,
to represent the special value infinity. Similarly, <CODE><I>nan</I></CODE>
is the sequence of characters <CODE>nan</CODE> or <CODE>nan(<I>qualifier</I>)</CODE>
with individual letters in either case, to represent the
special value not-a-number (NaN). A <CODE><I>qualifier</I></CODE> is any sequence
of zero or more letters, digits, and underscores. Each implementation defines
what effect, if any, a <CODE><I>qualifier</I></CODE> has on the actual encoding
of a NaN.</P>

<P>The pattern for a <CODE>strtod</CODE> hexadecimal string
is shown in the diagram.</P>

<P><IMG SRC="strtodx.gif"></P>

<P>Here, <CODE><I>hex</I></CODE> is a hexadecimal digit, in either case, and
a <CODE><I>point</I></CODE> is the
decimal-point
character for the current
<A HREF="charset.html#locale">locale</A>.
(It is the dot (<CODE>.</CODE>) in the
<A HREF="charset.html#C_locale"><CODE>"C"</CODE></A> locale.)
If the string <CODE>s</CODE> matches this pattern, its equivalent value
is the hexadecimal integer represented by any digits to the left of the
<CODE><I>point</I></CODE>, plus the hexadecimal fraction
represented by any digits to the right of the <CODE><I>point</I></CODE>,
times 2 raised to the signed decimal integer power
that follows an optional <CODE>p</CODE> or <CODE>P</CODE>. A leading
minus sign negates the value.</P>

<P>The pattern for a <CODE>strtod</CODE>
decimal string is shown in the diagram.</P>

<P><IMG SRC="strtod.gif"></P>

<P>Here, a <CODE><I>point</I></CODE> is the
decimal-point
character for the current
<A HREF="charset.html#locale">locale</A>.
(It is the dot (<CODE>.</CODE>) in the
<A HREF="charset.html#C_locale"><CODE>"C"</CODE></A> locale.)
If the string <CODE>s</CODE> matches this pattern, its equivalent value
is the decimal integer represented by any digits to the left of the
<CODE><I>point</I></CODE>, plus the decimal fraction
represented by any digits to the right of the <CODE><I>point</I></CODE>,
times 10 raised to the signed decimal integer power
that follows an optional <CODE>e</CODE> or <CODE>E</CODE>. A leading
minus sign negates the value.</P>

<P>In locales other than the
<A HREF="charset.html#C_locale"><CODE>"C"</CODE></A> locale,
<CODE>strtod</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtof"></A><CODE>strtof</CODE></H2>

<PRE>float <B>strtof</B>(const char *restrict s, char **restrict endptr); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>float.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>. <CODE>strtof</CODE> converts strings exactly as does
<A HREF="#strtod"><CODE>strtod</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtol"></A><CODE>strtol</CODE></H2>

<PRE>long <B>strtol</B>(const char *restrict s, char **restrict endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by the longest sequence of one or more characters that match
the pattern for <CODE>strtol</CODE> shown in the diagram.</P>

<P><IMG SRC="strtol.gif"></P>

<P>The function accepts the sequences
<CODE>0x</CODE> or <CODE>0X</CODE> only
when <CODE>base</CODE> equals zero or 16.
The letters <CODE>a-z</CODE> or <CODE>A-Z</CODE>
represent digits in the range [10, 36).
If <CODE>base</CODE> is in the range
[2, 36], the function accepts only digits
with values less than <CODE>base</CODE>.
If <CODE>base</CODE> == 0, then a leading <CODE>0x</CODE> or <CODE>0X</CODE>
(after any sign) indicates a hexadecimal (base 16) integer, a leading
<CODE>0</CODE> indicates an octal (base 8) integer, and any other valid
pattern indicates a decimal (base 10) integer.</P>

<P>If the string <CODE>s</CODE> matches this pattern, its equivalent
value is the signed integer of the appropriate base represented by
the digits that match the pattern. (A leading minus sign negates the
value.) In locales other than the
<A HREF="charset.html#C_locale"><CODE>"C"</CODE></A> locale,
<CODE>strtol</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>long,</I>
<CODE>strtol</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns either
<A HREF="limits.html#LONG_MAX"><CODE>LONG_MAX</CODE></A>,
if <CODE>x</CODE> is positive, or
<A HREF="limits.html#LONG_MIN"><CODE>LONG_MIN</CODE></A>,
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="strtold"></A><CODE>strtold</CODE></H2>

<PRE>long double <B>strtold</B>(const char *restrict s,
    char **restrict endptr); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long double.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>. <CODE>strtold</CODE> converts strings exactly as does
<A HREF="#strtod"><CODE>strtod</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range_error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtoll"></A><CODE>strtoll</CODE></H2>

<PRE>long long <B>strtoll</B>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.
<CODE>strtoll</CODE> converts strings exactly as does
<A HREF="#strtol"><CODE>strtol</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>long long,</I>
<CODE>strtoll</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns either
<A HREF="limits.html#LLONG_MAX"><CODE>LLONG_MAX</CODE></A>,
if <CODE>x</CODE> is positive, or
<A HREF="limits.html#LLONG_MIN"><CODE>LLONG_MIN</CODE></A>,
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="strtoul"></A><CODE>strtoul</CODE></H2>

<PRE>unsigned long <B>strtoul</B>(const char *restrict s, char **restrict endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>unsigned long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P><CODE>strtoul</CODE> converts strings exactly as does
<A HREF="#strtol"><CODE>strtol</CODE></A>,
but reports a range error only if the equivalent value is too large
to represent as type <I>unsigned long.</I>
In this case, <CODE>strtoul</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULONG_MAX"><CODE>ULONG_MAX</CODE></A>.</P>

<H2><A NAME="strtoull"></A><CODE>strtoull</CODE></H2>

<PRE>unsigned long long <B>strtoull</B>(const char *restrict s, char **restrict endptr,
    int base); <B>[added with C99]</B></PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>unsigned long long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.
<CODE>strtoull</CODE> converts strings exactly as does
<A HREF="#strtoul"><CODE>strtoul</CODE></A>.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>unsigned long long,</I>
<CODE>strtoull</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULLONG_MAX"><CODE>ULLONG_MAX</CODE></A>.</P>

<H2><A NAME="wchar_t"></A><CODE>wchar_t</CODE></H2>

<PRE>typedef <I>i-type</I> <B>wchar_t</B>; <B>[keyword in C++]</B></PRE>

<P>The type is the integer type <CODE><I>i-type</I></CODE> of a
<A HREF="charset.html#wide-character_constant">
wide-character constant</A>, such as <CODE>L'X'</CODE>.
You declare an object of type <CODE>wchar_t</CODE> to hold a
<A HREF="charset.html#Wide-Character_Encoding">wide character</A>.</P>

<H2><A NAME="wcstombs"></A><CODE>wcstombs</CODE></H2>

<PRE>size_t <B>wcstombs</B>(char *restrict s, const wchar_t *restrict wcs, size_t n);</PRE>

<P>The function stores a multibyte string, in successive elements
of the array whose first element has the address <CODE>s</CODE>,
by converting in turn each of the wide characters
in the string <CODE>wcs</CODE>. The multibyte string begins in the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
The function converts each wide character as if by calling
<A HREF="#wctomb"><CODE>wctomb</CODE></A> (except that the
<A HREF="charset.html#conversion_state">conversion state</A>
stored for that function is unaffected). It stores no
more than <CODE>n</CODE> bytes, stopping after it stores a null character. It
returns the number of bytes it stores, not counting the null character,
if all conversions are successful; otherwise, it returns -1.</P>

<H2><A NAME="wcstombs_s"></A><CODE>wcstombs_s</CODE></H2>

<PRE>errno_t <B>wcstombs_s</B>(size_t *restrict psize,
    char *restrict s, rsize_t maxsize,
    const wchar_t *restrict wcs, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is not a null pointer and <CODE>maxsize</CODE>
is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>psize</CODE> is a null pointer</LI>

<LI><CODE>wcs</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is not a null pointer and <CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>s</CODE> is not a null pointer and the multibyte sequence
generated by the function does not end with a null character within
the first <CODE>maxsize</CODE> elements</LI>
</UL>

<P>If such a violation occurs, other than the first one, and <CODE>s</CODE>
is not a null pointer, the function
stores a null character at <CODE>s[0]</CODE>.
If <CODE>psize</CODE> is not a null pointer, the function stores
<CODE>(rsize_t)-1</CODE> in <CODE>*psize</CODE>.
It returns the error code it reported to the constraint handler.</P>

<P>Otherwise, the function stores a multibyte string, in successive elements
of the array whose first element has the address <CODE>s</CODE>,
by converting in turn each of the wide characters
in the string <CODE>wcs</CODE>. The multibyte string begins in the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>.
The function converts each wide character as if by calling
<A HREF="#wctomb"><CODE>wctomb</CODE></A> (except that the
<A HREF="charset.html#conversion_state">conversion state</A>
stored for that function is unaffected). It stores no
more than <CODE>maxsize</CODE> bytes, stopping after it stores a null character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.
If the conversion stores no null character,
and stores less than <CODE>maxsize</CODE> characters, the function
stores a null character at the end of the converted characters.</P>

<P>The function stores at <CODE>*psize</CODE> the number of converted
characters, not counting any terminating null character.
It returns zero if all conversions are
successful; otherwise, it returns a nonzero value.</P>

<H2><A NAME="wctomb"></A><CODE>wctomb</CODE></H2>

<PRE>int <B>wctomb</B>(char *s, wchar_t wchar);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>N</CODE>,
the number of bytes needed to represent
the multibyte character corresponding
to the wide character <CODE>wchar</CODE>.
<CODE>N</CODE> cannot exceed
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.
The function converts <CODE>wchar</CODE> to its corresponding multibyte
character, which it stores in successive elements of the array whose
first element has the address <CODE>s</CODE>.
It then returns <CODE>N</CODE>, or it returns -1
if <CODE>wchar</CODE> does not correspond to a valid
multibyte character. <CODE>wctomb</CODE> includes the terminating
null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion_state">conversion state</A>
stored in a static-duration object to determine how to interpret the
multibyte character string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent_encoding">state-dependent encoding</A>
in the current
<A HREF="charset.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
in its static-duration object and returns
nonzero; otherwise, it returns zero.</P>

<P>The function is not necessarily thread safe.</P>

<H2><A NAME="wctomb_s"></A><CODE>wctomb_s</CODE></H2>

<PRE>errno_t <B>wctomb_s</B>(int *restrict pstat,
    char *restrict s, rsize_t maxsize, wchar_t wchar); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>pstat</CODE> is a null pointer</LI>

<LI><CODE>s</CODE> is not a null pointer and <CODE>maxsize</CODE> is
less than <CODE>N</CODE>, the number of bytes needed to represent
the multibyte character corresponding to the wide character
<CODE>wchar</CODE> (<CODE>N</CODE> cannot exceed
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)</LI>

<LI><CODE>s</CODE> is a null pointer and <CODE>maxsize</CODE> is nonzero</LI>

<LI><CODE>maxsize</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>
</UL>

<P>If such a violation occurs, and <CODE>s</CODE> is not a null
pointer, the function accesses at most the first <CODE>N</CODE> characters
beginning at <CODE>s</CODE>. The function does not store
anything into <CODE>*pstat</CODE>. It returns the error code
it reported to the constraint handler.</P>

<P>Otherwise, if <CODE>s</CODE> is not a null pointer:</P>

<UL>
<LI>the function converts <CODE>wchar</CODE> to its corresponding multibyte
character, which it stores in successive elements of the array whose
first element has the address <CODE>s</CODE></LI>

<LI>it stores in <CODE>*pstat</CODE> either <CODE>N</CODE>,
if <CODE>wchar</CODE> corresponds to a valid multibyte character,
or -1.</LI>
</UL>

<P><CODE>wctomb_s</CODE> includes the terminating
null character in the count of bytes. The function can use a
<A HREF="charset.html#conversion_state">conversion state</A>
stored in a static-duration object to determine how to interpret the
multibyte character string.</P>

<P>If <CODE>s</CODE> is a null pointer:</P>

<UL>
<LI>if multibyte characters have a
<A HREF="charset.html#state-dependent_encoding">state-dependent encoding</A>
in the current
<A HREF="charset.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial_conversion_state">initial conversion state</A>
in its static-duration object, stores a nonzero value in <CODE>*pstat</CODE>
and returns a nonzero value</LI>

<LI>otherwise, the function stores zero in <CODE>*pstat</CODE>
and returns zero.</LI>
</UL>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
&copy; 2014 Sony Computer Entertainment Inc. All rights reserved.</I></P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
