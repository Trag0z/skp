<HTML><HEAD>
<TITLE>&lt;stdio.h&gt; -- C and C++ Standard Libraries:&nbsp;&nbsp;Overview and Reference</TITLE>
<meta name="Microsoft.Help.Locale" content="en-us">
<meta name="Microsoft.Help.TopicLocale" content="en-us">
</HEAD><BODY>

<H1><A NAME="&lt;stdio.h&gt;"></A><CODE>&lt;stdio.h&gt;</CODE></H1><HR>

<P><B><CODE><A HREF="#_IOFBF">_IOFBF</A>
&middot; <A HREF="#_IOLBF">_IOLBF</A>
&middot; <A HREF="#_IONBF">_IONBF</A>
&middot; <A HREF="#BUFSIZ">BUFSIZ</A>
&middot; <A HREF="#EOF">EOF</A>
&middot; <A HREF="#FILE">FILE</A>
&middot; <A HREF="#FILENAME_MAX">FILENAME_MAX</A>
&middot; <A HREF="#FOPEN_MAX">FOPEN_MAX</A>
&middot; <A HREF="#NULL">NULL</A>
&middot; <A HREF="#SEEK_CUR">SEEK_CUR</A>
&middot; <A HREF="#SEEK_END">SEEK_END</A>
&middot; <A HREF="#SEEK_SET">SEEK_SET</A>
</CODE></B></P>

<P><B><CODE><A HREF="#clearerr">clearerr</A>
&middot; <A HREF="#fclose">fclose</A>
&middot; <A HREF="#fdopen">fdopen</A>
&middot; <A HREF="#feof">feof</A>
&middot; <A HREF="#ferror">ferror</A>
&middot; <A HREF="#fflush">fflush</A>
&middot; <A HREF="#fgetc">fgetc</A>
&middot; <A HREF="#fgetpos">fgetpos</A>
&middot; <A HREF="#fgets">fgets</A>
&middot; <A HREF="#fileno">fileno</A>
&middot; <A HREF="#fopen">fopen</A>
&middot; <A HREF="#fpos_t">fpos_t</A>
&middot; <A HREF="#fprintf">fprintf</A>
&middot; <A HREF="#fputc">fputc</A>
&middot; <A HREF="#fputs">fputs</A>
&middot; <A HREF="#fread">fread</A>
&middot; <A HREF="#freopen">freopen</A>
&middot; <A HREF="#fscanf">fscanf</A>
&middot; <A HREF="#fseek">fseek</A>
&middot; <A HREF="#fsetpos">fsetpos</A>
&middot; <A HREF="#ftell">ftell</A>
&middot; <A HREF="#fwrite">fwrite</A>
&middot; <A HREF="#getc">getc</A>
&middot; <A HREF="#getchar">getchar</A>
&middot; <A HREF="#gets">gets</A>
&middot; <A HREF="#perror">perror</A>
&middot; <A HREF="#printf">printf</A>
&middot; <A HREF="#putc">putc</A>
&middot; <A HREF="#putchar">putchar</A>
&middot; <A HREF="#puts">puts</A>
&middot; <A HREF="#remove">remove</A>
&middot; <A HREF="#rename">rename</A>
&middot; <A HREF="#rewind">rewind</A>
&middot; <A HREF="#scanf">scanf</A>
&middot; <A HREF="#setbuf">setbuf</A>
&middot; <A HREF="#setvbuf">setvbuf</A>
&middot; <A HREF="#size_t">size_t</A>
&middot; <A HREF="#snprintf">snprintf</A>
&middot; <A HREF="#sprintf">sprintf</A>
&middot; <A HREF="#sscanf">sscanf</A>
&middot; <A HREF="#stderr">stderr</A>
&middot; <A HREF="#stdin">stdin</A>
&middot; <A HREF="#stdout">stdout</A>
&middot; <A HREF="#ungetc">ungetc</A>
&middot; <A HREF="#vfprintf">vfprintf</A>
&middot; <A HREF="#vfscanf">vfscanf</A>
&middot; <A HREF="#vprintf">vprintf</A>
&middot; <A HREF="#vscanf">vscanf</A>
&middot; <A HREF="#vsnprintf">vsnprintf</A>
&middot; <A HREF="#vsprintf">vsprintf</A>
&middot; <A HREF="#vsscanf">vsscanf</A>
</CODE></B></P>

<P><B><CODE><A HREF="#sceLibcFopenWithFD">sceLibcFopenWithFD</A>
&middot; <A HREF="#sceLibcFopenWithFH">sceLibcFopenWithFH</A>
&middot; <A HREF="#sceLibcGetFD">sceLibcGetFD</A>
&middot; <A HREF="#sceLibcGetFH">sceLibcGetFH</A>
</CODE></B></P>

<P><B><CODE><A HREF="#errno_t">errno_t</A>
&middot; <A HREF="#fopen_s">fopen_s</A>
&middot; <A HREF="#fprintf_s">fprintf_s</A>
&middot; <A HREF="#freopen_s">freopen_s</A>
&middot; <A HREF="#gets_s">gets_s</A>
&middot; <A HREF="#fscanf_s">fscanf_s</A>
&middot; <A HREF="#printf_s">printf_s</A>
&middot; <A HREF="#rsize_t">rsize_t</A>
&middot; <A HREF="#scanf_s">scanf_s</A>
&middot; <A HREF="#snprintf_s">snprintf_s</A>
&middot; <A HREF="#sprintf_s">sprintf_s</A>
&middot; <A HREF="#sscanf_s">sscanf_s</A>
&middot; <A HREF="#vfprintf_s">vfprintf_s</A>
&middot; <A HREF="#vfscanf_s">vfscanf_s</A>
&middot; <A HREF="#vprintf_s">vprintf_s</A>
&middot; <A HREF="#vscanf_s">vscanf_s</A>
&middot; <A HREF="#vsnprintf_s">vsnprintf_s</A>
&middot; <A HREF="#vsprintf_s">vsprintf_s</A>
&middot; <A HREF="#vsscanf_s">vsscanf_s</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;stdio.h&gt;</CODE></B>
so that you can perform input and output operations on streams and files.</P>

<PRE>    /* MACROS */
#define <A HREF="#_IOFBF"><B>_IOFBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#_IOLBF"><B>_IOLBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#_IONBF"><B>_IONBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#BUFSIZ"><B>BUFSIZ</B></A> <I>&lt;integer constant expression &gt;= 256&gt;</I>
#define <A HREF="#EOF"><B>EOF</B></A> <I>&lt;integer constant expression &lt; 0&gt;</I>
#define <A HREF="#FILENAME_MAX"><B>FILENAME_MAX</B></A> <I>&lt;integer constant expression &gt; 0&gt;</I>
#define <A HREF="#FOPEN_MAX"><B>FOPEN_MAX</B></A> <I>&lt;integer constant expression &gt;= 8&gt;</I>
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#SEEK_CUR"><B>SEEK_CUR</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#SEEK_END"><B>SEEK_END</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#SEEK_SET"><B>SEEK_SET</B></A> <I>&lt;integer constant expression&gt;</I>

#define <A HREF="#stderr"><B>stderr</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>
#define <A HREF="#stdin"><B>stdin</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>
#define <A HREF="#stdout"><B>stdout</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>

    /* TYPES */
typedef <I>o-type</I> <A HREF="#FILE"><B>FILE</B></A>;
typedef <I>o-type</I> <A HREF="#fpos_t"><B>fpos_t</B></A>;
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;

    /* FUNCTIONS */
void <A HREF="#clearerr"><B>clearerr</B></A>(FILE *stream);
int <A HREF="#fclose"><B>fclose</B></A>(FILE *stream);
int <A HREF="#feof"><B>feof</B></A>(FILE *stream);
int <A HREF="#ferror"><B>ferror</B></A>(FILE *stream);
int <A HREF="#fflush"><B>fflush</B></A>(FILE *stream);
FILE *<A HREF="#fopen"><B>fopen</B></A>(const char *restrict filename, const char *restrict mode);
FILE *<A HREF="#freopen"><B>freopen</B></A>(const char *restrict filename, const char *restrict mode,
    FILE *stream);
int <A HREF="#remove"><B>remove</B></A>(const char *filename);
int <A HREF="#rename"><B>rename</B></A>(const char *old, const char *new);
void <A HREF="#rewind"><B>rewind</B></A>(FILE *stream);
void <A HREF="#setbuf"><B>setbuf</B></A>(FILE *restrict stream, char *restrict buf);
int <A HREF="#setvbuf"><B>setvbuf</B></A>(FILE *restrict stream, char *restrict buf, int mode,
    size_t size);

int <A HREF="#fseek"><B>fseek</B></A>(FILE *stream, long offset, int mode);
int <A HREF="#fsetpos"><B>fsetpos</B></A>(FILE *stream, const fpos_t *pos);
int <A HREF="#fgetpos"><B>fgetpos</B></A>(FILE *restrict stream, fpos_t *restrict pos);
long <A HREF="#ftell"><B>ftell</B></A>(FILE *stream);

int <A HREF="#fgetc"><B>fgetc</B></A>(FILE *stream);
char *<A HREF="#fgets"><B>fgets</B></A>(char *restrict s, int n, FILE *restrict stream);
size_t <A HREF="#fread"><B>fread</B></A>(void *restrict ptr,
    size_t size, size_t nelem, FILE *restrict stream);
int <A HREF="#getc"><B>getc</B></A>(FILE *stream);
int <A HREF="#getchar"><B>getchar</B></A>(void);
char *<A HREF="#gets"><B>gets</B></A>(char *s);
int <A HREF="#ungetc"><B>ungetc</B></A>(int c, FILE *stream);

int <A HREF="#fputc"><B>fputc</B></A>(int c, FILE *stream);
int <A HREF="#fputs"><B>fputs</B></A>(const char *restrict s, FILE *restrict stream);
size_t <A HREF="#fwrite"><B>fwrite</B></A>(const void *restrict ptr,
    size_t size, size_t nelem, FILE *restrict stream);
void <A HREF="#perror"><B>perror</B></A>(const char *s);
int <A HREF="#putc"><B>putc</B></A>(int c, FILE *stream);
int <A HREF="#putchar"><B>putchar</B></A>(int c);
int <A HREF="#puts"><B>puts</B></A>(const char *s);

int <A HREF="#fscanf"><B>fscanf</B></A>(FILE *restrict stream, const char *restrict format, ...);
int <A HREF="#scanf"><B>scanf</B></A>(const char *restrict format, ...);
int <A HREF="#sscanf"><B>sscanf</B></A>(const char *restrict s, const char *restrict format, ...);
int <A HREF="#vfscanf"><B>vfscanf</B></A>(FILE *restrict stream, const char *restrict format,
    va_list ap); <B>[added with C99]</B>
int <A HREF="#vscanf"><B>vscanf</B></A>(const char *restrict format,
    va_list ap); <B>[added with C99]</B>
int <A HREF="#vsscanf"><B>vsscanf</B></A>(const char *restrict s, const char *restrict format,
    va_list ap); <B>[added with C99]</B>

int <A HREF="#fprintf"><B>fprintf</B></A>(FILE *restrict stream, const char *restrict format, ...);
int <A HREF="#printf"><B>printf</B></A>(const char *restrict format, ...);
int <A HREF="#snprintf"><B>snprintf</B></A>(char *restrict s, size_t n,
    const char *restrict format, ...); <B>[added with C99]</B>
int <A HREF="#sprintf"><B>sprintf</B></A>(char *restrict s, const char *restrict format, ...);
int <A HREF="#vfprintf"><B>vfprintf</B></A>(FILE *restrict stream, const char *restrict format,
    va_list ap);
int <A HREF="#vprintf"><B>vprintf</B></A>(const char *restrict format,
    va_list ap);
int <A HREF="#vsnprintf"><B>vsnprintf</B></A>(char *restrict s, size_t n, const char *restrict format,
    va_list ap); <B>[added with C99]</B>
int <A HREF="#vsprintf"><B>vsprintf</B></A>(char *restrict s, const char *restrict format,
    va_list ap);

FILE *<A HREF="#fdopen"><B>fdopen</B></A>(int fd, const char *mode); <B>[non-standard]</B>
int <A HREF="#fileno"><B>fileno</B></A>(FILE *stream); <B>[non-standard]</B>

FILE *<A HREF="#sceLibcFopenWithFD"><B>sceLibcFopenWithFD</B></A>(int fd, const char *mode); <B>[non-standard]</B>
FILE *<A HREF="#sceLibcFopenWithFH"><B>sceLibcFopenWithFH</B></A>(int fh, const char *mode); <B>[non-standard]</B>
int <A HREF="#sceLibcGetFD"><B>sceLibcGetFD</B></A>(FILE *stream); <B>[non-standard]</B>
int <A HREF="#sceLibcGetFH"><B>sceLibcGetFH</B></A>(FILE *stream); <B>[non-standard]</B>

#if __STDC_WANT_LIB_EXT1__ <B>[added with <A HREF="index_ext1.html#TR24731">TR24731</A>]</B>
typedef int <A HREF="#errno_t"><B>errno_t</B></A>;
typedef size_t <A HREF="#rsize_t"><B>rsize_t</B></A>;

errno_t <A HREF="#fopen_s"><B>fopen_s</B></A>(FILE *restrict *restrict pstream,
    const char *restrict filename, const char *restrict mode);
errno_t <A HREF="#freopen_s"><B>freopen_s</B></A>(FILE *restrict *restrict pstream,
    const char *restrict filename, const char *restrict mode,
    FILE *restrict stream);

int <A HREF="#fprintf_s"><B>fprintf_s</B></A>(FILE *restrict stream,
    const char *restrict format, ...);
int <A HREF="#fscanf_s"><B>fscanf_s</B></A>(FILE *restrict stream,
    const char *restrict format, ...);
int <A HREF="#printf_s"><B>printf_s</B></A>(const char *restrict format, ...);
int <A HREF="#scanf_s"><B>scanf_s</B></A>(const char *restrict format, ...);
int <A HREF="#snprintf_s"><B>snprintf_s</B></A>(char *restrict s, rsize_t n,
    const char *restrict format, ...);
int <A HREF="#sscanf_s"><B>sscanf_s</B></A>(const char *restrict s,
    const char *restrict format, ...);
int <A HREF="#sprintf_s"><B>sprintf_s</B></A>(char *restrict s, rsize_t n,
    const char *restrict format, ...);
int <A HREF="#vfprintf_s"><B>vfprintf_s</B></A>(FILE *restrict stream,
    const char *restrict format,
    va_list ap);
int <A HREF="#vfscanf_s"><B>vfscanf_s</B></A>(FILE *restrict stream,
    const char *restrict format,
    va_list ap);
int <A HREF="#vprintf_s"><B>vprintf_s</B></A>(const char *restrict format,
    va_list ap);
int <A HREF="#vscanf_s"><B>vscanf_s</B></A>(const char *restrict format,
    va_list ap);
int <A HREF="#vsnprintf_s"><B>vsnprintf_s</B></A>(char *restrict s, rsize_t n,
    const char *restrict format,
    va_list ap);
int <A HREF="#vsprintf_s"><B>vsprintf_s</B></A>(char *restrict s, rsize_t n,
    const char *restrict format,
    va_list ap);
int <A HREF="#vsscanf_s"><B>vsscanf_s</B></A>(const char *restrict s,
    const char *restrict format,
    va_list ap);

char *<A HREF="#gets_s"><B>gets_s</B></A>(char *s, rsize_t n);
#endif /* __STDC_WANT_LIB_EXT1__ */</PRE>

<H2><A NAME="BUFSIZ"></A><CODE>BUFSIZ</CODE></H2>

<PRE>#define <B>BUFSIZ</B> <I>&lt;integer constant expression &gt;= 256&gt;</I></PRE>

<P>The macro yields the size of the stream buffer used by
<A HREF="#setbuf"><CODE>setbuf</CODE></A>.</P>

<H2><A NAME="clearerr"></A><CODE>clearerr</CODE></H2>

<PRE>void <B>clearerr</B>(FILE *stream);</PRE>

<P>The function clears the end-of-file and error indicators for
the stream <CODE>stream</CODE>.</P>

<H2><A NAME="EOF"></A><CODE>EOF</CODE></H2>

<PRE>#define <B>EOF</B> <I>&lt;integer constant expression &lt; 0&gt;</I></PRE>

<P>The macro yields the return value used to signal the end of
a stream or to report an error condition.</P>

<H2><A NAME="errno_t"></A><CODE>errno_t</CODE></H2>

<PRE>typedef int <B>errno_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <I>int,</I> used to represent
a value that can be stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="fclose"></A><CODE>fclose</CODE></H2>

<PRE>int <B>fclose</B>(FILE *stream);</PRE>

<P>The function closes the file associated with
the stream <CODE>stream</CODE>.
It returns zero if successful; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
<CODE>fclose</CODE> writes any buffered output to the file,
deallocates the stream buffer if it was automatically allocated,
and removes the association between the stream and the file.
Do not use the value of <CODE>stream</CODE> in subsequent expressions.</P>

<H2><A NAME="fdopen"></A><CODE>fdopen</CODE></H2>

<PRE>FILE *<B>fdopen</B>(int fd, const char *mode); <B>[non-standard]</B></PRE>

<P>The function creates an object controlling a stream and relates the stream to the file handle <CODE>fd</CODE> of FIOS2.  The function returns a pointer to the created object.</P>
<P>The value of <CODE>fd</CODE> must be obtained by <A HREF="#fileno"><CODE>fileno</CODE></A> or by <CODE>sceFiosFHOpenSync</CODE> of FIOS2.</P>
<P>The initial characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files_and_Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text_and_Binary_Streams">text or binary</A>.
The initial characters available for <CODE>mode</CODE> are the same as those for <CODE>fopen</CODE>.  Even if the initial characters starting from <CODE>&quot;w&quot;</CODE> are specified, the file is not truncated.  The function does not duplicate <CODE>fd</CODE>.  When the stream created by this function is closed, the file handle is also closed.</P>
<P>The way of manipulation specified by <CODE>mode</CODE> must match that for the file handle.  The function does not check the consistency between them.</P>
<P>If the value of <CODE>fd</CODE> is invalid, or if an error occurs, the function returns a null pointer and stores an error code in <CODE>errno</CODE>.</P>

<H2><A NAME="feof"></A><CODE>feof</CODE></H2>

<PRE>int <B>feof</B>(FILE *stream);</PRE>

<P>The function returns a nonzero value if the end-of-file indicator
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="ferror"></A><CODE>ferror</CODE></H2>

<PRE>int <B>ferror</B>(FILE *stream);</PRE>

<P>The function returns a nonzero value if the error indicator
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="fflush"></A><CODE>fflush</CODE></H2>

<PRE>int <B>fflush</B>(FILE *stream);</PRE>

<P>The function writes any buffered output to the file associated
with the stream <CODE>stream</CODE> and returns zero if successful;
otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
If <CODE>stream</CODE> is a null pointer, <CODE>fflush</CODE>
writes any buffered output to all files opened for output.</P>

<H2><A NAME="fgetc"></A><CODE>fgetc</CODE></H2>

<PRE>int <B>fgetc</B>(FILE *stream);</PRE>

<P>The function reads the next character <CODE>c</CODE> (if present)
from the input stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the
function sets either the end-of-file indicator or the error indicator,
it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fgetpos"></A><CODE>fgetpos</CODE></H2>

<PRE>int <B>fgetpos</B>(FILE *restrict stream, fpos_t *restrict pos);</PRE>

<P>The function stores the
file-position indicator for the stream
<CODE>stream</CODE> in <CODE>*pos</CODE> and returns zero if successful;
otherwise, the function stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns a
nonzero value.</P>

<H2><A NAME="fgets"></A><CODE>fgets</CODE></H2>

<PRE>char *<B>fgets</B>(char *restrict s, int n, FILE *restrict stream);</PRE>

<P>The function reads characters from the input stream <CODE>stream</CODE>
and stores them in successive elements of the array
beginning at <CODE>s</CODE>
and continuing until it stores <CODE>n-1</CODE> characters,
stores an <CODE><I>NL</I></CODE> character,
or sets the end-of-file or error indicators. If <CODE>fgets</CODE>
stores any characters, it concludes by storing a null character in
the next element of the array. It returns <CODE>s</CODE> if it stores any
characters and it has not set the error indicator for the stream;
otherwise, it returns a null pointer. If it sets the error indicator,
the array contents are indeterminate.</P>

<H2><A NAME="FILE"></A><CODE>FILE</CODE></H2>

<PRE>typedef <I>o-type</I> <B>FILE</B>;</PRE>

<P>The type is an object type <CODE><I>o-type</I></CODE> that stores all
<A HREF="lib_file.html#Controlling_Streams">control information</A>
for a stream. The functions
<A HREF="#fdopen"><CODE>fdopen</CODE></A>,
<A HREF="#fopen"><CODE>fopen</CODE></A>,
<A HREF="#freopen"><CODE>freopen</CODE></A>,
<A HREF="#sceLibcFopenWithFD"><CODE>sceLibcFopenWithFD</CODE></A> and
<A HREF="#sceLibcFopenWithFH"><CODE>sceLibcFopenWithFH</CODE></A>
allocate all <CODE>FILE</CODE> objects used by the read and write functions.</P>

<H2><A NAME="FILENAME_MAX"></A><CODE>FILENAME_MAX</CODE></H2>

<PRE>#define <B>FILENAME_MAX</B> <I>&lt;integer constant expression &gt; 0&gt;</I></PRE>

<P>The macro yields the maximum size array of characters that you
must provide to hold a
<A HREF="lib_over.html#filename">filename</A>.</P>

<H2><A NAME="fileno"></A><CODE>fileno</CODE></H2>

<PRE>int <B>fileno</B>(FILE *stream); <B>[non-standard]</B></PRE>

<P>The function returns the file handle of FIOS2 associated with <CODE>stream</CODE>. If <CODE>stream</CODE> is a null pointer, the function returns -1.</P>
<P>If the value of <CODE>stream</CODE> is invalid, the behavior is undefined.</P>

<H2><A NAME="fopen"></A><CODE>fopen</CODE></H2>

<PRE>FILE *<B>fopen</B>(const char *restrict filename, const char *restrict mode);</PRE>

<P>The function opens the file with the filename <CODE>filename</CODE>,
associates it with a stream, and returns a pointer to the object controlling
the stream. If the open fails, it returns a null pointer. The initial
characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files_and_Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text_and_Binary_Streams">text or binary</A>.
The initial characters must be one of the following sequences:</P>

<UL>
<LI><B><CODE>"r"</CODE></B> -- to open an existing text file for reading</LI>

<LI><B><CODE>"w"</CODE></B> -- to create a text file or to open and truncate
an existing text file, for writing</LI>

<LI><B><CODE>"a"</CODE></B> -- to create a text file or to open
an existing text file, for writing. The
file-position indicator is positioned
at the end of the file before each write</LI>

<LI><B><CODE>"rb"</CODE></B> -- to open an existing binary file for reading</LI>

<LI><B><CODE>"wb"</CODE></B> -- to create a binary file or to open and truncate
an existing binary file, for writing</LI>

<LI><B><CODE>"ab"</CODE></B> -- to create a binary file or to open an existing
binary file, for writing. The
file-position indicator is positioned
at the end of the file (possibly after arbitrary null byte padding)
before each write</LI>

<LI><B><CODE>"r+"</CODE></B> -- to open an existing text file for reading
and writing</LI>

<LI><B><CODE>"w+"</CODE></B> -- to create a text file or to open and truncate
an existing text file, for reading and writing</LI>

<LI><B><CODE>"a+"</CODE></B> -- to create a text file or to open an existing
text file, for reading and writing. The
file-position indicator is positioned
at the end of the file before each write</LI>

<LI><B><CODE>"r+b"</CODE></B> or <B><CODE>"rb+"</CODE></B> -- to open an existing binary
file for reading and writing</LI>

<LI><B><CODE>"w+b"</CODE></B> or <B><CODE>"wb+"</CODE></B> -- to create a binary file or
to open and truncate an existing binary file, for reading and writing</LI>

<LI><B><CODE>"a+b"</CODE></B> or <B><CODE>"ab+"</CODE></B> -- to create a binary file or
to open an existing binary file, for reading and writing. The
file-position indicator is positioned
at the end of the file (possibly after arbitrary
null byte padding) before each write</LI>
</UL>

<P>If you open a file for both reading and writing, the target
environment can open a binary file instead of a text file. If the
file is not interactive, the stream is fully buffered.</P>

<H2><A NAME="fopen_s"></A><CODE>fopen_s</CODE></H2>

<PRE>errno_t <B>fopen_s</B>(FILE *restrict *restrict pstream,
    const char *restrict filename, const char *restrict mode); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>pstream</CODE> is a null pointer</LI>

<LI><CODE>filename</CODE> is a null pointer</LI>

<LI><CODE>mode</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns the error code
it reported to the constraint handler.</P>

<P>Otherwise, the function opens the file with the filename
<CODE>filename</CODE>, as if by evaluating
<CODE>*pstream = <A HREF="#fopen">fopen(filename, mode)</A></CODE>, except that
the file is opened with exclusive (non-shared) access, if possible, and:</P>

<UL>
<LI>if <CODE>mode[0] == 'u'</CODE> the second argument to <CODE>fopen</CODE>
is <CODE>mode + 1</CODE> and the file is left with system default access
permissions (like <CODE>fopen</CODE>)</LI>

<LI>if <CODE>mode[0] != 'u'</CODE> the second argument to <CODE>fopen</CODE>
is <CODE>mode</CODE> and the file is left with access permissions that
prevent other users from accessing it, if possible</LI>
</UL>

<P>The function returns zero only if the open succeeds.</P>

<H2><A NAME="FOPEN_MAX"></A><CODE>FOPEN_MAX</CODE></H2>

<PRE>#define <B>FOPEN_MAX</B> <I>&lt;integer constant expression &gt;= 8&gt;</I></PRE>

<P>The macro yields the maximum number of files that the target
environment permits to be simultaneously open (including
<A HREF="#stderr"><CODE>stderr</CODE></A>,
<A HREF="#stdin"><CODE>stdin</CODE></A>, and
<A HREF="#stdout"><CODE>stdout</CODE></A>).</P>

<P><B>NOTE:</B> <A HREF="index.html#C_Standard">C Standard</A> describes that
<CODE>FOPEN_MAX</CODE> means the minimum number of files that
the implementation guarantees to be simultaneously open.
In this implementation, however, it means
&quot;the maximum number of files that are permitted to be simultaneously open&quot;.
It is not guaranteed to open files up to the maximum number.</P>

<H2><A NAME="fpos_t"></A><CODE>fpos_t</CODE></H2>

<PRE>typedef <I>o-type</I> <B>fpos_t</B>;</PRE>

<P>The type is an object type <CODE><I>o-type</I></CODE>
of an object that you declare to hold the value of a
file-position indicator stored by
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A> and accessed by
<A HREF="#fgetpos"><CODE>fgetpos</CODE></A>.</P>

<H2><A NAME="fprintf"></A><CODE>fprintf</CODE></H2>

<PRE>int <B>fprintf</B>(FILE *restrict stream, const char *restrict format, ...);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE>
conversion specifier is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>. It returns the
number of characters generated, or it returns a negative value if
the function sets the error indicator for the stream.</P>

<H2><A NAME="fprintf_s"></A><CODE>fprintf_s</CODE></H2>

<PRE>int <B>fprintf_s</B>(FILE *restrict stream,
    const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>. It returns the
number of characters generated, or it returns a negative value if
the function sets the error indicator for the stream.</P>

<H2><A NAME="fputc"></A><CODE>fputc</CODE></H2>

<PRE>int <B>fputc</B>(int c, FILE *stream);</PRE>

<P>The function writes the character <CODE>(unsigned char)c</CODE> to
the output stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the function
sets the error indicator for the stream, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fputs"></A><CODE>fputs</CODE></H2>

<PRE>int <B>fputs</B>(const char *restrict s, FILE *restrict stream);</PRE>

<P>The function accesses characters from the
<A HREF="lib_over.html#C_string">C string</A> <CODE>s</CODE> and
writes them to the output stream <CODE>stream</CODE>. The function does
not write the terminating null character. It returns a nonnegative
value if it has not set the error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fread"></A><CODE>fread</CODE></H2>

<PRE>size_t <B>fread</B>(void *restrict ptr,
    size_t size, size_t nelem, FILE *restrict stream);</PRE>

<P>The function reads characters from the input stream <CODE>stream</CODE>
and stores them in successive elements of the array whose first element
has the address <CODE>(char *)ptr</CODE>
until the function stores <CODE>size*nelem</CODE>
characters or sets the end-of-file or error indicator. It returns
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it read.
If <CODE>n</CODE> is not a multiple of <CODE>size</CODE>,
the value stored in the last element is indeterminate.
If the function sets the error indicator, the
file-position indicator is indeterminate.</P>

<H2><A NAME="freopen"></A><CODE>freopen</CODE></H2>

<PRE>FILE *<B>freopen</B>(const char *restrict filename, const char *restrict mode,
    FILE *stream);</PRE>

<P>The function closes the file associated with
the stream <CODE>stream</CODE> (as if by calling
<A HREF="#fclose"><CODE>fclose</CODE></A>);
then it opens the file with the filename <CODE>filename</CODE>
and associates the file with the stream <CODE>stream</CODE>
(as if by calling
<CODE><A HREF="#fopen">fopen</A>(filename, mode)</CODE>).
It returns <CODE>stream</CODE> if the open is successful;
otherwise, it returns a null pointer.</P>

<P>If <CODE>filename</CODE> is a null pointer, <A HREF="index.html#C_Standard">C Standard</A> describes that the mode of the stream is updated, as if the name of the file currently associated with <CODE>stream</CODE> were specified to <CODE>filename</CODE>.
In PlayStation&reg;Vita, however, <CODE>freopen</CODE> fails and returns a null pointer.
Also <CODE>EINVAL</CODE> is set to <A HREF="errno.html#errno"><CODE>errno</CODE></A>.</P>

<H2><A NAME="freopen_s"></A><CODE>freopen_s</CODE></H2>

<PRE>errno_t <B>freopen_s</B>(FILE *restrict *restrict pstream,
    const char *restrict filename, const char *restrict mode,
    FILE *stream); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>pstream</CODE> is a null pointer</LI>

<LI><CODE>mode</CODE> is a null pointer</LI>

<LI><CODE>stream</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns the error code
it reported to the constraint handler.</P>

<P>Otherwise, if <CODE>filename</CODE> is a null pointer, it is effectively set to
the name of the opened file controlled by <CODE>stream</CODE>, if possible.</P>

<P>The function reopens the file with the filename <CODE>filename</CODE>,
as if by evaluating
<CODE>*pstream = <A HREF="#freopen">freopen(filename, mode)</A></CODE>.
It returns zero only if the open succeeds.</P>

<H2><A NAME="fscanf"></A><CODE>fscanf</CODE></H2>

<PRE>int <B>fscanf</B>(FILE *restrict stream, const char *restrict format, ...);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<H2><A NAME="fscanf_s"></A><CODE>fscanf_s</CODE></H2>

<PRE>int <B>fscanf_s</B>(FILE *restrict stream,
    const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P><B><A NAME="additional_scan_checking"></A>Additional checking</B>
occurs for the scan conversion specifiers <CODE>c</CODE>, <CODE>s</CODE>,
and <CODE>[</CODE>. Each of these conversion specifiers consumes an
additional argument, of type
<CODE><A HREF="#rsize_t">rsize_t</A></CODE>, that specifies the maximum
number of elements <CODE>N</CODE> that can be stored in the array object.
It is a runtime constraint violation if <CODE>N</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>, or if
the number of elements to be stored is greater than <CODE>N</CODE>.</P>

<H2><A NAME="fseek"></A><CODE>fseek</CODE></H2>

<PRE>int <B>fseek</B>(FILE *stream, long offset, int mode);</PRE>

<P>The function sets the
file-position indicator for the stream
<CODE>stream</CODE> (as specified by
<CODE>offset</CODE> and <CODE>mode</CODE>), clears
the end-of-file indicator for the stream, and returns zero if successful.</P>

<P>For a
<A HREF="lib_file.html#binary_stream">binary stream</A>,
<CODE>offset</CODE> is a signed offset in bytes:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE>
to the file-position indicator for the beginning of the file.</LI>

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the current
file-position indicator.</LI>

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the
file-position indicator for the end of the file
(possibly after arbitrary null character padding).</LI>
</UL>

<P><CODE>fseek</CODE> sets the file-position indicator to the result
of this addition.</P>

<P>For a
<A HREF="lib_file.html#text_stream">text stream</A>:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> sets the
file-position indicator to the value encoded
in <CODE>offset</CODE>, which is either a value returned
by an earlier successful call to
<A HREF="#ftell"><CODE>ftell</CODE></A>
or zero to indicate the beginning of the file.</LI>

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> leaves the
file-position indicator at its current value.</LI>

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> sets the
file-position indicator to indicate the end of the file.</LI>
</UL>

<P>The function defines no other combination of argument values.</P>

<H2><A NAME="fsetpos"></A><CODE>fsetpos</CODE></H2>

<PRE>int <B>fsetpos</B>(FILE *stream, const fpos_t *pos);</PRE>

<P>The function sets the file-position indicator for the stream
<CODE>stream</CODE> to the value stored in <CODE>*pos</CODE>,
clears the end-of-file indicator for the stream,
and returns zero if successful. Otherwise,
the function stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns a nonzero value.</P>

<H2><A NAME="ftell"></A><CODE>ftell</CODE></H2>

<PRE>long <B>ftell</B>(FILE *stream);</PRE>

<P>The function returns an encoded form of the file-position indicator
for the stream <CODE>stream</CODE> or stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
the value -1. For a binary file, a successful return
value gives the number of bytes from the beginning of the file. For
a text file, target environments can vary on the representation and
range of encoded file-position indicator values.</P>

<H2><A NAME="fwrite"></A><CODE>fwrite</CODE></H2>

<PRE>size_t <B>fwrite</B>(const void *restrict ptr,
    size_t size, size_t nelem, FILE *stream);</PRE>

<P>The function writes characters to the output stream <CODE>stream</CODE>,
accessing values from successive elements of the array whose first
element has the address <CODE>(char *)ptr</CODE> until the function writes
<CODE>size*nelem</CODE> characters or sets the error indicator. It returns
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it wrote.
If the function sets the error indicator,
the file-position indicator is indeterminate.</P>

<H2><A NAME="getc"></A><CODE>getc</CODE></H2>

<PRE>int <B>getc</B>(FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stream)</CODE> except
that a macro version of <CODE>getc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="getchar"></A><CODE>getchar</CODE></H2>

<PRE>int <B>getchar</B>(void);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stdin)</CODE>,
reading a character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A></P>

<H2><A NAME="gets"></A><CODE>gets</CODE></H2>

<PRE>char *<B>gets</B>(char *s);</PRE>

<P><B>NOTE:</B> Use of this function is not recommended because of a security reason. Use <A HREF="#gets_s"><CODE>gets_s</CODE></A> instead.</P>

<P>The function reads characters from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>
and stores them in successive elements of the array whose first element
has the address <CODE>s</CODE> until the function reads
an <CODE><I>NL</I></CODE> character
(which is not stored) or sets the end-of-file or error indicator.
If <CODE>gets</CODE> reads any characters, it concludes by storing a null
character in the next element of the array. It returns <CODE>s</CODE> if
it reads any characters and has not set the error indicator for the
stream; otherwise, it returns a null pointer. If it sets the error
indicator, the array contents are indeterminate. The number of characters
that <CODE>gets</CODE> reads and stores cannot be limited. Use
<A HREF="#fgets"><CODE>fgets</CODE></A> instead.</P>

<H2><A NAME="gets_s"></A><CODE>gets_s</CODE></H2>

<PRE>char *<B>gets_s</B>(char *s, rsize_t n); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is zero or greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI>the function reads <CODE>n - 1</CODE> characters without
encountering an <CODE><I>NL</I></CODE> character, end of file,
or a read error</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null character at <CODE>s[0]</CODE>. It then returns a null pointer,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function reads characters from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>
and stores them in successive elements of the array whose first element
has the address <CODE>s</CODE> until the function reads
an <CODE><I>NL</I></CODE> character
(which is not stored) or sets the end-of-file or error indicator.
If <CODE>gets_s</CODE> reads any characters, it concludes by storing a null
character in the next element of the array. It returns <CODE>s</CODE> if
it reads any characters and has not set the error indicator for the
stream; otherwise, it stores a null character at <CODE>s[0]</CODE>
and returns a null pointer.</P>

<H2><A NAME="_IOFBF"></A><CODE>_IOFBF</CODE></H2>

<PRE>#define <B>_IOFBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="full_buffering"></A>full buffering</B>.
(Flush the stream buffer only when it fills.)</P>

<H2><A NAME="_IOLBF"></A><CODE>_IOLBF</CODE></H2>

<PRE>#define <B>_IOLBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="line_buffering"></A>line buffering</B>.
(Flush the stream buffer at the end of a
<A HREF="lib_file.html#text_lines">text line</A>.)</P>

<H2><A NAME="_IONBF"></A><CODE>_IONBF</CODE></H2>

<PRE>#define <B>_IONBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="no_buffering"></A>no buffering</B>.
(Flush the stream buffer at the end of each write operation.)</P>

<H2><A NAME="NULL"></A><CODE>NULL</CODE></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address_constant_expression">
address constant expression</A>.</P>

<H2><A NAME="perror"></A><CODE>perror</CODE></H2>

<PRE>void <B>perror</B>(const char *s);</PRE>

<P>The function writes a line of text to the stream
<A HREF="#stderr"><CODE>stderr</CODE></A>.
If <CODE>s</CODE> is not a null pointer,
the function first writes the
<A HREF="lib_over.html#C_string">C string</A> <CODE>s</CODE>
(as if by calling
<CODE><A HREF="#fputs">fputs</A>(s, stderr)</CODE>),
followed by a colon (<CODE>:</CODE>) and a <CODE><I>space</I></CODE>.
It then writes the same message
<A HREF="lib_over.html#C_string">C string</A> that is returned by
<CODE><A HREF="string.html#strerror">strerror</A>(errno)</CODE>,
converting the value stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>,
followed by an <CODE><I>NL</I></CODE>.</P>

<H2><A NAME="printf"></A><CODE>printf</CODE></H2>

<PRE>int <B>printf</B>(const char *restrict format, ...);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or it returns a negative value if the function
sets the error indicator for the stream.</P>

<H2><A NAME="printf_s"></A><CODE>printf_s</CODE></H2>

<PRE>int <B>printf_s</B>(const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or it returns a negative value if the function
sets the error indicator for the stream.</P>

<H2><A NAME="putc"></A><CODE>putc</CODE></H2>

<PRE>int <B>putc</B>(int c, FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stream)</CODE>
except that a macro version of <CODE>putc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="putchar"></A><CODE>putchar</CODE></H2>

<PRE>int <B>putchar</B>(int c);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stdout)</CODE>,
writing a character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.</P>

<H2><A NAME="puts"></A><CODE>puts</CODE></H2>

<PRE>int <B>puts</B>(const char *s);</PRE>

<P>The function accesses characters from the
<A HREF="lib_over.html#C_string">C string</A> <CODE>s</CODE> and
writes them to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>. The function writes
an <CODE><I>NL</I></CODE> character to the stream
in place of the terminating null character.
It returns a nonnegative value if it has not set the
error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="remove"></A><CODE>remove</CODE></H2>

<PRE>int <B>remove</B>(const char *filename);</PRE>

<P>The function removes the file with the filename <CODE>filename</CODE>
and returns zero if successful.
If the file is open when you remove it,
the result is implementation defined. After you remove it, you
cannot open it as an existing file.</P>

<H2><A NAME="rename"></A><CODE>rename</CODE></H2>

<PRE>int <B>rename</B>(const char *old, const char *new);</PRE>

<P>The function renames the file with the filename <CODE>old</CODE> to
have the filename <CODE>new</CODE> and returns zero if successful. If a
file with the filename <CODE>new</CODE> already exists,
the result is implementation defined.
After you rename it, you cannot open the file
with the filename <CODE>old</CODE>.</P>

<H2><A NAME="rewind"></A><CODE>rewind</CODE></H2>

<PRE>void <B>rewind</B>(FILE *stream);</PRE>

<P>The function calls
<CODE><A HREF="#fseek">fseek</A>(stream, 0L, SEEK_SET)</CODE>
and then clears the error indicator for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="rsize_t"></A><CODE>rsize_t</CODE></H2>

<PRE>typedef size_t <B>rsize_t</B>; <B>[added with TR24731]</B></PRE>

<P>The type is a synonym for <CODE>size_t</CODE>,
used to represent a function argument to be checked on entry
to a function. It is a
<A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
for an argument of type <CODE>rsize_t</CODE> to be greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE>.</P>

<H2><A NAME="scanf"></A><CODE>scanf</CODE></H2>

<PRE>int <B>scanf</B>(const char *restrict format, ...);</PRE>

<P><B>NOTE:</B> Use of this function is not recommended because of a security reason. Use <A HREF="#scanf_s"><CODE>scanf_s</CODE></A> instead.</P>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<H2><A NAME="scanf_s"></A><CODE>scanf_s</CODE></H2>

<PRE>int <B>scanf_s</B>(const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<H2><A NAME="sceLibcFopenWithFD"></A><CODE>sceLibcFopenWithFD</CODE></H2>

<PRE>FILE *<B>sceLibcFopenWithFD</B>(int fd, const char *mode); <B>[non-standard]</B></PRE>

<P>The function creates an object controlling a stream and relates the stream to the file descriptor <CODE>fd</CODE>.  The function returns a pointer to the created object.</P>
<P>The value of <CODE>fd</CODE> must be obtained by <A HREF="#sceLibcGetFD"><CODE>sceLibcGetFD</CODE></A> or by <CODE>sceKernelOpen</CODE> of the kernel.</P>
<P>The initial characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files_and_Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text_and_Binary_Streams">text or binary</A>.
The initial characters available for <CODE>mode</CODE> are the same as those for <CODE>fopen</CODE>.  Even if the initial characters starting from <CODE>&quot;w&quot;</CODE> are specified, the file is not truncated.  The function does not duplicate <CODE>fd</CODE>.  When the stream created by this function is closed, the file descriptor is also closed.</P>
<P>The way of manipulation specified by <CODE>mode</CODE> must match that for the file descriptor.  The function does not check the consistency between them.</P>
<P>If the value of <CODE>fd</CODE> is invalid, or if an error occurs, the function returns a null pointer and stores an error code in <CODE>errno</CODE>.</P>

<H2><A NAME="sceLibcFopenWithFH"></A><CODE>sceLibcFopenWithFH</CODE></H2>

<PRE>FILE *<B>sceLibcFopenWithFH</B>(int fh, const char *mode); <B>[non-standard]</B></PRE>

<P>The function creates an object controlling a stream and relates the stream to the file handle <CODE>fh</CODE> of FIOS2.  The function returns a pointer to the created object.</P>
<P>The value of <CODE>fh</CODE> must be obtained by <A HREF="#sceLibcGetFH"><CODE>sceLibcGetFH</CODE></A> or by <CODE>sceFiosFHOpenSync</CODE> of FIOS2.</P>
<P>The initial characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files_and_Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text_and_Binary_Streams">text or binary</A>.
The initial characters available for <CODE>mode</CODE> are the same as those for <CODE>fopen</CODE>.  Even if the initial characters starting from <CODE>&quot;w&quot;</CODE> are specified, the file is not truncated.  The function does not duplicate <CODE>fh</CODE>.  When the stream created by this function is closed, the file handle is also closed.</P>
<P>The way of manipulation specified by <CODE>mode</CODE> must match that for the file handle.  The function does not check the consistency between them.</P>
<P>If the value of <CODE>fh</CODE> is invalid, or if an error occurs, the function returns a null pointer and stores an error code in <CODE>errno</CODE>.</P>

<H2><A NAME="sceLibcGetFD"></A><CODE>sceLibcGetFD</CODE></H2>

<PRE>int <B>sceLibcGetFD</B>(FILE *stream); <B>[non-standard]</B></PRE>

<P>The function returns the file descriptor associated with <CODE>stream</CODE>. If <CODE>stream</CODE> is a null pointer, the function returns -1.</P>
<P>If the value of <CODE>stream</CODE> is invalid, the behavior is undefined.</P>

<H2><A NAME="sceLibcGetFH"></A><CODE>sceLibcGetFH</CODE></H2>

<PRE>int <B>sceLibcGetFH</B>(FILE *stream); <B>[non-standard]</B></PRE>

<P>The function returns the file handle of FIOS2 associated with <CODE>stream</CODE>. If <CODE>stream</CODE> is a null pointer, the function returns -1.</P>
<P>If the value of <CODE>stream</CODE> is invalid, the behavior is undefined.</P>

<H2><A NAME="SEEK_CUR"></A><CODE>SEEK_CUR</CODE></H2>

<PRE>#define <B>SEEK_CUR</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the current
file-position indicator.</P>

<H2><A NAME="SEEK_END"></A><CODE>SEEK_END</CODE></H2>

<PRE>#define <B>SEEK_END</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the end of the file.</P>

<H2><A NAME="SEEK_SET"></A><CODE>SEEK_SET</CODE></H2>

<PRE>#define <B>SEEK_SET</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the beginning of the file.</P>

<H2><A NAME="setbuf"></A><CODE>setbuf</CODE></H2>

<PRE>void <B>setbuf</B>(FILE *restrict stream, char *restrict buf);</PRE>

<P>If <CODE>buf</CODE> is not a null pointer, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream, buf,
_IOFBF, BUFSIZ)</CODE>,
specifying full buffering with
<A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A>
and a buffer size of
<A HREF="#BUFSIZ"><CODE>BUFSIZ</CODE></A> characters.
Otherwise, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream,
0, _IONBF, BUFSIZ)</CODE>,
specifying no buffering with
<A HREF="#_IONBF"><CODE>_IONBF</CODE></A>.</P>

<H2><A NAME="setvbuf"></A><CODE>setvbuf</CODE></H2>

<PRE>int <B>setvbuf</B>(FILE *restrict stream, char *restrict buf, int mode,
    size_t size);</PRE>

<P>The function sets the buffering mode for the stream <CODE>stream</CODE>
according to <CODE>buf</CODE>, <CODE>mode</CODE>, and <CODE>size</CODE>.
It returns zero if successful.
If <CODE>buf</CODE> is not a null pointer, then <CODE>buf</CODE>
is the address of the first element of an array of <I>char</I> of
size <CODE>size</CODE> that can be used as the stream buffer. Otherwise,
<CODE>setvbuf</CODE> can allocate a stream buffer that is freed when the
file is closed. For <CODE>mode</CODE> you must supply one of the following
values:</P>

<UL>
<LI><B><A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A></B>
-- to indicate full buffering</LI>

<LI><B><A HREF="#_IOLBF"><CODE>_IOLBF</CODE></A></B>
-- to indicate line buffering</LI>

<LI><B><A HREF="#_IONBF"><CODE>_IONBF</CODE></A></B>
-- to indicate no buffering</LI>
</UL>

<P>You must call <CODE>setvbuf</CODE> after you call
<A HREF="#fopen"><CODE>fopen</CODE></A>
to associate a file with that stream and before you call a library
function that performs any other operation on the stream.</P>

<H2><A NAME="size_t"></A><CODE>size_t</CODE></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof_operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="snprintf"></A><CODE>snprintf</CODE></H2>

<PRE>int <B>snprintf</B>(char *restrict s, size_t n,
    const char *restrict format, ...); <B>[added with C99]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
characters and concludes by
storing a null character in the next location of the array. It returns
the number of characters that would have been generated if <CODE>n</CODE> had been large enough, not including the null character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="snprintf_s"></A><CODE>snprintf_s</CODE></H2>

<PRE>int <B>snprintf_s</B>(char *restrict s, rsize_t n,
    const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null character at <CODE>s[0]</CODE>.
It then returns a negative value.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
characters and concludes by
storing a null character in the next location of the array. It returns
the <I>total</I> number of characters generated (even those not stored),
not including the null character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="sprintf"></A><CODE>sprintf</CODE></H2>

<PRE>int <B>sprintf</B>(char *restrict s, const char *restrict format, ...);</PRE>

<P><B>NOTE:</B> Use of this function is not recommended because of a security reason. Use <A HREF="#sprintf_s"><CODE>sprintf_s</CODE></A> instead.</P>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null character in the next location of the array. It returns
the number of characters generated, not including the null character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="sprintf_s"></A><CODE>sprintf_s</CODE></H2>

<PRE>int <B>sprintf_s</B>(char *restrict s, rsize_t n,
    const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>

<LI>the function attempts to generate more than <CODE>n - 1</CODE>
characters</LI>
</UL>

<P>If such a violation occurs, other than the first two,
the function stores a null character in <CODE>s[0]</CODE>. It then
returns zero.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
characters and concludes by
storing a null character in the next location of the array. It returns
the <I>total</I> number of characters generated (even those not stored),
not including the null character,
or a negative value if an encoding error occurs.</P>

<H2><A NAME="sscanf"></A><CODE>sscanf</CODE></H2>

<PRE>int <B>sscanf</B>(const char *restrict s, const char *restrict format, ...);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<H2><A NAME="sscanf_s"></A><CODE>sscanf_s</CODE></H2>

<PRE>int <B>sscanf_s</B>(const char *restrict s, const char *restrict format, ...); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<H2><A NAME="stderr"></A><CODE>stderr</CODE></H2>

<PRE>#define <B>stderr</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
error output stream.</P>

<H2><A NAME="stdin"></A><CODE>stdin</CODE></H2>

<PRE>#define <B>stdin</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
input stream.</P>

<H2><A NAME="stdout"></A><CODE>stdout</CODE></H2>

<PRE>#define <B>stdout</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
output stream.</P>

<H2><A NAME="ungetc"></A><CODE>ungetc</CODE></H2>

<PRE>int <B>ungetc</B>(int c, FILE *stream);</PRE>

<P>If <CODE>c</CODE> is not equal to
<A HREF="#EOF"><CODE>EOF</CODE></A>, the function stores
<CODE>(unsigned char)c</CODE> in the object
whose address is <CODE>stream</CODE>
and clears the end-of-file indicator. If <CODE>c</CODE> equals
<A HREF="#EOF"><CODE>EOF</CODE></A>
or the store cannot occur, the function returns
<A HREF="#EOF"><CODE>EOF</CODE></A>; otherwise,
it returns <CODE>(unsigned char)c</CODE>. A subsequent library function
call that reads a character from the stream <CODE>stream</CODE> obtains
this stored value, which is then forgotten.</P>

<P>Thus, you can effectively
<B><A NAME="push_back"></A>push back</B> a character to a
stream after reading a character. (You need not push back the same
character that you read.) An implementation can let you push back
additional characters before you read the first one. You read the
characters in reverse order of pushing them back to the stream. You
cannot portably:</P>

<UL>
<LI>push back more than one character</LI>

<LI>push back a character if the file-position indicator is at the
beginning of the file</LI>

<LI>Call
<A HREF="#ftell"><CODE>ftell</CODE></A>
for a text file that has a character currently pushed back</LI>
</UL>

<P>A call to the functions
<A HREF="#fseek"><CODE>fseek</CODE></A>,
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A>, or
<A HREF="#rewind"><CODE>rewind</CODE></A>
for the stream causes the stream to forget any pushed-back characters.
For a binary stream, the file-position indicator is decremented for
each character that is pushed back.</P>

<H2><A NAME="vfprintf"></A><CODE>vfprintf</CODE></H2>

<PRE>int <B>vfprintf</B>(FILE *restrict stream, const char *restrict format,
     va_list ap);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>.
It returns the number
of characters generated, or it returns a negative value if the function
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfprintf_s"></A><CODE>vfprintf_s</CODE></H2>

<PRE>int <B>vfprintf_s</B>(FILE *restrict stream, const char *restrict format,
     va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>.
It returns the number
of characters generated, or it returns a negative value if the function
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfscanf"></A><CODE>vfscanf</CODE></H2>

<PRE>int <B>vfscanf</B>(FILE *restrict stream, const char *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vfscanf_s"></A><CODE>vfscanf_s</CODE></H2>

<PRE>int <B>vfscanf_s</B>(FILE *restrict stream, const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>stream</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vprintf"></A><CODE>vprintf</CODE></H2>

<PRE>int <B>vprintf</B>(const char *restrict format,
    va_list ap);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or a negative value if the function sets
the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vprintf_s"></A><CODE>vprintf_s</CODE></H2>

<PRE>int <B>vprintf_s</B>(const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or a negative value if the function sets
the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vscanf"></A><CODE>vscanf</CODE></H2>

<PRE>int <B>vscanf</B>(const char *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vscanf_s"></A><CODE>vscanf_s</CODE></H2>

<PRE>int <B>vscanf_s</B>(const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsnprintf"></A><CODE>vsnprintf</CODE></H2>

<PRE>int <B>vsnprintf</B>(char *restrict s, size_t n, const char *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
characters and concludes by
storing a null character in the next location of the array. It returns
the number of characters that would have been generated if <CODE>n</CODE> had been large enough -- not including the null character.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsnprintf_s"></A><CODE>vsnprintf_s</CODE></H2>

<PRE>int <B>vsnprintf_s</B>(char *restrict s, rsize_t n, const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null character at <CODE>s[0]</CODE>.
It then returns a negative value.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
generated characters in successive locations of the array object whose
first element has the address <CODE>s</CODE>. If <CODE>n</CODE> is zero,
it stores no characters. Otherwise, the function stores up to <CODE>n - 1</CODE>
characters and concludes by
storing a null character in the next location of the array. It returns
the <I>total</I> number of characters generated (even those not stored),
not including the null character,
or a negative value if an encoding error occurs.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsprintf"></A><CODE>vsprintf</CODE></H2>

<PRE>int <B>vsprintf</B>(char *restrict s, const char *restrict format,
    va_list ap);</PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer.
If such a violation occurs, the function returns a negative value,
after producing an unspecified amount of output.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null character in the next location of the array. It returns
the number of characters generated -- not including the null character.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsprintf_s"></A><CODE>vsprintf_s</CODE></H2>

<PRE>int <B>vsprintf_s</B>(char *restrict s, rsize_t n,
    const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>n</CODE> is greater than
<CODE><A HREF="index_ext1.html#RSIZE_MAX">RSIZE_MAX</A></CODE></LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>the argument corresponding to a <CODE>%s</CODE> conversion specifier
is a null pointer</LI>

<LI><CODE>format</CODE> contains a <CODE>%n</CODE> conversion specifier</LI>

<LI>the function generates more than <CODE>n</CODE> characters,
counting the terminating null character</LI>
</UL>

<P>If such a violation occurs, other than the first two, the function
stores a null character at <CODE>s[0]</CODE>.
It then returns zero.</P>

<P>Otherwise, the function
<A HREF="lib_prin.html#Print_Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null character in the next location of the array. It returns
the number of characters generated, not including the null character,
or a negative value if an encoding error occurs.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsscanf"></A><CODE>vsscanf</CODE></H2>

<PRE>int <B>vsscanf</B>(const char *restrict s, const char *restrict format,
    va_list ap); <B>[added with C99]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if any pointer argument after <CODE>format</CODE> is a null pointer.
If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsscanf_s"></A><CODE>vsscanf_s</CODE></H2>

<PRE>int <B>vsscanf_s</B>(const char *restrict s, const char *restrict format,
    va_list ap); <B>[added with TR24731]</B></PRE>

<P>A <A HREF="index_ext1.html#runtime_constraint_violation">runtime constraint violation</A>
occurs if:</P>

<UL>
<LI><CODE>s</CODE> is a null pointer</LI>

<LI><CODE>format</CODE> is a null pointer</LI>

<LI>any pointer argument after <CODE>format</CODE> is a null pointer</LI>
</UL>

<P>If such a violation occurs, the function returns a negative value,
after consuming an unspecified amount of input.</P>

<P>Otherwise, the function
<A HREF="lib_scan.html#Scan_Functions">scans formatted text</A>,
with <A HREF="#additional_scan_checking">additional checking</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table_of_Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
&copy; 2015 Sony Computer Entertainment Inc. All rights reserved.</I></P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &copy; 1992-2013
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V6.42:0216--></BODY></HTML>
